
obc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d0  00800200  00001cc4  00001d58  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001cc4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001816  008002d0  008002d0  00001e28  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001e28  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001e58  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004b8  00000000  00000000  00001e98  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005ad6  00000000  00000000  00002350  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001abc  00000000  00000000  00007e26  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003456  00000000  00000000  000098e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f3c  00000000  00000000  0000cd38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b34  00000000  00000000  0000dc74  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004ea4  00000000  00000000  0000f7a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004a8  00000000  00000000  0001464c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	90 c0       	rjmp	.+288    	; 0x126 <__bad_interrupt>
       6:	00 00       	nop
       8:	8e c0       	rjmp	.+284    	; 0x126 <__bad_interrupt>
       a:	00 00       	nop
       c:	8c c0       	rjmp	.+280    	; 0x126 <__bad_interrupt>
       e:	00 00       	nop
      10:	8a c0       	rjmp	.+276    	; 0x126 <__bad_interrupt>
      12:	00 00       	nop
      14:	88 c0       	rjmp	.+272    	; 0x126 <__bad_interrupt>
      16:	00 00       	nop
      18:	86 c0       	rjmp	.+268    	; 0x126 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	84 c0       	rjmp	.+264    	; 0x126 <__bad_interrupt>
      1e:	00 00       	nop
      20:	82 c0       	rjmp	.+260    	; 0x126 <__bad_interrupt>
      22:	00 00       	nop
      24:	80 c0       	rjmp	.+256    	; 0x126 <__bad_interrupt>
      26:	00 00       	nop
      28:	7e c0       	rjmp	.+252    	; 0x126 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7c c0       	rjmp	.+248    	; 0x126 <__bad_interrupt>
      2e:	00 00       	nop
      30:	7a c0       	rjmp	.+244    	; 0x126 <__bad_interrupt>
      32:	00 00       	nop
      34:	78 c0       	rjmp	.+240    	; 0x126 <__bad_interrupt>
      36:	00 00       	nop
      38:	76 c0       	rjmp	.+236    	; 0x126 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	74 c0       	rjmp	.+232    	; 0x126 <__bad_interrupt>
      3e:	00 00       	nop
      40:	72 c0       	rjmp	.+228    	; 0x126 <__bad_interrupt>
      42:	00 00       	nop
      44:	c5 c3       	rjmp	.+1930   	; 0x7d0 <__vector_17>
      46:	00 00       	nop
      48:	6e c0       	rjmp	.+220    	; 0x126 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6c c0       	rjmp	.+216    	; 0x126 <__bad_interrupt>
      4e:	00 00       	nop
      50:	6a c0       	rjmp	.+212    	; 0x126 <__bad_interrupt>
      52:	00 00       	nop
      54:	68 c0       	rjmp	.+208    	; 0x126 <__bad_interrupt>
      56:	00 00       	nop
      58:	66 c0       	rjmp	.+204    	; 0x126 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	64 c0       	rjmp	.+200    	; 0x126 <__bad_interrupt>
      5e:	00 00       	nop
      60:	62 c0       	rjmp	.+196    	; 0x126 <__bad_interrupt>
      62:	00 00       	nop
      64:	60 c0       	rjmp	.+192    	; 0x126 <__bad_interrupt>
      66:	00 00       	nop
      68:	5e c0       	rjmp	.+188    	; 0x126 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5c c0       	rjmp	.+184    	; 0x126 <__bad_interrupt>
      6e:	00 00       	nop
      70:	5a c0       	rjmp	.+180    	; 0x126 <__bad_interrupt>
      72:	00 00       	nop
      74:	58 c0       	rjmp	.+176    	; 0x126 <__bad_interrupt>
      76:	00 00       	nop
      78:	56 c0       	rjmp	.+172    	; 0x126 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	54 c0       	rjmp	.+168    	; 0x126 <__bad_interrupt>
      7e:	00 00       	nop
      80:	52 c0       	rjmp	.+164    	; 0x126 <__bad_interrupt>
      82:	00 00       	nop
      84:	50 c0       	rjmp	.+160    	; 0x126 <__bad_interrupt>
      86:	00 00       	nop
      88:	4e c0       	rjmp	.+156    	; 0x126 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4c c0       	rjmp	.+152    	; 0x126 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 12 0e 	jmp	0x1c24	; 0x1c24 <__vector_36>
      94:	48 c0       	rjmp	.+144    	; 0x126 <__bad_interrupt>
      96:	00 00       	nop
      98:	46 c0       	rjmp	.+140    	; 0x126 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	44 c0       	rjmp	.+136    	; 0x126 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	42 c0       	rjmp	.+132    	; 0x126 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	40 c0       	rjmp	.+128    	; 0x126 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3e c0       	rjmp	.+124    	; 0x126 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3c c0       	rjmp	.+120    	; 0x126 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	3a c0       	rjmp	.+116    	; 0x126 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	38 c0       	rjmp	.+112    	; 0x126 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	36 c0       	rjmp	.+108    	; 0x126 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	34 c0       	rjmp	.+104    	; 0x126 <__bad_interrupt>
      be:	00 00       	nop
      c0:	32 c0       	rjmp	.+100    	; 0x126 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	30 c0       	rjmp	.+96     	; 0x126 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2e c0       	rjmp	.+92     	; 0x126 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2c c0       	rjmp	.+88     	; 0x126 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	2a c0       	rjmp	.+84     	; 0x126 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	28 c0       	rjmp	.+80     	; 0x126 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	26 c0       	rjmp	.+76     	; 0x126 <__bad_interrupt>
      da:	00 00       	nop
      dc:	24 c0       	rjmp	.+72     	; 0x126 <__bad_interrupt>
      de:	00 00       	nop
      e0:	22 c0       	rjmp	.+68     	; 0x126 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e4 ec       	ldi	r30, 0xC4	; 196
      fc:	fc e1       	ldi	r31, 0x1C	; 28
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a0 3d       	cpi	r26, 0xD0	; 208
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	2a e1       	ldi	r18, 0x1A	; 26
     110:	a0 ed       	ldi	r26, 0xD0	; 208
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a6 3e       	cpi	r26, 0xE6	; 230
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 2d 0c 	call	0x185a	; 0x185a <main>
     122:	0c 94 60 0e 	jmp	0x1cc0	; 0x1cc0 <_exit>

00000126 <__bad_interrupt>:
     126:	6c cf       	rjmp	.-296    	; 0x0 <__vectors>

00000128 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     128:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     12a:	03 96       	adiw	r24, 0x03	; 3
     12c:	92 83       	std	Z+2, r25	; 0x02
     12e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     130:	4f ef       	ldi	r20, 0xFF	; 255
     132:	5f ef       	ldi	r21, 0xFF	; 255
     134:	ba 01       	movw	r22, r20
     136:	43 83       	std	Z+3, r20	; 0x03
     138:	54 83       	std	Z+4, r21	; 0x04
     13a:	65 83       	std	Z+5, r22	; 0x05
     13c:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     13e:	90 87       	std	Z+8, r25	; 0x08
     140:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     142:	92 87       	std	Z+10, r25	; 0x0a
     144:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     146:	10 82       	st	Z, r1
     148:	08 95       	ret

0000014a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     14a:	fc 01       	movw	r30, r24
     14c:	13 86       	std	Z+11, r1	; 0x0b
     14e:	12 86       	std	Z+10, r1	; 0x0a
     150:	08 95       	ret

00000152 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	9c 01       	movw	r18, r24
     158:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     15a:	dc 01       	movw	r26, r24
     15c:	11 96       	adiw	r26, 0x01	; 1
     15e:	cd 91       	ld	r28, X+
     160:	dc 91       	ld	r29, X
     162:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     164:	d5 83       	std	Z+5, r29	; 0x05
     166:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     168:	8e 81       	ldd	r24, Y+6	; 0x06
     16a:	9f 81       	ldd	r25, Y+7	; 0x07
     16c:	97 83       	std	Z+7, r25	; 0x07
     16e:	86 83       	std	Z+6, r24	; 0x06

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     170:	8e 81       	ldd	r24, Y+6	; 0x06
     172:	9f 81       	ldd	r25, Y+7	; 0x07
     174:	dc 01       	movw	r26, r24
     176:	15 96       	adiw	r26, 0x05	; 5
     178:	7c 93       	st	X, r23
     17a:	6e 93       	st	-X, r22
     17c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     17e:	7f 83       	std	Y+7, r23	; 0x07
     180:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     182:	33 87       	std	Z+11, r19	; 0x0b
     184:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     186:	f9 01       	movw	r30, r18
     188:	80 81       	ld	r24, Z
     18a:	8f 5f       	subi	r24, 0xFF	; 255
     18c:	80 83       	st	Z, r24
}
     18e:	df 91       	pop	r29
     190:	cf 91       	pop	r28
     192:	08 95       	ret

00000194 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     194:	0f 93       	push	r16
     196:	1f 93       	push	r17
     198:	cf 93       	push	r28
     19a:	df 93       	push	r29
     19c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     19e:	08 81       	ld	r16, Y
     1a0:	19 81       	ldd	r17, Y+1	; 0x01
     1a2:	2a 81       	ldd	r18, Y+2	; 0x02
     1a4:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     1a6:	0f 3f       	cpi	r16, 0xFF	; 255
     1a8:	4f ef       	ldi	r20, 0xFF	; 255
     1aa:	14 07       	cpc	r17, r20
     1ac:	24 07       	cpc	r18, r20
     1ae:	34 07       	cpc	r19, r20
     1b0:	21 f4       	brne	.+8      	; 0x1ba <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     1b2:	fc 01       	movw	r30, r24
     1b4:	a1 85       	ldd	r26, Z+9	; 0x09
     1b6:	b2 85       	ldd	r27, Z+10	; 0x0a
     1b8:	11 c0       	rjmp	.+34     	; 0x1dc <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1ba:	dc 01       	movw	r26, r24
     1bc:	13 96       	adiw	r26, 0x03	; 3
     1be:	01 c0       	rjmp	.+2      	; 0x1c2 <vListInsert+0x2e>
     1c0:	df 01       	movw	r26, r30
     1c2:	14 96       	adiw	r26, 0x04	; 4
     1c4:	ed 91       	ld	r30, X+
     1c6:	fc 91       	ld	r31, X
     1c8:	15 97       	sbiw	r26, 0x05	; 5
     1ca:	40 81       	ld	r20, Z
     1cc:	51 81       	ldd	r21, Z+1	; 0x01
     1ce:	62 81       	ldd	r22, Z+2	; 0x02
     1d0:	73 81       	ldd	r23, Z+3	; 0x03
     1d2:	04 17       	cp	r16, r20
     1d4:	15 07       	cpc	r17, r21
     1d6:	26 07       	cpc	r18, r22
     1d8:	37 07       	cpc	r19, r23
     1da:	90 f7       	brcc	.-28     	; 0x1c0 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     1dc:	14 96       	adiw	r26, 0x04	; 4
     1de:	ed 91       	ld	r30, X+
     1e0:	fc 91       	ld	r31, X
     1e2:	15 97       	sbiw	r26, 0x05	; 5
     1e4:	fd 83       	std	Y+5, r31	; 0x05
     1e6:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     1e8:	d7 83       	std	Z+7, r29	; 0x07
     1ea:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     1ec:	bf 83       	std	Y+7, r27	; 0x07
     1ee:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     1f0:	15 96       	adiw	r26, 0x05	; 5
     1f2:	dc 93       	st	X, r29
     1f4:	ce 93       	st	-X, r28
     1f6:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1f8:	9b 87       	std	Y+11, r25	; 0x0b
     1fa:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     1fc:	fc 01       	movw	r30, r24
     1fe:	20 81       	ld	r18, Z
     200:	2f 5f       	subi	r18, 0xFF	; 255
     202:	20 83       	st	Z, r18
}
     204:	df 91       	pop	r29
     206:	cf 91       	pop	r28
     208:	1f 91       	pop	r17
     20a:	0f 91       	pop	r16
     20c:	08 95       	ret

0000020e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     214:	a2 85       	ldd	r26, Z+10	; 0x0a
     216:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     218:	c4 81       	ldd	r28, Z+4	; 0x04
     21a:	d5 81       	ldd	r29, Z+5	; 0x05
     21c:	86 81       	ldd	r24, Z+6	; 0x06
     21e:	97 81       	ldd	r25, Z+7	; 0x07
     220:	9f 83       	std	Y+7, r25	; 0x07
     222:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     224:	c6 81       	ldd	r28, Z+6	; 0x06
     226:	d7 81       	ldd	r29, Z+7	; 0x07
     228:	84 81       	ldd	r24, Z+4	; 0x04
     22a:	95 81       	ldd	r25, Z+5	; 0x05
     22c:	9d 83       	std	Y+5, r25	; 0x05
     22e:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     230:	11 96       	adiw	r26, 0x01	; 1
     232:	8d 91       	ld	r24, X+
     234:	9c 91       	ld	r25, X
     236:	12 97       	sbiw	r26, 0x02	; 2
     238:	e8 17       	cp	r30, r24
     23a:	f9 07       	cpc	r31, r25
     23c:	31 f4       	brne	.+12     	; 0x24a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     23e:	86 81       	ldd	r24, Z+6	; 0x06
     240:	97 81       	ldd	r25, Z+7	; 0x07
     242:	12 96       	adiw	r26, 0x02	; 2
     244:	9c 93       	st	X, r25
     246:	8e 93       	st	-X, r24
     248:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     24a:	13 86       	std	Z+11, r1	; 0x0b
     24c:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
     24e:	8c 91       	ld	r24, X
     250:	81 50       	subi	r24, 0x01	; 1
     252:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     254:	df 91       	pop	r29
     256:	cf 91       	pop	r28
     258:	08 95       	ret

0000025a <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
     25a:	cf 93       	push	r28
     25c:	df 93       	push	r29
uint8_t *pucAlignedHeap;
uint32_t ulAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	ulAddress = ( uint32_t ) ucHeap;
     25e:	ec ed       	ldi	r30, 0xDC	; 220
     260:	f2 e0       	ldi	r31, 0x02	; 2

	pucAlignedHeap = ( uint8_t * ) ulAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     262:	a8 ed       	ldi	r26, 0xD8	; 216
     264:	b2 e0       	ldi	r27, 0x02	; 2
     266:	11 96       	adiw	r26, 0x01	; 1
     268:	fc 93       	st	X, r31
     26a:	ee 93       	st	-X, r30
	xStart.xBlockSize = ( size_t ) 0;
     26c:	13 96       	adiw	r26, 0x03	; 3
     26e:	1c 92       	st	X, r1
     270:	1e 92       	st	-X, r1
     272:	12 97       	sbiw	r26, 0x02	; 2

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
     274:	cf 01       	movw	r24, r30
     276:	0f 2e       	mov	r0, r31
     278:	00 0c       	add	r0, r0
     27a:	aa 0b       	sbc	r26, r26
     27c:	bb 0b       	sbc	r27, r27
	ulAddress -= xHeapStructSize;
     27e:	84 59       	subi	r24, 0x94	; 148
     280:	98 4e       	sbci	r25, 0xE8	; 232
     282:	af 4f       	sbci	r26, 0xFF	; 255
     284:	bf 4f       	sbci	r27, 0xFF	; 255
	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
	pxEnd = ( void * ) ulAddress;
     286:	ec 01       	movw	r28, r24
     288:	90 93 d7 02 	sts	0x02D7, r25	; 0x8002d7 <pxEnd+0x1>
     28c:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <pxEnd>
	pxEnd->xBlockSize = 0;
     290:	1b 82       	std	Y+3, r1	; 0x03
     292:	1a 82       	std	Y+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     294:	19 82       	std	Y+1, r1	; 0x01
     296:	18 82       	st	Y, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
     298:	9c 01       	movw	r18, r24
     29a:	2c 5d       	subi	r18, 0xDC	; 220
     29c:	32 40       	sbci	r19, 0x02	; 2
     29e:	33 83       	std	Z+3, r19	; 0x03
     2a0:	22 83       	std	Z+2, r18	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     2a2:	91 83       	std	Z+1, r25	; 0x01
     2a4:	80 83       	st	Z, r24

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     2a6:	30 93 d3 02 	sts	0x02D3, r19	; 0x8002d3 <xMinimumEverFreeBytesRemaining+0x1>
     2aa:	20 93 d2 02 	sts	0x02D2, r18	; 0x8002d2 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     2ae:	30 93 d5 02 	sts	0x02D5, r19	; 0x8002d5 <xFreeBytesRemaining+0x1>
     2b2:	20 93 d4 02 	sts	0x02D4, r18	; 0x8002d4 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     2b6:	80 e0       	ldi	r24, 0x00	; 0
     2b8:	90 e8       	ldi	r25, 0x80	; 128
     2ba:	90 93 d1 02 	sts	0x02D1, r25	; 0x8002d1 <__data_end+0x1>
     2be:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <__data_end>
}
     2c2:	df 91       	pop	r29
     2c4:	cf 91       	pop	r28
     2c6:	08 95       	ret

000002c8 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     2c8:	cf 93       	push	r28
     2ca:	df 93       	push	r29
     2cc:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     2ce:	a8 ed       	ldi	r26, 0xD8	; 216
     2d0:	b2 e0       	ldi	r27, 0x02	; 2
     2d2:	01 c0       	rjmp	.+2      	; 0x2d6 <prvInsertBlockIntoFreeList+0xe>
     2d4:	df 01       	movw	r26, r30
     2d6:	ed 91       	ld	r30, X+
     2d8:	fc 91       	ld	r31, X
     2da:	11 97       	sbiw	r26, 0x01	; 1
     2dc:	ec 17       	cp	r30, r28
     2de:	fd 07       	cpc	r31, r29
     2e0:	c8 f3       	brcs	.-14     	; 0x2d4 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     2e2:	12 96       	adiw	r26, 0x02	; 2
     2e4:	8d 91       	ld	r24, X+
     2e6:	9c 91       	ld	r25, X
     2e8:	13 97       	sbiw	r26, 0x03	; 3
     2ea:	9d 01       	movw	r18, r26
     2ec:	28 0f       	add	r18, r24
     2ee:	39 1f       	adc	r19, r25
     2f0:	c2 17       	cp	r28, r18
     2f2:	d3 07       	cpc	r29, r19
     2f4:	49 f4       	brne	.+18     	; 0x308 <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     2f6:	2a 81       	ldd	r18, Y+2	; 0x02
     2f8:	3b 81       	ldd	r19, Y+3	; 0x03
     2fa:	82 0f       	add	r24, r18
     2fc:	93 1f       	adc	r25, r19
     2fe:	13 96       	adiw	r26, 0x03	; 3
     300:	9c 93       	st	X, r25
     302:	8e 93       	st	-X, r24
     304:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     306:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     308:	8a 81       	ldd	r24, Y+2	; 0x02
     30a:	9b 81       	ldd	r25, Y+3	; 0x03
     30c:	9e 01       	movw	r18, r28
     30e:	28 0f       	add	r18, r24
     310:	39 1f       	adc	r19, r25
     312:	e2 17       	cp	r30, r18
     314:	f3 07       	cpc	r31, r19
     316:	c1 f4       	brne	.+48     	; 0x348 <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     318:	20 91 d6 02 	lds	r18, 0x02D6	; 0x8002d6 <pxEnd>
     31c:	30 91 d7 02 	lds	r19, 0x02D7	; 0x8002d7 <pxEnd+0x1>
     320:	e2 17       	cp	r30, r18
     322:	f3 07       	cpc	r31, r19
     324:	71 f0       	breq	.+28     	; 0x342 <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     326:	22 81       	ldd	r18, Z+2	; 0x02
     328:	33 81       	ldd	r19, Z+3	; 0x03
     32a:	82 0f       	add	r24, r18
     32c:	93 1f       	adc	r25, r19
     32e:	9b 83       	std	Y+3, r25	; 0x03
     330:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     332:	ed 91       	ld	r30, X+
     334:	fc 91       	ld	r31, X
     336:	11 97       	sbiw	r26, 0x01	; 1
     338:	80 81       	ld	r24, Z
     33a:	91 81       	ldd	r25, Z+1	; 0x01
     33c:	99 83       	std	Y+1, r25	; 0x01
     33e:	88 83       	st	Y, r24
     340:	05 c0       	rjmp	.+10     	; 0x34c <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     342:	39 83       	std	Y+1, r19	; 0x01
     344:	28 83       	st	Y, r18
     346:	02 c0       	rjmp	.+4      	; 0x34c <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     348:	f9 83       	std	Y+1, r31	; 0x01
     34a:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     34c:	ca 17       	cp	r28, r26
     34e:	db 07       	cpc	r29, r27
     350:	11 f0       	breq	.+4      	; 0x356 <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     352:	cd 93       	st	X+, r28
     354:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     356:	df 91       	pop	r29
     358:	cf 91       	pop	r28
     35a:	08 95       	ret

0000035c <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     35c:	ef 92       	push	r14
     35e:	ff 92       	push	r15
     360:	0f 93       	push	r16
     362:	1f 93       	push	r17
     364:	cf 93       	push	r28
     366:	df 93       	push	r29
     368:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     36a:	1f d7       	rcall	.+3646   	; 0x11aa <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     36c:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxEnd>
     370:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxEnd+0x1>
     374:	89 2b       	or	r24, r25
		{
			prvHeapInit();
     376:	09 f4       	brne	.+2      	; 0x37a <pvPortMalloc+0x1e>
     378:	70 df       	rcall	.-288    	; 0x25a <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     37a:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <__data_end>
     37e:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <__data_end+0x1>
     382:	80 23       	and	r24, r16
     384:	91 23       	and	r25, r17
     386:	89 2b       	or	r24, r25
     388:	09 f0       	breq	.+2      	; 0x38c <pvPortMalloc+0x30>
     38a:	66 c0       	rjmp	.+204    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     38c:	01 15       	cp	r16, r1
     38e:	11 05       	cpc	r17, r1
     390:	11 f0       	breq	.+4      	; 0x396 <pvPortMalloc+0x3a>
			{
				xWantedSize += xHeapStructSize;
     392:	0c 5f       	subi	r16, 0xFC	; 252
     394:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     396:	01 15       	cp	r16, r1
     398:	11 05       	cpc	r17, r1
     39a:	09 f4       	brne	.+2      	; 0x39e <pvPortMalloc+0x42>
     39c:	60 c0       	rjmp	.+192    	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     39e:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <xFreeBytesRemaining>
     3a2:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <xFreeBytesRemaining+0x1>
     3a6:	80 17       	cp	r24, r16
     3a8:	91 07       	cpc	r25, r17
     3aa:	08 f4       	brcc	.+2      	; 0x3ae <pvPortMalloc+0x52>
     3ac:	5b c0       	rjmp	.+182    	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     3ae:	c0 91 d8 02 	lds	r28, 0x02D8	; 0x8002d8 <xStart>
     3b2:	d0 91 d9 02 	lds	r29, 0x02D9	; 0x8002d9 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     3b6:	e8 ed       	ldi	r30, 0xD8	; 216
     3b8:	f2 e0       	ldi	r31, 0x02	; 2
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     3ba:	02 c0       	rjmp	.+4      	; 0x3c0 <pvPortMalloc+0x64>
				{
					pxPreviousBlock = pxBlock;
     3bc:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     3be:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     3c0:	8a 81       	ldd	r24, Y+2	; 0x02
     3c2:	9b 81       	ldd	r25, Y+3	; 0x03
     3c4:	80 17       	cp	r24, r16
     3c6:	91 07       	cpc	r25, r17
     3c8:	20 f4       	brcc	.+8      	; 0x3d2 <pvPortMalloc+0x76>
     3ca:	88 81       	ld	r24, Y
     3cc:	99 81       	ldd	r25, Y+1	; 0x01
     3ce:	00 97       	sbiw	r24, 0x00	; 0
     3d0:	a9 f7       	brne	.-22     	; 0x3bc <pvPortMalloc+0x60>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     3d2:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxEnd>
     3d6:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxEnd+0x1>
     3da:	c8 17       	cp	r28, r24
     3dc:	d9 07       	cpc	r29, r25
     3de:	09 f4       	brne	.+2      	; 0x3e2 <pvPortMalloc+0x86>
     3e0:	44 c0       	rjmp	.+136    	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     3e2:	e0 80       	ld	r14, Z
     3e4:	f1 80       	ldd	r15, Z+1	; 0x01
     3e6:	84 e0       	ldi	r24, 0x04	; 4
     3e8:	e8 0e       	add	r14, r24
     3ea:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     3ec:	88 81       	ld	r24, Y
     3ee:	99 81       	ldd	r25, Y+1	; 0x01
     3f0:	91 83       	std	Z+1, r25	; 0x01
     3f2:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     3f4:	2a 81       	ldd	r18, Y+2	; 0x02
     3f6:	3b 81       	ldd	r19, Y+3	; 0x03
     3f8:	20 1b       	sub	r18, r16
     3fa:	31 0b       	sbc	r19, r17
     3fc:	29 30       	cpi	r18, 0x09	; 9
     3fe:	31 05       	cpc	r19, r1
     400:	48 f0       	brcs	.+18     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     402:	ce 01       	movw	r24, r28
     404:	80 0f       	add	r24, r16
     406:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     408:	fc 01       	movw	r30, r24
     40a:	33 83       	std	Z+3, r19	; 0x03
     40c:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     40e:	1b 83       	std	Y+3, r17	; 0x03

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     410:	0a 83       	std	Y+2, r16	; 0x02
     412:	5a df       	rcall	.-332    	; 0x2c8 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     414:	2a 81       	ldd	r18, Y+2	; 0x02
     416:	3b 81       	ldd	r19, Y+3	; 0x03
     418:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <xFreeBytesRemaining>
     41c:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <xFreeBytesRemaining+0x1>
     420:	82 1b       	sub	r24, r18
     422:	93 0b       	sbc	r25, r19
     424:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <xFreeBytesRemaining+0x1>
     428:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     42c:	40 91 d2 02 	lds	r20, 0x02D2	; 0x8002d2 <xMinimumEverFreeBytesRemaining>
     430:	50 91 d3 02 	lds	r21, 0x02D3	; 0x8002d3 <xMinimumEverFreeBytesRemaining+0x1>
     434:	84 17       	cp	r24, r20
     436:	95 07       	cpc	r25, r21
     438:	20 f4       	brcc	.+8      	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     43a:	90 93 d3 02 	sts	0x02D3, r25	; 0x8002d3 <xMinimumEverFreeBytesRemaining+0x1>
     43e:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     442:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <__data_end>
     446:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <__data_end+0x1>
     44a:	28 2b       	or	r18, r24
     44c:	39 2b       	or	r19, r25
     44e:	3b 83       	std	Y+3, r19	; 0x03
     450:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     452:	19 82       	std	Y+1, r1	; 0x01
     454:	18 82       	st	Y, r1
     456:	0b c0       	rjmp	.+22     	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     458:	e1 2c       	mov	r14, r1
     45a:	f1 2c       	mov	r15, r1
     45c:	08 c0       	rjmp	.+16     	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
     45e:	e1 2c       	mov	r14, r1
     460:	f1 2c       	mov	r15, r1
     462:	05 c0       	rjmp	.+10     	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
     464:	e1 2c       	mov	r14, r1
     466:	f1 2c       	mov	r15, r1
     468:	02 c0       	rjmp	.+4      	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
     46a:	e1 2c       	mov	r14, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     46c:	f1 2c       	mov	r15, r1
     46e:	72 d7       	rcall	.+3812   	; 0x1354 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     470:	c7 01       	movw	r24, r14
     472:	df 91       	pop	r29
     474:	cf 91       	pop	r28
     476:	1f 91       	pop	r17
     478:	0f 91       	pop	r16
     47a:	ff 90       	pop	r15
     47c:	ef 90       	pop	r14
     47e:	08 95       	ret

00000480 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     488:	00 97       	sbiw	r24, 0x00	; 0
     48a:	39 f1       	breq	.+78     	; 0x4da <vPortFree+0x5a>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     48c:	ec 01       	movw	r28, r24
     48e:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     490:	4a 81       	ldd	r20, Y+2	; 0x02
     492:	5b 81       	ldd	r21, Y+3	; 0x03
     494:	20 91 d0 02 	lds	r18, 0x02D0	; 0x8002d0 <__data_end>
     498:	30 91 d1 02 	lds	r19, 0x02D1	; 0x8002d1 <__data_end+0x1>
     49c:	ba 01       	movw	r22, r20
     49e:	62 23       	and	r22, r18
     4a0:	73 23       	and	r23, r19
     4a2:	67 2b       	or	r22, r23
     4a4:	d1 f0       	breq	.+52     	; 0x4da <vPortFree+0x5a>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     4a6:	68 81       	ld	r22, Y
     4a8:	79 81       	ldd	r23, Y+1	; 0x01
     4aa:	67 2b       	or	r22, r23
     4ac:	b1 f4       	brne	.+44     	; 0x4da <vPortFree+0x5a>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     4ae:	20 95       	com	r18
     4b0:	30 95       	com	r19
     4b2:	24 23       	and	r18, r20
     4b4:	35 23       	and	r19, r21
     4b6:	3b 83       	std	Y+3, r19	; 0x03
     4b8:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     4ba:	77 d6       	rcall	.+3310   	; 0x11aa <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     4bc:	8a 81       	ldd	r24, Y+2	; 0x02
     4be:	9b 81       	ldd	r25, Y+3	; 0x03
     4c0:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <xFreeBytesRemaining>
     4c4:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <xFreeBytesRemaining+0x1>
     4c8:	82 0f       	add	r24, r18
     4ca:	93 1f       	adc	r25, r19
     4cc:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <xFreeBytesRemaining+0x1>
     4d0:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     4d4:	ce 01       	movw	r24, r28
				}
				( void ) xTaskResumeAll();
     4d6:	f8 de       	rcall	.-528    	; 0x2c8 <prvInsertBlockIntoFreeList>
     4d8:	3d d7       	rcall	.+3706   	; 0x1354 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     4da:	df 91       	pop	r29
     4dc:	cf 91       	pop	r28
     4de:	1f 91       	pop	r17
     4e0:	0f 91       	pop	r16
     4e2:	08 95       	ret

000004e4 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     4e4:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7c0089>
     4e8:	89 ef       	ldi	r24, 0xF9	; 249
     4ea:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7c0088>
     4ee:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7c0080>
     4f2:	8b e0       	ldi	r24, 0x0B	; 11
     4f4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7c0081>
     4f8:	ef e6       	ldi	r30, 0x6F	; 111
     4fa:	f0 e0       	ldi	r31, 0x00	; 0
     4fc:	80 81       	ld	r24, Z
     4fe:	82 60       	ori	r24, 0x02	; 2
     500:	80 83       	st	Z, r24
     502:	08 95       	ret

00000504 <pxPortInitialiseStack>:
     504:	31 e1       	ldi	r19, 0x11	; 17
     506:	fc 01       	movw	r30, r24
     508:	30 83       	st	Z, r19
     50a:	31 97       	sbiw	r30, 0x01	; 1
     50c:	22 e2       	ldi	r18, 0x22	; 34
     50e:	20 83       	st	Z, r18
     510:	31 97       	sbiw	r30, 0x01	; 1
     512:	a3 e3       	ldi	r26, 0x33	; 51
     514:	a0 83       	st	Z, r26
     516:	31 97       	sbiw	r30, 0x01	; 1
     518:	60 83       	st	Z, r22
     51a:	31 97       	sbiw	r30, 0x01	; 1
     51c:	70 83       	st	Z, r23
     51e:	31 97       	sbiw	r30, 0x01	; 1
     520:	10 82       	st	Z, r1
     522:	31 97       	sbiw	r30, 0x01	; 1
     524:	10 82       	st	Z, r1
     526:	31 97       	sbiw	r30, 0x01	; 1
     528:	60 e8       	ldi	r22, 0x80	; 128
     52a:	60 83       	st	Z, r22
     52c:	31 97       	sbiw	r30, 0x01	; 1
     52e:	10 82       	st	Z, r1
     530:	31 97       	sbiw	r30, 0x01	; 1
     532:	10 82       	st	Z, r1
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	10 82       	st	Z, r1
     538:	31 97       	sbiw	r30, 0x01	; 1
     53a:	62 e0       	ldi	r22, 0x02	; 2
     53c:	60 83       	st	Z, r22
     53e:	31 97       	sbiw	r30, 0x01	; 1
     540:	63 e0       	ldi	r22, 0x03	; 3
     542:	60 83       	st	Z, r22
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	64 e0       	ldi	r22, 0x04	; 4
     548:	60 83       	st	Z, r22
     54a:	31 97       	sbiw	r30, 0x01	; 1
     54c:	65 e0       	ldi	r22, 0x05	; 5
     54e:	60 83       	st	Z, r22
     550:	31 97       	sbiw	r30, 0x01	; 1
     552:	66 e0       	ldi	r22, 0x06	; 6
     554:	60 83       	st	Z, r22
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	67 e0       	ldi	r22, 0x07	; 7
     55a:	60 83       	st	Z, r22
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	68 e0       	ldi	r22, 0x08	; 8
     560:	60 83       	st	Z, r22
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	69 e0       	ldi	r22, 0x09	; 9
     566:	60 83       	st	Z, r22
     568:	31 97       	sbiw	r30, 0x01	; 1
     56a:	60 e1       	ldi	r22, 0x10	; 16
     56c:	60 83       	st	Z, r22
     56e:	31 97       	sbiw	r30, 0x01	; 1
     570:	30 83       	st	Z, r19
     572:	31 97       	sbiw	r30, 0x01	; 1
     574:	32 e1       	ldi	r19, 0x12	; 18
     576:	30 83       	st	Z, r19
     578:	31 97       	sbiw	r30, 0x01	; 1
     57a:	33 e1       	ldi	r19, 0x13	; 19
     57c:	30 83       	st	Z, r19
     57e:	31 97       	sbiw	r30, 0x01	; 1
     580:	34 e1       	ldi	r19, 0x14	; 20
     582:	30 83       	st	Z, r19
     584:	31 97       	sbiw	r30, 0x01	; 1
     586:	35 e1       	ldi	r19, 0x15	; 21
     588:	30 83       	st	Z, r19
     58a:	31 97       	sbiw	r30, 0x01	; 1
     58c:	36 e1       	ldi	r19, 0x16	; 22
     58e:	30 83       	st	Z, r19
     590:	31 97       	sbiw	r30, 0x01	; 1
     592:	37 e1       	ldi	r19, 0x17	; 23
     594:	30 83       	st	Z, r19
     596:	31 97       	sbiw	r30, 0x01	; 1
     598:	38 e1       	ldi	r19, 0x18	; 24
     59a:	30 83       	st	Z, r19
     59c:	31 97       	sbiw	r30, 0x01	; 1
     59e:	39 e1       	ldi	r19, 0x19	; 25
     5a0:	30 83       	st	Z, r19
     5a2:	31 97       	sbiw	r30, 0x01	; 1
     5a4:	30 e2       	ldi	r19, 0x20	; 32
     5a6:	30 83       	st	Z, r19
     5a8:	31 97       	sbiw	r30, 0x01	; 1
     5aa:	31 e2       	ldi	r19, 0x21	; 33
     5ac:	30 83       	st	Z, r19
     5ae:	31 97       	sbiw	r30, 0x01	; 1
     5b0:	20 83       	st	Z, r18
     5b2:	31 97       	sbiw	r30, 0x01	; 1
     5b4:	23 e2       	ldi	r18, 0x23	; 35
     5b6:	20 83       	st	Z, r18
     5b8:	31 97       	sbiw	r30, 0x01	; 1
     5ba:	40 83       	st	Z, r20
     5bc:	31 97       	sbiw	r30, 0x01	; 1
     5be:	50 83       	st	Z, r21
     5c0:	31 97       	sbiw	r30, 0x01	; 1
     5c2:	26 e2       	ldi	r18, 0x26	; 38
     5c4:	20 83       	st	Z, r18
     5c6:	31 97       	sbiw	r30, 0x01	; 1
     5c8:	27 e2       	ldi	r18, 0x27	; 39
     5ca:	20 83       	st	Z, r18
     5cc:	31 97       	sbiw	r30, 0x01	; 1
     5ce:	28 e2       	ldi	r18, 0x28	; 40
     5d0:	20 83       	st	Z, r18
     5d2:	31 97       	sbiw	r30, 0x01	; 1
     5d4:	29 e2       	ldi	r18, 0x29	; 41
     5d6:	20 83       	st	Z, r18
     5d8:	31 97       	sbiw	r30, 0x01	; 1
     5da:	20 e3       	ldi	r18, 0x30	; 48
     5dc:	20 83       	st	Z, r18
     5de:	31 97       	sbiw	r30, 0x01	; 1
     5e0:	21 e3       	ldi	r18, 0x31	; 49
     5e2:	20 83       	st	Z, r18
     5e4:	89 97       	sbiw	r24, 0x29	; 41
     5e6:	08 95       	ret

000005e8 <xPortStartScheduler>:
     5e8:	7d df       	rcall	.-262    	; 0x4e4 <prvSetupTimerInterrupt>
     5ea:	a0 91 d1 1a 	lds	r26, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
     5ee:	b0 91 d2 1a 	lds	r27, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     5f2:	cd 91       	ld	r28, X+
     5f4:	cd bf       	out	0x3d, r28	; 61
     5f6:	dd 91       	ld	r29, X+
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	ff 91       	pop	r31
     5fc:	ef 91       	pop	r30
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	bf 91       	pop	r27
     604:	af 91       	pop	r26
     606:	9f 91       	pop	r25
     608:	8f 91       	pop	r24
     60a:	7f 91       	pop	r23
     60c:	6f 91       	pop	r22
     60e:	5f 91       	pop	r21
     610:	4f 91       	pop	r20
     612:	3f 91       	pop	r19
     614:	2f 91       	pop	r18
     616:	1f 91       	pop	r17
     618:	0f 91       	pop	r16
     61a:	ff 90       	pop	r15
     61c:	ef 90       	pop	r14
     61e:	df 90       	pop	r13
     620:	cf 90       	pop	r12
     622:	bf 90       	pop	r11
     624:	af 90       	pop	r10
     626:	9f 90       	pop	r9
     628:	8f 90       	pop	r8
     62a:	7f 90       	pop	r7
     62c:	6f 90       	pop	r6
     62e:	5f 90       	pop	r5
     630:	4f 90       	pop	r4
     632:	3f 90       	pop	r3
     634:	2f 90       	pop	r2
     636:	1f 90       	pop	r1
     638:	0f 90       	pop	r0
     63a:	0c be       	out	0x3c, r0	; 60
     63c:	0f 90       	pop	r0
     63e:	0b be       	out	0x3b, r0	; 59
     640:	0f 90       	pop	r0
     642:	0f be       	out	0x3f, r0	; 63
     644:	0f 90       	pop	r0
     646:	08 95       	ret
     648:	81 e0       	ldi	r24, 0x01	; 1
     64a:	08 95       	ret

0000064c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     64c:	0f 92       	push	r0
     64e:	0f b6       	in	r0, 0x3f	; 63
     650:	f8 94       	cli
     652:	0f 92       	push	r0
     654:	0b b6       	in	r0, 0x3b	; 59
     656:	0f 92       	push	r0
     658:	0c b6       	in	r0, 0x3c	; 60
     65a:	0f 92       	push	r0
     65c:	1f 92       	push	r1
     65e:	11 24       	eor	r1, r1
     660:	2f 92       	push	r2
     662:	3f 92       	push	r3
     664:	4f 92       	push	r4
     666:	5f 92       	push	r5
     668:	6f 92       	push	r6
     66a:	7f 92       	push	r7
     66c:	8f 92       	push	r8
     66e:	9f 92       	push	r9
     670:	af 92       	push	r10
     672:	bf 92       	push	r11
     674:	cf 92       	push	r12
     676:	df 92       	push	r13
     678:	ef 92       	push	r14
     67a:	ff 92       	push	r15
     67c:	0f 93       	push	r16
     67e:	1f 93       	push	r17
     680:	2f 93       	push	r18
     682:	3f 93       	push	r19
     684:	4f 93       	push	r20
     686:	5f 93       	push	r21
     688:	6f 93       	push	r22
     68a:	7f 93       	push	r23
     68c:	8f 93       	push	r24
     68e:	9f 93       	push	r25
     690:	af 93       	push	r26
     692:	bf 93       	push	r27
     694:	cf 93       	push	r28
     696:	df 93       	push	r29
     698:	ef 93       	push	r30
     69a:	ff 93       	push	r31
     69c:	a0 91 d1 1a 	lds	r26, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
     6a0:	b0 91 d2 1a 	lds	r27, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     6a4:	0d b6       	in	r0, 0x3d	; 61
     6a6:	0d 92       	st	X+, r0
     6a8:	0e b6       	in	r0, 0x3e	; 62
     6aa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     6ac:	08 d7       	rcall	.+3600   	; 0x14be <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     6ae:	a0 91 d1 1a 	lds	r26, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
     6b2:	b0 91 d2 1a 	lds	r27, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     6b6:	cd 91       	ld	r28, X+
     6b8:	cd bf       	out	0x3d, r28	; 61
     6ba:	dd 91       	ld	r29, X+
     6bc:	de bf       	out	0x3e, r29	; 62
     6be:	ff 91       	pop	r31
     6c0:	ef 91       	pop	r30
     6c2:	df 91       	pop	r29
     6c4:	cf 91       	pop	r28
     6c6:	bf 91       	pop	r27
     6c8:	af 91       	pop	r26
     6ca:	9f 91       	pop	r25
     6cc:	8f 91       	pop	r24
     6ce:	7f 91       	pop	r23
     6d0:	6f 91       	pop	r22
     6d2:	5f 91       	pop	r21
     6d4:	4f 91       	pop	r20
     6d6:	3f 91       	pop	r19
     6d8:	2f 91       	pop	r18
     6da:	1f 91       	pop	r17
     6dc:	0f 91       	pop	r16
     6de:	ff 90       	pop	r15
     6e0:	ef 90       	pop	r14
     6e2:	df 90       	pop	r13
     6e4:	cf 90       	pop	r12
     6e6:	bf 90       	pop	r11
     6e8:	af 90       	pop	r10
     6ea:	9f 90       	pop	r9
     6ec:	8f 90       	pop	r8
     6ee:	7f 90       	pop	r7
     6f0:	6f 90       	pop	r6
     6f2:	5f 90       	pop	r5
     6f4:	4f 90       	pop	r4
     6f6:	3f 90       	pop	r3
     6f8:	2f 90       	pop	r2
     6fa:	1f 90       	pop	r1
     6fc:	0f 90       	pop	r0
     6fe:	0c be       	out	0x3c, r0	; 60
     700:	0f 90       	pop	r0
     702:	0b be       	out	0x3b, r0	; 59
     704:	0f 90       	pop	r0
     706:	0f be       	out	0x3f, r0	; 63
     708:	0f 90       	pop	r0

	asm volatile ( "ret" );
     70a:	08 95       	ret

0000070c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     70c:	0f 92       	push	r0
     70e:	0f b6       	in	r0, 0x3f	; 63
     710:	f8 94       	cli
     712:	0f 92       	push	r0
     714:	0b b6       	in	r0, 0x3b	; 59
     716:	0f 92       	push	r0
     718:	0c b6       	in	r0, 0x3c	; 60
     71a:	0f 92       	push	r0
     71c:	1f 92       	push	r1
     71e:	11 24       	eor	r1, r1
     720:	2f 92       	push	r2
     722:	3f 92       	push	r3
     724:	4f 92       	push	r4
     726:	5f 92       	push	r5
     728:	6f 92       	push	r6
     72a:	7f 92       	push	r7
     72c:	8f 92       	push	r8
     72e:	9f 92       	push	r9
     730:	af 92       	push	r10
     732:	bf 92       	push	r11
     734:	cf 92       	push	r12
     736:	df 92       	push	r13
     738:	ef 92       	push	r14
     73a:	ff 92       	push	r15
     73c:	0f 93       	push	r16
     73e:	1f 93       	push	r17
     740:	2f 93       	push	r18
     742:	3f 93       	push	r19
     744:	4f 93       	push	r20
     746:	5f 93       	push	r21
     748:	6f 93       	push	r22
     74a:	7f 93       	push	r23
     74c:	8f 93       	push	r24
     74e:	9f 93       	push	r25
     750:	af 93       	push	r26
     752:	bf 93       	push	r27
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	ef 93       	push	r30
     75a:	ff 93       	push	r31
     75c:	a0 91 d1 1a 	lds	r26, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
     760:	b0 91 d2 1a 	lds	r27, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     764:	0d b6       	in	r0, 0x3d	; 61
     766:	0d 92       	st	X+, r0
     768:	0e b6       	in	r0, 0x3e	; 62
     76a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     76c:	24 d5       	rcall	.+2632   	; 0x11b6 <xTaskIncrementTick>
     76e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     770:	a6 d6       	rcall	.+3404   	; 0x14be <vTaskSwitchContext>
     772:	a0 91 d1 1a 	lds	r26, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
     776:	b0 91 d2 1a 	lds	r27, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     77a:	cd 91       	ld	r28, X+
     77c:	cd bf       	out	0x3d, r28	; 61
     77e:	dd 91       	ld	r29, X+
     780:	de bf       	out	0x3e, r29	; 62
     782:	ff 91       	pop	r31
     784:	ef 91       	pop	r30
     786:	df 91       	pop	r29
     788:	cf 91       	pop	r28
     78a:	bf 91       	pop	r27
     78c:	af 91       	pop	r26
     78e:	9f 91       	pop	r25
     790:	8f 91       	pop	r24
     792:	7f 91       	pop	r23
     794:	6f 91       	pop	r22
     796:	5f 91       	pop	r21
     798:	4f 91       	pop	r20
     79a:	3f 91       	pop	r19
     79c:	2f 91       	pop	r18
     79e:	1f 91       	pop	r17
     7a0:	0f 91       	pop	r16
     7a2:	ff 90       	pop	r15
     7a4:	ef 90       	pop	r14
     7a6:	df 90       	pop	r13
     7a8:	cf 90       	pop	r12
     7aa:	bf 90       	pop	r11
     7ac:	af 90       	pop	r10
     7ae:	9f 90       	pop	r9
     7b0:	8f 90       	pop	r8
     7b2:	7f 90       	pop	r7
     7b4:	6f 90       	pop	r6
     7b6:	5f 90       	pop	r5
     7b8:	4f 90       	pop	r4
     7ba:	3f 90       	pop	r3
     7bc:	2f 90       	pop	r2
     7be:	1f 90       	pop	r1
     7c0:	0f 90       	pop	r0
     7c2:	0c be       	out	0x3c, r0	; 60
     7c4:	0f 90       	pop	r0
     7c6:	0b be       	out	0x3b, r0	; 59
     7c8:	0f 90       	pop	r0
     7ca:	0f be       	out	0x3f, r0	; 63
     7cc:	0f 90       	pop	r0
     7ce:	08 95       	ret

000007d0 <__vector_17>:

	asm volatile ( "ret" );
     7d0:	9d df       	rcall	.-198    	; 0x70c <vPortYieldFromTick>
	 */
	ISR(TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR(TIMER1_COMPA_vect)
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
     7d2:	18 95       	reti

000007d4 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     7d4:	0f b6       	in	r0, 0x3f	; 63
     7d6:	f8 94       	cli
     7d8:	0f 92       	push	r0
     7da:	fc 01       	movw	r30, r24
     7dc:	86 8d       	ldd	r24, Z+30	; 0x1e
     7de:	81 11       	cpse	r24, r1
     7e0:	02 c0       	rjmp	.+4      	; 0x7e6 <prvIsQueueEmpty+0x12>
     7e2:	81 e0       	ldi	r24, 0x01	; 1
     7e4:	01 c0       	rjmp	.+2      	; 0x7e8 <prvIsQueueEmpty+0x14>
     7e6:	80 e0       	ldi	r24, 0x00	; 0
     7e8:	0f 90       	pop	r0
     7ea:	0f be       	out	0x3f, r0	; 63
     7ec:	08 95       	ret

000007ee <prvIsQueueFull>:
     7ee:	0f b6       	in	r0, 0x3f	; 63
     7f0:	f8 94       	cli
     7f2:	0f 92       	push	r0
     7f4:	fc 01       	movw	r30, r24
     7f6:	26 8d       	ldd	r18, Z+30	; 0x1e
     7f8:	87 8d       	ldd	r24, Z+31	; 0x1f
     7fa:	28 13       	cpse	r18, r24
     7fc:	02 c0       	rjmp	.+4      	; 0x802 <prvIsQueueFull+0x14>
     7fe:	81 e0       	ldi	r24, 0x01	; 1
     800:	01 c0       	rjmp	.+2      	; 0x804 <prvIsQueueFull+0x16>
     802:	80 e0       	ldi	r24, 0x00	; 0
     804:	0f 90       	pop	r0
     806:	0f be       	out	0x3f, r0	; 63
     808:	08 95       	ret

0000080a <prvCopyDataToQueue>:
     80a:	0f 93       	push	r16
     80c:	1f 93       	push	r17
     80e:	cf 93       	push	r28
     810:	df 93       	push	r29
     812:	ec 01       	movw	r28, r24
     814:	04 2f       	mov	r16, r20
     816:	1e 8d       	ldd	r17, Y+30	; 0x1e
     818:	48 a1       	ldd	r20, Y+32	; 0x20
     81a:	41 11       	cpse	r20, r1
     81c:	0b c0       	rjmp	.+22     	; 0x834 <prvCopyDataToQueue+0x2a>
     81e:	88 81       	ld	r24, Y
     820:	99 81       	ldd	r25, Y+1	; 0x01
     822:	89 2b       	or	r24, r25
     824:	09 f0       	breq	.+2      	; 0x828 <prvCopyDataToQueue+0x1e>
     826:	41 c0       	rjmp	.+130    	; 0x8aa <prvCopyDataToQueue+0xa0>
     828:	8a 81       	ldd	r24, Y+2	; 0x02
     82a:	9b 81       	ldd	r25, Y+3	; 0x03
     82c:	c4 d7       	rcall	.+3976   	; 0x17b6 <xTaskPriorityDisinherit>
     82e:	1b 82       	std	Y+3, r1	; 0x03
     830:	1a 82       	std	Y+2, r1	; 0x02
     832:	42 c0       	rjmp	.+132    	; 0x8b8 <prvCopyDataToQueue+0xae>
     834:	01 11       	cpse	r16, r1
     836:	17 c0       	rjmp	.+46     	; 0x866 <prvCopyDataToQueue+0x5c>
     838:	50 e0       	ldi	r21, 0x00	; 0
     83a:	8c 81       	ldd	r24, Y+4	; 0x04
     83c:	9d 81       	ldd	r25, Y+5	; 0x05
     83e:	0e 94 57 0e 	call	0x1cae	; 0x1cae <memcpy>
     842:	28 a1       	ldd	r18, Y+32	; 0x20
     844:	8c 81       	ldd	r24, Y+4	; 0x04
     846:	9d 81       	ldd	r25, Y+5	; 0x05
     848:	82 0f       	add	r24, r18
     84a:	91 1d       	adc	r25, r1
     84c:	9d 83       	std	Y+5, r25	; 0x05
     84e:	8c 83       	std	Y+4, r24	; 0x04
     850:	2a 81       	ldd	r18, Y+2	; 0x02
     852:	3b 81       	ldd	r19, Y+3	; 0x03
     854:	82 17       	cp	r24, r18
     856:	93 07       	cpc	r25, r19
     858:	50 f1       	brcs	.+84     	; 0x8ae <prvCopyDataToQueue+0xa4>
     85a:	88 81       	ld	r24, Y
     85c:	99 81       	ldd	r25, Y+1	; 0x01
     85e:	9d 83       	std	Y+5, r25	; 0x05
     860:	8c 83       	std	Y+4, r24	; 0x04
     862:	80 e0       	ldi	r24, 0x00	; 0
     864:	29 c0       	rjmp	.+82     	; 0x8b8 <prvCopyDataToQueue+0xae>
     866:	50 e0       	ldi	r21, 0x00	; 0
     868:	8e 81       	ldd	r24, Y+6	; 0x06
     86a:	9f 81       	ldd	r25, Y+7	; 0x07
     86c:	0e 94 57 0e 	call	0x1cae	; 0x1cae <memcpy>
     870:	88 a1       	ldd	r24, Y+32	; 0x20
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	91 95       	neg	r25
     876:	81 95       	neg	r24
     878:	91 09       	sbc	r25, r1
     87a:	2e 81       	ldd	r18, Y+6	; 0x06
     87c:	3f 81       	ldd	r19, Y+7	; 0x07
     87e:	28 0f       	add	r18, r24
     880:	39 1f       	adc	r19, r25
     882:	3f 83       	std	Y+7, r19	; 0x07
     884:	2e 83       	std	Y+6, r18	; 0x06
     886:	48 81       	ld	r20, Y
     888:	59 81       	ldd	r21, Y+1	; 0x01
     88a:	24 17       	cp	r18, r20
     88c:	35 07       	cpc	r19, r21
     88e:	30 f4       	brcc	.+12     	; 0x89c <prvCopyDataToQueue+0x92>
     890:	2a 81       	ldd	r18, Y+2	; 0x02
     892:	3b 81       	ldd	r19, Y+3	; 0x03
     894:	82 0f       	add	r24, r18
     896:	93 1f       	adc	r25, r19
     898:	9f 83       	std	Y+7, r25	; 0x07
     89a:	8e 83       	std	Y+6, r24	; 0x06
     89c:	02 30       	cpi	r16, 0x02	; 2
     89e:	49 f4       	brne	.+18     	; 0x8b2 <prvCopyDataToQueue+0xa8>
     8a0:	11 23       	and	r17, r17
     8a2:	49 f0       	breq	.+18     	; 0x8b6 <prvCopyDataToQueue+0xac>
     8a4:	11 50       	subi	r17, 0x01	; 1
     8a6:	80 e0       	ldi	r24, 0x00	; 0
     8a8:	07 c0       	rjmp	.+14     	; 0x8b8 <prvCopyDataToQueue+0xae>
     8aa:	80 e0       	ldi	r24, 0x00	; 0
     8ac:	05 c0       	rjmp	.+10     	; 0x8b8 <prvCopyDataToQueue+0xae>
     8ae:	80 e0       	ldi	r24, 0x00	; 0
     8b0:	03 c0       	rjmp	.+6      	; 0x8b8 <prvCopyDataToQueue+0xae>
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	01 c0       	rjmp	.+2      	; 0x8b8 <prvCopyDataToQueue+0xae>
     8b6:	80 e0       	ldi	r24, 0x00	; 0
     8b8:	1f 5f       	subi	r17, 0xFF	; 255
     8ba:	1e 8f       	std	Y+30, r17	; 0x1e
     8bc:	df 91       	pop	r29
     8be:	cf 91       	pop	r28
     8c0:	1f 91       	pop	r17
     8c2:	0f 91       	pop	r16
     8c4:	08 95       	ret

000008c6 <prvCopyDataFromQueue>:
     8c6:	fc 01       	movw	r30, r24
     8c8:	40 a1       	ldd	r20, Z+32	; 0x20
     8ca:	44 23       	and	r20, r20
     8cc:	a9 f0       	breq	.+42     	; 0x8f8 <prvCopyDataFromQueue+0x32>
     8ce:	50 e0       	ldi	r21, 0x00	; 0
     8d0:	26 81       	ldd	r18, Z+6	; 0x06
     8d2:	37 81       	ldd	r19, Z+7	; 0x07
     8d4:	24 0f       	add	r18, r20
     8d6:	35 1f       	adc	r19, r21
     8d8:	37 83       	std	Z+7, r19	; 0x07
     8da:	26 83       	std	Z+6, r18	; 0x06
     8dc:	82 81       	ldd	r24, Z+2	; 0x02
     8de:	93 81       	ldd	r25, Z+3	; 0x03
     8e0:	28 17       	cp	r18, r24
     8e2:	39 07       	cpc	r19, r25
     8e4:	20 f0       	brcs	.+8      	; 0x8ee <prvCopyDataFromQueue+0x28>
     8e6:	80 81       	ld	r24, Z
     8e8:	91 81       	ldd	r25, Z+1	; 0x01
     8ea:	97 83       	std	Z+7, r25	; 0x07
     8ec:	86 83       	std	Z+6, r24	; 0x06
     8ee:	cb 01       	movw	r24, r22
     8f0:	66 81       	ldd	r22, Z+6	; 0x06
     8f2:	77 81       	ldd	r23, Z+7	; 0x07
     8f4:	0c 94 57 0e 	jmp	0x1cae	; 0x1cae <memcpy>
     8f8:	08 95       	ret

000008fa <prvUnlockQueue>:
     8fa:	1f 93       	push	r17
     8fc:	cf 93       	push	r28
     8fe:	df 93       	push	r29
     900:	ec 01       	movw	r28, r24
     902:	0f b6       	in	r0, 0x3f	; 63
     904:	f8 94       	cli
     906:	0f 92       	push	r0
     908:	1a a1       	ldd	r17, Y+34	; 0x22
     90a:	09 c0       	rjmp	.+18     	; 0x91e <prvUnlockQueue+0x24>
     90c:	8b 89       	ldd	r24, Y+19	; 0x13
     90e:	88 23       	and	r24, r24
     910:	41 f0       	breq	.+16     	; 0x922 <prvUnlockQueue+0x28>
     912:	ce 01       	movw	r24, r28
     914:	43 96       	adiw	r24, 0x13	; 19
     916:	34 d6       	rcall	.+3176   	; 0x1580 <xTaskRemoveFromEventList>
     918:	81 11       	cpse	r24, r1
     91a:	eb d6       	rcall	.+3542   	; 0x16f2 <vTaskMissedYield>
     91c:	11 50       	subi	r17, 0x01	; 1
     91e:	11 16       	cp	r1, r17
     920:	ac f3       	brlt	.-22     	; 0x90c <prvUnlockQueue+0x12>
     922:	8f ef       	ldi	r24, 0xFF	; 255
     924:	8a a3       	std	Y+34, r24	; 0x22
     926:	0f 90       	pop	r0
     928:	0f be       	out	0x3f, r0	; 63
     92a:	0f b6       	in	r0, 0x3f	; 63
     92c:	f8 94       	cli
     92e:	0f 92       	push	r0
     930:	19 a1       	ldd	r17, Y+33	; 0x21
     932:	09 c0       	rjmp	.+18     	; 0x946 <prvUnlockQueue+0x4c>
     934:	88 85       	ldd	r24, Y+8	; 0x08
     936:	88 23       	and	r24, r24
     938:	41 f0       	breq	.+16     	; 0x94a <prvUnlockQueue+0x50>
     93a:	ce 01       	movw	r24, r28
     93c:	08 96       	adiw	r24, 0x08	; 8
     93e:	20 d6       	rcall	.+3136   	; 0x1580 <xTaskRemoveFromEventList>
     940:	81 11       	cpse	r24, r1
     942:	d7 d6       	rcall	.+3502   	; 0x16f2 <vTaskMissedYield>
     944:	11 50       	subi	r17, 0x01	; 1
     946:	11 16       	cp	r1, r17
     948:	ac f3       	brlt	.-22     	; 0x934 <prvUnlockQueue+0x3a>
     94a:	8f ef       	ldi	r24, 0xFF	; 255
     94c:	89 a3       	std	Y+33, r24	; 0x21
     94e:	0f 90       	pop	r0
     950:	0f be       	out	0x3f, r0	; 63
     952:	df 91       	pop	r29
     954:	cf 91       	pop	r28
     956:	1f 91       	pop	r17
     958:	08 95       	ret

0000095a <xQueueGenericReset>:
     95a:	cf 93       	push	r28
     95c:	df 93       	push	r29
     95e:	ec 01       	movw	r28, r24
     960:	0f b6       	in	r0, 0x3f	; 63
     962:	f8 94       	cli
     964:	0f 92       	push	r0
     966:	e8 81       	ld	r30, Y
     968:	f9 81       	ldd	r31, Y+1	; 0x01
     96a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	28 a1       	ldd	r18, Y+32	; 0x20
     970:	30 e0       	ldi	r19, 0x00	; 0
     972:	82 9f       	mul	r24, r18
     974:	a0 01       	movw	r20, r0
     976:	83 9f       	mul	r24, r19
     978:	50 0d       	add	r21, r0
     97a:	92 9f       	mul	r25, r18
     97c:	50 0d       	add	r21, r0
     97e:	11 24       	eor	r1, r1
     980:	4e 0f       	add	r20, r30
     982:	5f 1f       	adc	r21, r31
     984:	5b 83       	std	Y+3, r21	; 0x03
     986:	4a 83       	std	Y+2, r20	; 0x02
     988:	1e 8e       	std	Y+30, r1	; 0x1e
     98a:	fd 83       	std	Y+5, r31	; 0x05
     98c:	ec 83       	std	Y+4, r30	; 0x04
     98e:	01 97       	sbiw	r24, 0x01	; 1
     990:	28 9f       	mul	r18, r24
     992:	a0 01       	movw	r20, r0
     994:	29 9f       	mul	r18, r25
     996:	50 0d       	add	r21, r0
     998:	38 9f       	mul	r19, r24
     99a:	50 0d       	add	r21, r0
     99c:	11 24       	eor	r1, r1
     99e:	cf 01       	movw	r24, r30
     9a0:	84 0f       	add	r24, r20
     9a2:	95 1f       	adc	r25, r21
     9a4:	9f 83       	std	Y+7, r25	; 0x07
     9a6:	8e 83       	std	Y+6, r24	; 0x06
     9a8:	8f ef       	ldi	r24, 0xFF	; 255
     9aa:	89 a3       	std	Y+33, r24	; 0x21
     9ac:	8a a3       	std	Y+34, r24	; 0x22
     9ae:	61 11       	cpse	r22, r1
     9b0:	0a c0       	rjmp	.+20     	; 0x9c6 <xQueueGenericReset+0x6c>
     9b2:	88 85       	ldd	r24, Y+8	; 0x08
     9b4:	88 23       	and	r24, r24
     9b6:	69 f0       	breq	.+26     	; 0x9d2 <xQueueGenericReset+0x78>
     9b8:	ce 01       	movw	r24, r28
     9ba:	08 96       	adiw	r24, 0x08	; 8
     9bc:	e1 d5       	rcall	.+3010   	; 0x1580 <xTaskRemoveFromEventList>
     9be:	88 23       	and	r24, r24
     9c0:	41 f0       	breq	.+16     	; 0x9d2 <xQueueGenericReset+0x78>
     9c2:	44 de       	rcall	.-888    	; 0x64c <vPortYield>
     9c4:	06 c0       	rjmp	.+12     	; 0x9d2 <xQueueGenericReset+0x78>
     9c6:	ce 01       	movw	r24, r28
     9c8:	08 96       	adiw	r24, 0x08	; 8
     9ca:	ae db       	rcall	.-2212   	; 0x128 <vListInitialise>
     9cc:	ce 01       	movw	r24, r28
     9ce:	43 96       	adiw	r24, 0x13	; 19
     9d0:	ab db       	rcall	.-2218   	; 0x128 <vListInitialise>
     9d2:	0f 90       	pop	r0
     9d4:	0f be       	out	0x3f, r0	; 63
     9d6:	81 e0       	ldi	r24, 0x01	; 1
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	08 95       	ret

000009de <prvInitialiseNewQueue>:
     9de:	0f 93       	push	r16
     9e0:	1f 93       	push	r17
     9e2:	f8 01       	movw	r30, r16
     9e4:	61 11       	cpse	r22, r1
     9e6:	03 c0       	rjmp	.+6      	; 0x9ee <prvInitialiseNewQueue+0x10>
     9e8:	11 83       	std	Z+1, r17	; 0x01
     9ea:	00 83       	st	Z, r16
     9ec:	02 c0       	rjmp	.+4      	; 0x9f2 <prvInitialiseNewQueue+0x14>
     9ee:	51 83       	std	Z+1, r21	; 0x01
     9f0:	40 83       	st	Z, r20
     9f2:	87 8f       	std	Z+31, r24	; 0x1f
     9f4:	60 a3       	std	Z+32, r22	; 0x20
     9f6:	61 e0       	ldi	r22, 0x01	; 1
     9f8:	cf 01       	movw	r24, r30
     9fa:	af df       	rcall	.-162    	; 0x95a <xQueueGenericReset>
     9fc:	1f 91       	pop	r17
     9fe:	0f 91       	pop	r16
     a00:	08 95       	ret

00000a02 <xQueueGenericCreate>:
     a02:	df 92       	push	r13
     a04:	ef 92       	push	r14
     a06:	ff 92       	push	r15
     a08:	0f 93       	push	r16
     a0a:	1f 93       	push	r17
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	e8 2e       	mov	r14, r24
     a12:	f6 2e       	mov	r15, r22
     a14:	d4 2e       	mov	r13, r20
     a16:	66 23       	and	r22, r22
     a18:	21 f0       	breq	.+8      	; 0xa22 <xQueueGenericCreate+0x20>
     a1a:	86 9f       	mul	r24, r22
     a1c:	c0 01       	movw	r24, r0
     a1e:	11 24       	eor	r1, r1
     a20:	02 c0       	rjmp	.+4      	; 0xa26 <xQueueGenericCreate+0x24>
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	90 e0       	ldi	r25, 0x00	; 0
     a26:	83 96       	adiw	r24, 0x23	; 35
     a28:	99 dc       	rcall	.-1742   	; 0x35c <pvPortMalloc>
     a2a:	ec 01       	movw	r28, r24
     a2c:	00 97       	sbiw	r24, 0x00	; 0
     a2e:	41 f0       	breq	.+16     	; 0xa40 <xQueueGenericCreate+0x3e>
     a30:	8c 01       	movw	r16, r24
     a32:	2d 2d       	mov	r18, r13
     a34:	ac 01       	movw	r20, r24
     a36:	4d 5d       	subi	r20, 0xDD	; 221
     a38:	5f 4f       	sbci	r21, 0xFF	; 255
     a3a:	6f 2d       	mov	r22, r15
     a3c:	8e 2d       	mov	r24, r14
     a3e:	cf df       	rcall	.-98     	; 0x9de <prvInitialiseNewQueue>
     a40:	ce 01       	movw	r24, r28
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	1f 91       	pop	r17
     a48:	0f 91       	pop	r16
     a4a:	ff 90       	pop	r15
     a4c:	ef 90       	pop	r14
     a4e:	df 90       	pop	r13
     a50:	08 95       	ret

00000a52 <xQueueGenericSend>:
     a52:	cf 92       	push	r12
     a54:	df 92       	push	r13
     a56:	ef 92       	push	r14
     a58:	ff 92       	push	r15
     a5a:	0f 93       	push	r16
     a5c:	1f 93       	push	r17
     a5e:	cf 93       	push	r28
     a60:	df 93       	push	r29
     a62:	cd b7       	in	r28, 0x3d	; 61
     a64:	de b7       	in	r29, 0x3e	; 62
     a66:	29 97       	sbiw	r28, 0x09	; 9
     a68:	0f b6       	in	r0, 0x3f	; 63
     a6a:	f8 94       	cli
     a6c:	de bf       	out	0x3e, r29	; 62
     a6e:	0f be       	out	0x3f, r0	; 63
     a70:	cd bf       	out	0x3d, r28	; 61
     a72:	7c 01       	movw	r14, r24
     a74:	6b 01       	movw	r12, r22
     a76:	2e 83       	std	Y+6, r18	; 0x06
     a78:	3f 83       	std	Y+7, r19	; 0x07
     a7a:	48 87       	std	Y+8, r20	; 0x08
     a7c:	59 87       	std	Y+9, r21	; 0x09
     a7e:	10 e0       	ldi	r17, 0x00	; 0
     a80:	0f b6       	in	r0, 0x3f	; 63
     a82:	f8 94       	cli
     a84:	0f 92       	push	r0
     a86:	f7 01       	movw	r30, r14
     a88:	96 8d       	ldd	r25, Z+30	; 0x1e
     a8a:	87 8d       	ldd	r24, Z+31	; 0x1f
     a8c:	98 17       	cp	r25, r24
     a8e:	10 f0       	brcs	.+4      	; 0xa94 <xQueueGenericSend+0x42>
     a90:	02 30       	cpi	r16, 0x02	; 2
     a92:	a9 f4       	brne	.+42     	; 0xabe <xQueueGenericSend+0x6c>
     a94:	40 2f       	mov	r20, r16
     a96:	b6 01       	movw	r22, r12
     a98:	c7 01       	movw	r24, r14
     a9a:	b7 de       	rcall	.-658    	; 0x80a <prvCopyDataToQueue>
     a9c:	f7 01       	movw	r30, r14
     a9e:	93 89       	ldd	r25, Z+19	; 0x13
     aa0:	99 23       	and	r25, r25
     aa2:	39 f0       	breq	.+14     	; 0xab2 <xQueueGenericSend+0x60>
     aa4:	c7 01       	movw	r24, r14
     aa6:	43 96       	adiw	r24, 0x13	; 19
     aa8:	6b d5       	rcall	.+2774   	; 0x1580 <xTaskRemoveFromEventList>
     aaa:	88 23       	and	r24, r24
     aac:	21 f0       	breq	.+8      	; 0xab6 <xQueueGenericSend+0x64>
     aae:	ce dd       	rcall	.-1124   	; 0x64c <vPortYield>
     ab0:	02 c0       	rjmp	.+4      	; 0xab6 <xQueueGenericSend+0x64>
     ab2:	81 11       	cpse	r24, r1
     ab4:	cb dd       	rcall	.-1130   	; 0x64c <vPortYield>
     ab6:	0f 90       	pop	r0
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	81 e0       	ldi	r24, 0x01	; 1
     abc:	46 c0       	rjmp	.+140    	; 0xb4a <xQueueGenericSend+0xf8>
     abe:	8e 81       	ldd	r24, Y+6	; 0x06
     ac0:	9f 81       	ldd	r25, Y+7	; 0x07
     ac2:	a8 85       	ldd	r26, Y+8	; 0x08
     ac4:	b9 85       	ldd	r27, Y+9	; 0x09
     ac6:	89 2b       	or	r24, r25
     ac8:	8a 2b       	or	r24, r26
     aca:	8b 2b       	or	r24, r27
     acc:	21 f4       	brne	.+8      	; 0xad6 <xQueueGenericSend+0x84>
     ace:	0f 90       	pop	r0
     ad0:	0f be       	out	0x3f, r0	; 63
     ad2:	80 e0       	ldi	r24, 0x00	; 0
     ad4:	3a c0       	rjmp	.+116    	; 0xb4a <xQueueGenericSend+0xf8>
     ad6:	11 11       	cpse	r17, r1
     ad8:	04 c0       	rjmp	.+8      	; 0xae2 <xQueueGenericSend+0x90>
     ada:	ce 01       	movw	r24, r28
     adc:	01 96       	adiw	r24, 0x01	; 1
     ade:	92 d5       	rcall	.+2852   	; 0x1604 <vTaskSetTimeOutState>
     ae0:	11 e0       	ldi	r17, 0x01	; 1
     ae2:	0f 90       	pop	r0
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	61 d3       	rcall	.+1730   	; 0x11aa <vTaskSuspendAll>
     ae8:	0f b6       	in	r0, 0x3f	; 63
     aea:	f8 94       	cli
     aec:	0f 92       	push	r0
     aee:	f7 01       	movw	r30, r14
     af0:	81 a1       	ldd	r24, Z+33	; 0x21
     af2:	8f 3f       	cpi	r24, 0xFF	; 255
     af4:	09 f4       	brne	.+2      	; 0xaf8 <xQueueGenericSend+0xa6>
     af6:	11 a2       	std	Z+33, r1	; 0x21
     af8:	f7 01       	movw	r30, r14
     afa:	82 a1       	ldd	r24, Z+34	; 0x22
     afc:	8f 3f       	cpi	r24, 0xFF	; 255
     afe:	09 f4       	brne	.+2      	; 0xb02 <xQueueGenericSend+0xb0>
     b00:	12 a2       	std	Z+34, r1	; 0x22
     b02:	0f 90       	pop	r0
     b04:	0f be       	out	0x3f, r0	; 63
     b06:	be 01       	movw	r22, r28
     b08:	6a 5f       	subi	r22, 0xFA	; 250
     b0a:	7f 4f       	sbci	r23, 0xFF	; 255
     b0c:	ce 01       	movw	r24, r28
     b0e:	01 96       	adiw	r24, 0x01	; 1
     b10:	8a d5       	rcall	.+2836   	; 0x1626 <xTaskCheckForTimeOut>
     b12:	81 11       	cpse	r24, r1
     b14:	16 c0       	rjmp	.+44     	; 0xb42 <xQueueGenericSend+0xf0>
     b16:	c7 01       	movw	r24, r14
     b18:	6a de       	rcall	.-812    	; 0x7ee <prvIsQueueFull>
     b1a:	88 23       	and	r24, r24
     b1c:	71 f0       	breq	.+28     	; 0xb3a <xQueueGenericSend+0xe8>
     b1e:	4e 81       	ldd	r20, Y+6	; 0x06
     b20:	5f 81       	ldd	r21, Y+7	; 0x07
     b22:	68 85       	ldd	r22, Y+8	; 0x08
     b24:	79 85       	ldd	r23, Y+9	; 0x09
     b26:	c7 01       	movw	r24, r14
     b28:	08 96       	adiw	r24, 0x08	; 8
     b2a:	13 d5       	rcall	.+2598   	; 0x1552 <vTaskPlaceOnEventList>
     b2c:	c7 01       	movw	r24, r14
     b2e:	e5 de       	rcall	.-566    	; 0x8fa <prvUnlockQueue>
     b30:	11 d4       	rcall	.+2082   	; 0x1354 <xTaskResumeAll>
     b32:	81 11       	cpse	r24, r1
     b34:	a5 cf       	rjmp	.-182    	; 0xa80 <xQueueGenericSend+0x2e>
     b36:	8a dd       	rcall	.-1260   	; 0x64c <vPortYield>
     b38:	a3 cf       	rjmp	.-186    	; 0xa80 <xQueueGenericSend+0x2e>
     b3a:	c7 01       	movw	r24, r14
     b3c:	de de       	rcall	.-580    	; 0x8fa <prvUnlockQueue>
     b3e:	0a d4       	rcall	.+2068   	; 0x1354 <xTaskResumeAll>
     b40:	9f cf       	rjmp	.-194    	; 0xa80 <xQueueGenericSend+0x2e>
     b42:	c7 01       	movw	r24, r14
     b44:	da de       	rcall	.-588    	; 0x8fa <prvUnlockQueue>
     b46:	06 d4       	rcall	.+2060   	; 0x1354 <xTaskResumeAll>
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	29 96       	adiw	r28, 0x09	; 9
     b4c:	0f b6       	in	r0, 0x3f	; 63
     b4e:	f8 94       	cli
     b50:	de bf       	out	0x3e, r29	; 62
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	cd bf       	out	0x3d, r28	; 61
     b56:	df 91       	pop	r29
     b58:	cf 91       	pop	r28
     b5a:	1f 91       	pop	r17
     b5c:	0f 91       	pop	r16
     b5e:	ff 90       	pop	r15
     b60:	ef 90       	pop	r14
     b62:	df 90       	pop	r13
     b64:	cf 90       	pop	r12
     b66:	08 95       	ret

00000b68 <prvInitialiseMutex>:
     b68:	0f 93       	push	r16
     b6a:	00 97       	sbiw	r24, 0x00	; 0
     b6c:	69 f0       	breq	.+26     	; 0xb88 <prvInitialiseMutex+0x20>
     b6e:	fc 01       	movw	r30, r24
     b70:	13 82       	std	Z+3, r1	; 0x03
     b72:	12 82       	std	Z+2, r1	; 0x02
     b74:	11 82       	std	Z+1, r1	; 0x01
     b76:	10 82       	st	Z, r1
     b78:	16 82       	std	Z+6, r1	; 0x06
     b7a:	00 e0       	ldi	r16, 0x00	; 0
     b7c:	20 e0       	ldi	r18, 0x00	; 0
     b7e:	30 e0       	ldi	r19, 0x00	; 0
     b80:	a9 01       	movw	r20, r18
     b82:	60 e0       	ldi	r22, 0x00	; 0
     b84:	70 e0       	ldi	r23, 0x00	; 0
     b86:	65 df       	rcall	.-310    	; 0xa52 <xQueueGenericSend>
     b88:	0f 91       	pop	r16
     b8a:	08 95       	ret

00000b8c <xQueueCreateMutex>:
     b8c:	cf 93       	push	r28
     b8e:	df 93       	push	r29
     b90:	48 2f       	mov	r20, r24
     b92:	60 e0       	ldi	r22, 0x00	; 0
     b94:	81 e0       	ldi	r24, 0x01	; 1
     b96:	35 df       	rcall	.-406    	; 0xa02 <xQueueGenericCreate>
     b98:	ec 01       	movw	r28, r24
     b9a:	e6 df       	rcall	.-52     	; 0xb68 <prvInitialiseMutex>
     b9c:	ce 01       	movw	r24, r28
     b9e:	df 91       	pop	r29
     ba0:	cf 91       	pop	r28
     ba2:	08 95       	ret

00000ba4 <xQueueGenericSendFromISR>:
     ba4:	ef 92       	push	r14
     ba6:	ff 92       	push	r15
     ba8:	0f 93       	push	r16
     baa:	1f 93       	push	r17
     bac:	cf 93       	push	r28
     bae:	df 93       	push	r29
     bb0:	8a 01       	movw	r16, r20
     bb2:	fc 01       	movw	r30, r24
     bb4:	56 8d       	ldd	r21, Z+30	; 0x1e
     bb6:	37 8d       	ldd	r19, Z+31	; 0x1f
     bb8:	53 17       	cp	r21, r19
     bba:	10 f0       	brcs	.+4      	; 0xbc0 <xQueueGenericSendFromISR+0x1c>
     bbc:	22 30       	cpi	r18, 0x02	; 2
     bbe:	e1 f4       	brne	.+56     	; 0xbf8 <xQueueGenericSendFromISR+0x54>
     bc0:	42 2f       	mov	r20, r18
     bc2:	78 01       	movw	r14, r16
     bc4:	ec 01       	movw	r28, r24
     bc6:	1a a1       	ldd	r17, Y+34	; 0x22
     bc8:	20 de       	rcall	.-960    	; 0x80a <prvCopyDataToQueue>
     bca:	1f 3f       	cpi	r17, 0xFF	; 255
     bcc:	79 f4       	brne	.+30     	; 0xbec <xQueueGenericSendFromISR+0x48>
     bce:	8b 89       	ldd	r24, Y+19	; 0x13
     bd0:	88 23       	and	r24, r24
     bd2:	a1 f0       	breq	.+40     	; 0xbfc <xQueueGenericSendFromISR+0x58>
     bd4:	ce 01       	movw	r24, r28
     bd6:	43 96       	adiw	r24, 0x13	; 19
     bd8:	d3 d4       	rcall	.+2470   	; 0x1580 <xTaskRemoveFromEventList>
     bda:	88 23       	and	r24, r24
     bdc:	89 f0       	breq	.+34     	; 0xc00 <xQueueGenericSendFromISR+0x5c>
     bde:	e1 14       	cp	r14, r1
     be0:	f1 04       	cpc	r15, r1
     be2:	81 f0       	breq	.+32     	; 0xc04 <xQueueGenericSendFromISR+0x60>
     be4:	81 e0       	ldi	r24, 0x01	; 1
     be6:	f7 01       	movw	r30, r14
     be8:	80 83       	st	Z, r24
     bea:	0d c0       	rjmp	.+26     	; 0xc06 <xQueueGenericSendFromISR+0x62>
     bec:	ff 24       	eor	r15, r15
     bee:	f3 94       	inc	r15
     bf0:	f1 0e       	add	r15, r17
     bf2:	fa a2       	std	Y+34, r15	; 0x22
     bf4:	81 e0       	ldi	r24, 0x01	; 1
     bf6:	07 c0       	rjmp	.+14     	; 0xc06 <xQueueGenericSendFromISR+0x62>
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	05 c0       	rjmp	.+10     	; 0xc06 <xQueueGenericSendFromISR+0x62>
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	03 c0       	rjmp	.+6      	; 0xc06 <xQueueGenericSendFromISR+0x62>
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	01 c0       	rjmp	.+2      	; 0xc06 <xQueueGenericSendFromISR+0x62>
     c04:	81 e0       	ldi	r24, 0x01	; 1
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
     c0a:	1f 91       	pop	r17
     c0c:	0f 91       	pop	r16
     c0e:	ff 90       	pop	r15
     c10:	ef 90       	pop	r14
     c12:	08 95       	ret

00000c14 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     c14:	8f 92       	push	r8
     c16:	9f 92       	push	r9
     c18:	bf 92       	push	r11
     c1a:	cf 92       	push	r12
     c1c:	df 92       	push	r13
     c1e:	ef 92       	push	r14
     c20:	ff 92       	push	r15
     c22:	0f 93       	push	r16
     c24:	1f 93       	push	r17
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	cd b7       	in	r28, 0x3d	; 61
     c2c:	de b7       	in	r29, 0x3e	; 62
     c2e:	29 97       	sbiw	r28, 0x09	; 9
     c30:	0f b6       	in	r0, 0x3f	; 63
     c32:	f8 94       	cli
     c34:	de bf       	out	0x3e, r29	; 62
     c36:	0f be       	out	0x3f, r0	; 63
     c38:	cd bf       	out	0x3d, r28	; 61
     c3a:	7c 01       	movw	r14, r24
     c3c:	6b 01       	movw	r12, r22
     c3e:	2e 83       	std	Y+6, r18	; 0x06
     c40:	3f 83       	std	Y+7, r19	; 0x07
     c42:	48 87       	std	Y+8, r20	; 0x08
     c44:	59 87       	std	Y+9, r21	; 0x09
     c46:	b0 2e       	mov	r11, r16
BaseType_t xEntryTimeSet = pdFALSE;
     c48:	00 e0       	ldi	r16, 0x00	; 0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     c4a:	0f b6       	in	r0, 0x3f	; 63
     c4c:	f8 94       	cli
     c4e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     c50:	f7 01       	movw	r30, r14
     c52:	16 8d       	ldd	r17, Z+30	; 0x1e

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     c54:	11 23       	and	r17, r17
     c56:	61 f1       	breq	.+88     	; 0xcb0 <xQueueGenericReceive+0x9c>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     c58:	86 80       	ldd	r8, Z+6	; 0x06
     c5a:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     c5c:	b6 01       	movw	r22, r12
     c5e:	c7 01       	movw	r24, r14
     c60:	32 de       	rcall	.-924    	; 0x8c6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     c62:	b1 10       	cpse	r11, r1
     c64:	16 c0       	rjmp	.+44     	; 0xc92 <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     c66:	11 50       	subi	r17, 0x01	; 1
     c68:	f7 01       	movw	r30, r14
     c6a:	16 8f       	std	Z+30, r17	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c6c:	80 81       	ld	r24, Z
     c6e:	91 81       	ldd	r25, Z+1	; 0x01
     c70:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     c72:	21 f4       	brne	.+8      	; 0xc7c <xQueueGenericReceive+0x68>
     c74:	e0 d5       	rcall	.+3008   	; 0x1836 <pvTaskIncrementMutexHeldCount>
     c76:	f7 01       	movw	r30, r14
     c78:	93 83       	std	Z+3, r25	; 0x03
     c7a:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c7c:	f7 01       	movw	r30, r14
     c7e:	80 85       	ldd	r24, Z+8	; 0x08
     c80:	88 23       	and	r24, r24
     c82:	91 f0       	breq	.+36     	; 0xca8 <xQueueGenericReceive+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c84:	c7 01       	movw	r24, r14
     c86:	08 96       	adiw	r24, 0x08	; 8
     c88:	7b d4       	rcall	.+2294   	; 0x1580 <xTaskRemoveFromEventList>
     c8a:	88 23       	and	r24, r24
						{
							queueYIELD_IF_USING_PREEMPTION();
     c8c:	69 f0       	breq	.+26     	; 0xca8 <xQueueGenericReceive+0x94>
     c8e:	de dc       	rcall	.-1604   	; 0x64c <vPortYield>
     c90:	0b c0       	rjmp	.+22     	; 0xca8 <xQueueGenericReceive+0x94>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     c92:	f7 01       	movw	r30, r14
     c94:	97 82       	std	Z+7, r9	; 0x07
     c96:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c98:	83 89       	ldd	r24, Z+19	; 0x13
     c9a:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c9c:	29 f0       	breq	.+10     	; 0xca8 <xQueueGenericReceive+0x94>
     c9e:	c7 01       	movw	r24, r14
     ca0:	43 96       	adiw	r24, 0x13	; 19
     ca2:	6e d4       	rcall	.+2268   	; 0x1580 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     ca4:	81 11       	cpse	r24, r1
     ca6:	d2 dc       	rcall	.-1628   	; 0x64c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     ca8:	0f 90       	pop	r0
     caa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	58 c0       	rjmp	.+176    	; 0xd60 <xQueueGenericReceive+0x14c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     cb0:	8e 81       	ldd	r24, Y+6	; 0x06
     cb2:	9f 81       	ldd	r25, Y+7	; 0x07
     cb4:	a8 85       	ldd	r26, Y+8	; 0x08
     cb6:	b9 85       	ldd	r27, Y+9	; 0x09
     cb8:	89 2b       	or	r24, r25
     cba:	8a 2b       	or	r24, r26
     cbc:	8b 2b       	or	r24, r27
     cbe:	21 f4       	brne	.+8      	; 0xcc8 <xQueueGenericReceive+0xb4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     cc0:	0f 90       	pop	r0
     cc2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     cc4:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     cc6:	4c c0       	rjmp	.+152    	; 0xd60 <xQueueGenericReceive+0x14c>
     cc8:	01 11       	cpse	r16, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     cca:	04 c0       	rjmp	.+8      	; 0xcd4 <xQueueGenericReceive+0xc0>
     ccc:	ce 01       	movw	r24, r28
     cce:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     cd0:	99 d4       	rcall	.+2354   	; 0x1604 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     cd2:	01 e0       	ldi	r16, 0x01	; 1
     cd4:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     cd6:	0f be       	out	0x3f, r0	; 63
     cd8:	68 d2       	rcall	.+1232   	; 0x11aa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     cda:	0f b6       	in	r0, 0x3f	; 63
     cdc:	f8 94       	cli
     cde:	0f 92       	push	r0
     ce0:	f7 01       	movw	r30, r14
     ce2:	81 a1       	ldd	r24, Z+33	; 0x21
     ce4:	8f 3f       	cpi	r24, 0xFF	; 255
     ce6:	09 f4       	brne	.+2      	; 0xcea <xQueueGenericReceive+0xd6>
     ce8:	11 a2       	std	Z+33, r1	; 0x21
     cea:	f7 01       	movw	r30, r14
     cec:	82 a1       	ldd	r24, Z+34	; 0x22
     cee:	8f 3f       	cpi	r24, 0xFF	; 255
     cf0:	09 f4       	brne	.+2      	; 0xcf4 <xQueueGenericReceive+0xe0>
     cf2:	12 a2       	std	Z+34, r1	; 0x22
     cf4:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     cf6:	0f be       	out	0x3f, r0	; 63
     cf8:	be 01       	movw	r22, r28
     cfa:	6a 5f       	subi	r22, 0xFA	; 250
     cfc:	7f 4f       	sbci	r23, 0xFF	; 255
     cfe:	ce 01       	movw	r24, r28
     d00:	01 96       	adiw	r24, 0x01	; 1
     d02:	91 d4       	rcall	.+2338   	; 0x1626 <xTaskCheckForTimeOut>
     d04:	81 11       	cpse	r24, r1
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d06:	23 c0       	rjmp	.+70     	; 0xd4e <xQueueGenericReceive+0x13a>
     d08:	c7 01       	movw	r24, r14
     d0a:	64 dd       	rcall	.-1336   	; 0x7d4 <prvIsQueueEmpty>
     d0c:	88 23       	and	r24, r24
     d0e:	d9 f0       	breq	.+54     	; 0xd46 <xQueueGenericReceive+0x132>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d10:	f7 01       	movw	r30, r14
     d12:	80 81       	ld	r24, Z
     d14:	91 81       	ldd	r25, Z+1	; 0x01
     d16:	89 2b       	or	r24, r25
					{
						taskENTER_CRITICAL();
     d18:	41 f4       	brne	.+16     	; 0xd2a <xQueueGenericReceive+0x116>
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	f8 94       	cli
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     d1e:	0f 92       	push	r0
     d20:	82 81       	ldd	r24, Z+2	; 0x02
     d22:	93 81       	ldd	r25, Z+3	; 0x03
						}
						taskEXIT_CRITICAL();
     d24:	ea d4       	rcall	.+2516   	; 0x16fa <vTaskPriorityInherit>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d26:	0f 90       	pop	r0
     d28:	0f be       	out	0x3f, r0	; 63
     d2a:	4e 81       	ldd	r20, Y+6	; 0x06
     d2c:	5f 81       	ldd	r21, Y+7	; 0x07
     d2e:	68 85       	ldd	r22, Y+8	; 0x08
				prvUnlockQueue( pxQueue );
     d30:	79 85       	ldd	r23, Y+9	; 0x09
				if( xTaskResumeAll() == pdFALSE )
     d32:	c7 01       	movw	r24, r14
     d34:	43 96       	adiw	r24, 0x13	; 19
     d36:	0d d4       	rcall	.+2074   	; 0x1552 <vTaskPlaceOnEventList>
				{
					portYIELD_WITHIN_API();
     d38:	c7 01       	movw	r24, r14
     d3a:	df dd       	rcall	.-1090   	; 0x8fa <prvUnlockQueue>
     d3c:	0b d3       	rcall	.+1558   	; 0x1354 <xTaskResumeAll>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     d3e:	81 11       	cpse	r24, r1
     d40:	84 cf       	rjmp	.-248    	; 0xc4a <xQueueGenericReceive+0x36>
     d42:	84 dc       	rcall	.-1784   	; 0x64c <vPortYield>
				( void ) xTaskResumeAll();
     d44:	82 cf       	rjmp	.-252    	; 0xc4a <xQueueGenericReceive+0x36>
     d46:	c7 01       	movw	r24, r14
     d48:	d8 dd       	rcall	.-1104   	; 0x8fa <prvUnlockQueue>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     d4a:	04 d3       	rcall	.+1544   	; 0x1354 <xTaskResumeAll>
     d4c:	7e cf       	rjmp	.-260    	; 0xc4a <xQueueGenericReceive+0x36>
     d4e:	c7 01       	movw	r24, r14
			( void ) xTaskResumeAll();
     d50:	d4 dd       	rcall	.-1112   	; 0x8fa <prvUnlockQueue>
     d52:	00 d3       	rcall	.+1536   	; 0x1354 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d54:	c7 01       	movw	r24, r14
     d56:	3e dd       	rcall	.-1412   	; 0x7d4 <prvIsQueueEmpty>
     d58:	88 23       	and	r24, r24
     d5a:	09 f4       	brne	.+2      	; 0xd5e <xQueueGenericReceive+0x14a>
     d5c:	76 cf       	rjmp	.-276    	; 0xc4a <xQueueGenericReceive+0x36>
     d5e:	80 e0       	ldi	r24, 0x00	; 0
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     d60:	29 96       	adiw	r28, 0x09	; 9
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     d62:	0f b6       	in	r0, 0x3f	; 63
     d64:	f8 94       	cli
     d66:	de bf       	out	0x3e, r29	; 62
     d68:	0f be       	out	0x3f, r0	; 63
     d6a:	cd bf       	out	0x3d, r28	; 61
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	1f 91       	pop	r17
     d72:	0f 91       	pop	r16
     d74:	ff 90       	pop	r15
     d76:	ef 90       	pop	r14
     d78:	df 90       	pop	r13
     d7a:	cf 90       	pop	r12
     d7c:	bf 90       	pop	r11
     d7e:	9f 90       	pop	r9
     d80:	8f 90       	pop	r8
     d82:	08 95       	ret

00000d84 <prvResetNextTaskUnblockTime>:
     d84:	e0 91 82 1a 	lds	r30, 0x1A82	; 0x801a82 <pxDelayedTaskList>
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     d88:	f0 91 83 1a 	lds	r31, 0x1A83	; 0x801a83 <pxDelayedTaskList+0x1>
     d8c:	80 81       	ld	r24, Z
     d8e:	81 11       	cpse	r24, r1
     d90:	0c c0       	rjmp	.+24     	; 0xdaa <prvResetNextTaskUnblockTime+0x26>
     d92:	8f ef       	ldi	r24, 0xFF	; 255
     d94:	9f ef       	ldi	r25, 0xFF	; 255
     d96:	dc 01       	movw	r26, r24
     d98:	80 93 4f 1a 	sts	0x1A4F, r24	; 0x801a4f <xNextTaskUnblockTime>
     d9c:	90 93 50 1a 	sts	0x1A50, r25	; 0x801a50 <xNextTaskUnblockTime+0x1>
     da0:	a0 93 51 1a 	sts	0x1A51, r26	; 0x801a51 <xNextTaskUnblockTime+0x2>
     da4:	b0 93 52 1a 	sts	0x1A52, r27	; 0x801a52 <xNextTaskUnblockTime+0x3>
     da8:	08 95       	ret
     daa:	e0 91 82 1a 	lds	r30, 0x1A82	; 0x801a82 <pxDelayedTaskList>
     dae:	f0 91 83 1a 	lds	r31, 0x1A83	; 0x801a83 <pxDelayedTaskList+0x1>
     db2:	07 80       	ldd	r0, Z+7	; 0x07
     db4:	f0 85       	ldd	r31, Z+8	; 0x08
     db6:	e0 2d       	mov	r30, r0
     db8:	00 84       	ldd	r0, Z+8	; 0x08
     dba:	f1 85       	ldd	r31, Z+9	; 0x09
     dbc:	e0 2d       	mov	r30, r0
     dbe:	82 81       	ldd	r24, Z+2	; 0x02
     dc0:	93 81       	ldd	r25, Z+3	; 0x03
     dc2:	a4 81       	ldd	r26, Z+4	; 0x04
     dc4:	b5 81       	ldd	r27, Z+5	; 0x05
     dc6:	80 93 4f 1a 	sts	0x1A4F, r24	; 0x801a4f <xNextTaskUnblockTime>
     dca:	90 93 50 1a 	sts	0x1A50, r25	; 0x801a50 <xNextTaskUnblockTime+0x1>
     dce:	a0 93 51 1a 	sts	0x1A51, r26	; 0x801a51 <xNextTaskUnblockTime+0x2>
     dd2:	b0 93 52 1a 	sts	0x1A52, r27	; 0x801a52 <xNextTaskUnblockTime+0x3>
     dd6:	08 95       	ret

00000dd8 <prvDeleteTCB>:
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
     ddc:	ec 01       	movw	r28, r24
     dde:	8b 8d       	ldd	r24, Y+27	; 0x1b
     de0:	9c 8d       	ldd	r25, Y+28	; 0x1c
     de2:	4e db       	rcall	.-2404   	; 0x480 <vPortFree>
     de4:	ce 01       	movw	r24, r28
     de6:	4c db       	rcall	.-2408   	; 0x480 <vPortFree>
     de8:	df 91       	pop	r29
     dea:	cf 91       	pop	r28
     dec:	08 95       	ret

00000dee <prvInitialiseNewTask>:
     dee:	6f 92       	push	r6
     df0:	7f 92       	push	r7
     df2:	8f 92       	push	r8
     df4:	9f 92       	push	r9
     df6:	af 92       	push	r10
     df8:	bf 92       	push	r11
     dfa:	cf 92       	push	r12
     dfc:	df 92       	push	r13
     dfe:	ef 92       	push	r14
     e00:	0f 93       	push	r16
     e02:	1f 93       	push	r17
     e04:	cf 93       	push	r28
     e06:	df 93       	push	r29
     e08:	cd b7       	in	r28, 0x3d	; 61
     e0a:	de b7       	in	r29, 0x3e	; 62
     e0c:	4c 01       	movw	r8, r24
     e0e:	f5 01       	movw	r30, r10
     e10:	83 8d       	ldd	r24, Z+27	; 0x1b
     e12:	94 8d       	ldd	r25, Z+28	; 0x1c
     e14:	21 50       	subi	r18, 0x01	; 1
     e16:	31 09       	sbc	r19, r1
     e18:	3c 01       	movw	r6, r24
     e1a:	62 0e       	add	r6, r18
     e1c:	73 1e       	adc	r7, r19
     e1e:	20 e0       	ldi	r18, 0x00	; 0
     e20:	0f c0       	rjmp	.+30     	; 0xe40 <prvInitialiseNewTask+0x52>
     e22:	82 2f       	mov	r24, r18
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	fb 01       	movw	r30, r22
     e28:	e8 0f       	add	r30, r24
     e2a:	f9 1f       	adc	r31, r25
     e2c:	30 81       	ld	r19, Z
     e2e:	d5 01       	movw	r26, r10
     e30:	a8 0f       	add	r26, r24
     e32:	b9 1f       	adc	r27, r25
     e34:	5d 96       	adiw	r26, 0x1d	; 29
     e36:	3c 93       	st	X, r19
     e38:	80 81       	ld	r24, Z
     e3a:	88 23       	and	r24, r24
     e3c:	19 f0       	breq	.+6      	; 0xe44 <prvInitialiseNewTask+0x56>
     e3e:	2f 5f       	subi	r18, 0xFF	; 255
     e40:	24 31       	cpi	r18, 0x14	; 20
     e42:	78 f3       	brcs	.-34     	; 0xe22 <prvInitialiseNewTask+0x34>
     e44:	f5 01       	movw	r30, r10
     e46:	10 aa       	std	Z+48, r1	; 0x30
     e48:	f4 e0       	ldi	r31, 0x04	; 4
     e4a:	fe 15       	cp	r31, r14
     e4c:	18 f4       	brcc	.+6      	; 0xe54 <prvInitialiseNewTask+0x66>
     e4e:	68 94       	set
     e50:	ee 24       	eor	r14, r14
     e52:	e2 f8       	bld	r14, 2
     e54:	f5 01       	movw	r30, r10
     e56:	e2 8e       	std	Z+26, r14	; 0x1a
     e58:	e1 aa       	std	Z+49, r14	; 0x31
     e5a:	12 aa       	std	Z+50, r1	; 0x32
     e5c:	c5 01       	movw	r24, r10
     e5e:	02 96       	adiw	r24, 0x02	; 2
     e60:	74 d9       	rcall	.-3352   	; 0x14a <vListInitialiseItem>
     e62:	c5 01       	movw	r24, r10
     e64:	0e 96       	adiw	r24, 0x0e	; 14
     e66:	71 d9       	rcall	.-3358   	; 0x14a <vListInitialiseItem>
     e68:	f5 01       	movw	r30, r10
     e6a:	b3 86       	std	Z+11, r11	; 0x0b
     e6c:	a2 86       	std	Z+10, r10	; 0x0a
     e6e:	85 e0       	ldi	r24, 0x05	; 5
     e70:	90 e0       	ldi	r25, 0x00	; 0
     e72:	a0 e0       	ldi	r26, 0x00	; 0
     e74:	b0 e0       	ldi	r27, 0x00	; 0
     e76:	8e 19       	sub	r24, r14
     e78:	91 09       	sbc	r25, r1
     e7a:	a1 09       	sbc	r26, r1
     e7c:	b1 09       	sbc	r27, r1
     e7e:	86 87       	std	Z+14, r24	; 0x0e
     e80:	97 87       	std	Z+15, r25	; 0x0f
     e82:	a0 8b       	std	Z+16, r26	; 0x10
     e84:	b1 8b       	std	Z+17, r27	; 0x11
     e86:	b7 8a       	std	Z+23, r11	; 0x17
     e88:	a6 8a       	std	Z+22, r10	; 0x16
     e8a:	13 aa       	std	Z+51, r1	; 0x33
     e8c:	14 aa       	std	Z+52, r1	; 0x34
     e8e:	15 aa       	std	Z+53, r1	; 0x35
     e90:	16 aa       	std	Z+54, r1	; 0x36
     e92:	17 aa       	std	Z+55, r1	; 0x37
     e94:	a8 01       	movw	r20, r16
     e96:	b4 01       	movw	r22, r8
     e98:	c3 01       	movw	r24, r6
     e9a:	34 db       	rcall	.-2456   	; 0x504 <pxPortInitialiseStack>
     e9c:	f5 01       	movw	r30, r10
     e9e:	91 83       	std	Z+1, r25	; 0x01
     ea0:	80 83       	st	Z, r24
     ea2:	c1 14       	cp	r12, r1
     ea4:	d1 04       	cpc	r13, r1
     ea6:	19 f0       	breq	.+6      	; 0xeae <prvInitialiseNewTask+0xc0>
     ea8:	f6 01       	movw	r30, r12
     eaa:	b1 82       	std	Z+1, r11	; 0x01
     eac:	a0 82       	st	Z, r10
     eae:	df 91       	pop	r29
     eb0:	cf 91       	pop	r28
     eb2:	1f 91       	pop	r17
     eb4:	0f 91       	pop	r16
     eb6:	ef 90       	pop	r14
     eb8:	df 90       	pop	r13
     eba:	cf 90       	pop	r12
     ebc:	bf 90       	pop	r11
     ebe:	af 90       	pop	r10
     ec0:	9f 90       	pop	r9
     ec2:	8f 90       	pop	r8
     ec4:	7f 90       	pop	r7
     ec6:	6f 90       	pop	r6
     ec8:	08 95       	ret

00000eca <prvInitialiseTaskLists>:
     eca:	cf 93       	push	r28
     ecc:	c0 e0       	ldi	r28, 0x00	; 0
     ece:	08 c0       	rjmp	.+16     	; 0xee0 <prvInitialiseTaskLists+0x16>
     ed0:	2b e0       	ldi	r18, 0x0B	; 11
     ed2:	c2 9f       	mul	r28, r18
     ed4:	c0 01       	movw	r24, r0
     ed6:	11 24       	eor	r1, r1
     ed8:	86 56       	subi	r24, 0x66	; 102
     eda:	95 4e       	sbci	r25, 0xE5	; 229
     edc:	25 d9       	rcall	.-3510   	; 0x128 <vListInitialise>
     ede:	cf 5f       	subi	r28, 0xFF	; 255
     ee0:	c5 30       	cpi	r28, 0x05	; 5
     ee2:	b0 f3       	brcs	.-20     	; 0xed0 <prvInitialiseTaskLists+0x6>
     ee4:	8f e8       	ldi	r24, 0x8F	; 143
     ee6:	9a e1       	ldi	r25, 0x1A	; 26
     ee8:	1f d9       	rcall	.-3522   	; 0x128 <vListInitialise>
     eea:	84 e8       	ldi	r24, 0x84	; 132
     eec:	9a e1       	ldi	r25, 0x1A	; 26
     eee:	1c d9       	rcall	.-3528   	; 0x128 <vListInitialise>
     ef0:	85 e7       	ldi	r24, 0x75	; 117
     ef2:	9a e1       	ldi	r25, 0x1A	; 26
     ef4:	19 d9       	rcall	.-3534   	; 0x128 <vListInitialise>
     ef6:	8a e6       	ldi	r24, 0x6A	; 106
     ef8:	9a e1       	ldi	r25, 0x1A	; 26
     efa:	16 d9       	rcall	.-3540   	; 0x128 <vListInitialise>
     efc:	8e e5       	ldi	r24, 0x5E	; 94
     efe:	9a e1       	ldi	r25, 0x1A	; 26
     f00:	13 d9       	rcall	.-3546   	; 0x128 <vListInitialise>
     f02:	8f e8       	ldi	r24, 0x8F	; 143
     f04:	9a e1       	ldi	r25, 0x1A	; 26
     f06:	90 93 83 1a 	sts	0x1A83, r25	; 0x801a83 <pxDelayedTaskList+0x1>
     f0a:	80 93 82 1a 	sts	0x1A82, r24	; 0x801a82 <pxDelayedTaskList>
     f0e:	84 e8       	ldi	r24, 0x84	; 132
     f10:	9a e1       	ldi	r25, 0x1A	; 26
     f12:	90 93 81 1a 	sts	0x1A81, r25	; 0x801a81 <pxOverflowDelayedTaskList+0x1>
     f16:	80 93 80 1a 	sts	0x1A80, r24	; 0x801a80 <pxOverflowDelayedTaskList>
     f1a:	cf 91       	pop	r28
     f1c:	08 95       	ret

00000f1e <prvAddNewTaskToReadyList>:
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	ec 01       	movw	r28, r24
     f24:	0f b6       	in	r0, 0x3f	; 63
     f26:	f8 94       	cli
     f28:	0f 92       	push	r0
     f2a:	80 91 5d 1a 	lds	r24, 0x1A5D	; 0x801a5d <uxCurrentNumberOfTasks>
     f2e:	8f 5f       	subi	r24, 0xFF	; 255
     f30:	80 93 5d 1a 	sts	0x1A5D, r24	; 0x801a5d <uxCurrentNumberOfTasks>
     f34:	80 91 d1 1a 	lds	r24, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
     f38:	90 91 d2 1a 	lds	r25, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     f3c:	89 2b       	or	r24, r25
     f3e:	51 f4       	brne	.+20     	; 0xf54 <prvAddNewTaskToReadyList+0x36>
     f40:	d0 93 d2 1a 	sts	0x1AD2, r29	; 0x801ad2 <pxCurrentTCB+0x1>
     f44:	c0 93 d1 1a 	sts	0x1AD1, r28	; 0x801ad1 <pxCurrentTCB>
     f48:	80 91 5d 1a 	lds	r24, 0x1A5D	; 0x801a5d <uxCurrentNumberOfTasks>
     f4c:	81 30       	cpi	r24, 0x01	; 1
     f4e:	91 f4       	brne	.+36     	; 0xf74 <prvAddNewTaskToReadyList+0x56>
     f50:	bc df       	rcall	.-136    	; 0xeca <prvInitialiseTaskLists>
     f52:	10 c0       	rjmp	.+32     	; 0xf74 <prvAddNewTaskToReadyList+0x56>
     f54:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <xSchedulerRunning>
     f58:	81 11       	cpse	r24, r1
     f5a:	0c c0       	rjmp	.+24     	; 0xf74 <prvAddNewTaskToReadyList+0x56>
     f5c:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
     f60:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     f64:	92 8d       	ldd	r25, Z+26	; 0x1a
     f66:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f68:	89 17       	cp	r24, r25
     f6a:	20 f0       	brcs	.+8      	; 0xf74 <prvAddNewTaskToReadyList+0x56>
     f6c:	d0 93 d2 1a 	sts	0x1AD2, r29	; 0x801ad2 <pxCurrentTCB+0x1>
     f70:	c0 93 d1 1a 	sts	0x1AD1, r28	; 0x801ad1 <pxCurrentTCB>
     f74:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxTaskNumber>
     f78:	8f 5f       	subi	r24, 0xFF	; 255
     f7a:	80 93 53 1a 	sts	0x1A53, r24	; 0x801a53 <uxTaskNumber>
     f7e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f80:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <uxTopReadyPriority>
     f84:	98 17       	cp	r25, r24
     f86:	10 f4       	brcc	.+4      	; 0xf8c <prvAddNewTaskToReadyList+0x6e>
     f88:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <uxTopReadyPriority>
     f8c:	2b e0       	ldi	r18, 0x0B	; 11
     f8e:	82 9f       	mul	r24, r18
     f90:	c0 01       	movw	r24, r0
     f92:	11 24       	eor	r1, r1
     f94:	be 01       	movw	r22, r28
     f96:	6e 5f       	subi	r22, 0xFE	; 254
     f98:	7f 4f       	sbci	r23, 0xFF	; 255
     f9a:	86 56       	subi	r24, 0x66	; 102
     f9c:	95 4e       	sbci	r25, 0xE5	; 229
     f9e:	d9 d8       	rcall	.-3662   	; 0x152 <vListInsertEnd>
     fa0:	0f 90       	pop	r0
     fa2:	0f be       	out	0x3f, r0	; 63
     fa4:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <xSchedulerRunning>
     fa8:	88 23       	and	r24, r24
     faa:	49 f0       	breq	.+18     	; 0xfbe <prvAddNewTaskToReadyList+0xa0>
     fac:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
     fb0:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     fb4:	92 8d       	ldd	r25, Z+26	; 0x1a
     fb6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fb8:	98 17       	cp	r25, r24
     fba:	08 f4       	brcc	.+2      	; 0xfbe <prvAddNewTaskToReadyList+0xa0>
     fbc:	47 db       	rcall	.-2418   	; 0x64c <vPortYield>
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	08 95       	ret

00000fc4 <prvAddCurrentTaskToDelayedList>:
     fc4:	8f 92       	push	r8
     fc6:	9f 92       	push	r9
     fc8:	af 92       	push	r10
     fca:	bf 92       	push	r11
     fcc:	cf 92       	push	r12
     fce:	df 92       	push	r13
     fd0:	ef 92       	push	r14
     fd2:	ff 92       	push	r15
     fd4:	cf 93       	push	r28
     fd6:	6b 01       	movw	r12, r22
     fd8:	7c 01       	movw	r14, r24
     fda:	c4 2f       	mov	r28, r20
     fdc:	80 90 59 1a 	lds	r8, 0x1A59	; 0x801a59 <xTickCount>
     fe0:	90 90 5a 1a 	lds	r9, 0x1A5A	; 0x801a5a <xTickCount+0x1>
     fe4:	a0 90 5b 1a 	lds	r10, 0x1A5B	; 0x801a5b <xTickCount+0x2>
     fe8:	b0 90 5c 1a 	lds	r11, 0x1A5C	; 0x801a5c <xTickCount+0x3>
     fec:	80 91 d1 1a 	lds	r24, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
     ff0:	90 91 d2 1a 	lds	r25, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
     ff4:	02 96       	adiw	r24, 0x02	; 2
     ff6:	0b d9       	rcall	.-3562   	; 0x20e <uxListRemove>
     ff8:	8f ef       	ldi	r24, 0xFF	; 255
     ffa:	c8 16       	cp	r12, r24
     ffc:	d8 06       	cpc	r13, r24
     ffe:	e8 06       	cpc	r14, r24
    1000:	f8 06       	cpc	r15, r24
    1002:	61 f4       	brne	.+24     	; 0x101c <__EEPROM_REGION_LENGTH__+0x1c>
    1004:	cc 23       	and	r28, r28
    1006:	51 f0       	breq	.+20     	; 0x101c <__EEPROM_REGION_LENGTH__+0x1c>
    1008:	60 91 d1 1a 	lds	r22, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    100c:	70 91 d2 1a 	lds	r23, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    1010:	6e 5f       	subi	r22, 0xFE	; 254
    1012:	7f 4f       	sbci	r23, 0xFF	; 255
    1014:	8e e5       	ldi	r24, 0x5E	; 94
    1016:	9a e1       	ldi	r25, 0x1A	; 26
    1018:	9c d8       	rcall	.-3784   	; 0x152 <vListInsertEnd>
    101a:	3d c0       	rjmp	.+122    	; 0x1096 <__EEPROM_REGION_LENGTH__+0x96>
    101c:	c8 0c       	add	r12, r8
    101e:	d9 1c       	adc	r13, r9
    1020:	ea 1c       	adc	r14, r10
    1022:	fb 1c       	adc	r15, r11
    1024:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    1028:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    102c:	c2 82       	std	Z+2, r12	; 0x02
    102e:	d3 82       	std	Z+3, r13	; 0x03
    1030:	e4 82       	std	Z+4, r14	; 0x04
    1032:	f5 82       	std	Z+5, r15	; 0x05
    1034:	c8 14       	cp	r12, r8
    1036:	d9 04       	cpc	r13, r9
    1038:	ea 04       	cpc	r14, r10
    103a:	fb 04       	cpc	r15, r11
    103c:	60 f4       	brcc	.+24     	; 0x1056 <__EEPROM_REGION_LENGTH__+0x56>
    103e:	60 91 d1 1a 	lds	r22, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    1042:	70 91 d2 1a 	lds	r23, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    1046:	80 91 80 1a 	lds	r24, 0x1A80	; 0x801a80 <pxOverflowDelayedTaskList>
    104a:	90 91 81 1a 	lds	r25, 0x1A81	; 0x801a81 <pxOverflowDelayedTaskList+0x1>
    104e:	6e 5f       	subi	r22, 0xFE	; 254
    1050:	7f 4f       	sbci	r23, 0xFF	; 255
    1052:	a0 d8       	rcall	.-3776   	; 0x194 <vListInsert>
    1054:	20 c0       	rjmp	.+64     	; 0x1096 <__EEPROM_REGION_LENGTH__+0x96>
    1056:	60 91 d1 1a 	lds	r22, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    105a:	70 91 d2 1a 	lds	r23, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    105e:	80 91 82 1a 	lds	r24, 0x1A82	; 0x801a82 <pxDelayedTaskList>
    1062:	90 91 83 1a 	lds	r25, 0x1A83	; 0x801a83 <pxDelayedTaskList+0x1>
    1066:	6e 5f       	subi	r22, 0xFE	; 254
    1068:	7f 4f       	sbci	r23, 0xFF	; 255
    106a:	94 d8       	rcall	.-3800   	; 0x194 <vListInsert>
    106c:	80 91 4f 1a 	lds	r24, 0x1A4F	; 0x801a4f <xNextTaskUnblockTime>
    1070:	90 91 50 1a 	lds	r25, 0x1A50	; 0x801a50 <xNextTaskUnblockTime+0x1>
    1074:	a0 91 51 1a 	lds	r26, 0x1A51	; 0x801a51 <xNextTaskUnblockTime+0x2>
    1078:	b0 91 52 1a 	lds	r27, 0x1A52	; 0x801a52 <xNextTaskUnblockTime+0x3>
    107c:	c8 16       	cp	r12, r24
    107e:	d9 06       	cpc	r13, r25
    1080:	ea 06       	cpc	r14, r26
    1082:	fb 06       	cpc	r15, r27
    1084:	40 f4       	brcc	.+16     	; 0x1096 <__EEPROM_REGION_LENGTH__+0x96>
    1086:	c0 92 4f 1a 	sts	0x1A4F, r12	; 0x801a4f <xNextTaskUnblockTime>
    108a:	d0 92 50 1a 	sts	0x1A50, r13	; 0x801a50 <xNextTaskUnblockTime+0x1>
    108e:	e0 92 51 1a 	sts	0x1A51, r14	; 0x801a51 <xNextTaskUnblockTime+0x2>
    1092:	f0 92 52 1a 	sts	0x1A52, r15	; 0x801a52 <xNextTaskUnblockTime+0x3>
    1096:	cf 91       	pop	r28
    1098:	ff 90       	pop	r15
    109a:	ef 90       	pop	r14
    109c:	df 90       	pop	r13
    109e:	cf 90       	pop	r12
    10a0:	bf 90       	pop	r11
    10a2:	af 90       	pop	r10
    10a4:	9f 90       	pop	r9
    10a6:	8f 90       	pop	r8
    10a8:	08 95       	ret

000010aa <xTaskCreate>:
    10aa:	2f 92       	push	r2
    10ac:	3f 92       	push	r3
    10ae:	4f 92       	push	r4
    10b0:	5f 92       	push	r5
    10b2:	6f 92       	push	r6
    10b4:	7f 92       	push	r7
    10b6:	8f 92       	push	r8
    10b8:	9f 92       	push	r9
    10ba:	af 92       	push	r10
    10bc:	bf 92       	push	r11
    10be:	cf 92       	push	r12
    10c0:	df 92       	push	r13
    10c2:	ef 92       	push	r14
    10c4:	ff 92       	push	r15
    10c6:	0f 93       	push	r16
    10c8:	1f 93       	push	r17
    10ca:	cf 93       	push	r28
    10cc:	df 93       	push	r29
    10ce:	3c 01       	movw	r6, r24
    10d0:	1b 01       	movw	r2, r22
    10d2:	5a 01       	movw	r10, r20
    10d4:	29 01       	movw	r4, r18
    10d6:	ca 01       	movw	r24, r20
    10d8:	41 d9       	rcall	.-3454   	; 0x35c <pvPortMalloc>
    10da:	6c 01       	movw	r12, r24
    10dc:	89 2b       	or	r24, r25
    10de:	61 f0       	breq	.+24     	; 0x10f8 <xTaskCreate+0x4e>
    10e0:	88 e3       	ldi	r24, 0x38	; 56
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	3b d9       	rcall	.-3466   	; 0x35c <pvPortMalloc>
    10e6:	ec 01       	movw	r28, r24
    10e8:	89 2b       	or	r24, r25
    10ea:	19 f0       	breq	.+6      	; 0x10f2 <xTaskCreate+0x48>
    10ec:	dc 8e       	std	Y+28, r13	; 0x1c
    10ee:	cb 8e       	std	Y+27, r12	; 0x1b
    10f0:	05 c0       	rjmp	.+10     	; 0x10fc <xTaskCreate+0x52>
    10f2:	c6 01       	movw	r24, r12
    10f4:	c5 d9       	rcall	.-3190   	; 0x480 <vPortFree>
    10f6:	02 c0       	rjmp	.+4      	; 0x10fc <xTaskCreate+0x52>
    10f8:	c0 e0       	ldi	r28, 0x00	; 0
    10fa:	d0 e0       	ldi	r29, 0x00	; 0
    10fc:	20 97       	sbiw	r28, 0x00	; 0
    10fe:	81 f0       	breq	.+32     	; 0x1120 <xTaskCreate+0x76>
    1100:	95 01       	movw	r18, r10
    1102:	40 e0       	ldi	r20, 0x00	; 0
    1104:	50 e0       	ldi	r21, 0x00	; 0
    1106:	81 2c       	mov	r8, r1
    1108:	91 2c       	mov	r9, r1
    110a:	5e 01       	movw	r10, r28
    110c:	67 01       	movw	r12, r14
    110e:	e0 2e       	mov	r14, r16
    1110:	82 01       	movw	r16, r4
    1112:	b1 01       	movw	r22, r2
    1114:	c3 01       	movw	r24, r6
    1116:	6b de       	rcall	.-810    	; 0xdee <prvInitialiseNewTask>
    1118:	ce 01       	movw	r24, r28
    111a:	01 df       	rcall	.-510    	; 0xf1e <prvAddNewTaskToReadyList>
    111c:	81 e0       	ldi	r24, 0x01	; 1
    111e:	01 c0       	rjmp	.+2      	; 0x1122 <xTaskCreate+0x78>
    1120:	8f ef       	ldi	r24, 0xFF	; 255
    1122:	df 91       	pop	r29
    1124:	cf 91       	pop	r28
    1126:	1f 91       	pop	r17
    1128:	0f 91       	pop	r16
    112a:	ff 90       	pop	r15
    112c:	ef 90       	pop	r14
    112e:	df 90       	pop	r13
    1130:	cf 90       	pop	r12
    1132:	bf 90       	pop	r11
    1134:	af 90       	pop	r10
    1136:	9f 90       	pop	r9
    1138:	8f 90       	pop	r8
    113a:	7f 90       	pop	r7
    113c:	6f 90       	pop	r6
    113e:	5f 90       	pop	r5
    1140:	4f 90       	pop	r4
    1142:	3f 90       	pop	r3
    1144:	2f 90       	pop	r2
    1146:	08 95       	ret

00001148 <vTaskStartScheduler>:
    1148:	ef 92       	push	r14
    114a:	ff 92       	push	r15
    114c:	0f 93       	push	r16
    114e:	0f 2e       	mov	r0, r31
    1150:	fd e4       	ldi	r31, 0x4D	; 77
    1152:	ef 2e       	mov	r14, r31
    1154:	fa e1       	ldi	r31, 0x1A	; 26
    1156:	ff 2e       	mov	r15, r31
    1158:	f0 2d       	mov	r31, r0
    115a:	00 e0       	ldi	r16, 0x00	; 0
    115c:	20 e0       	ldi	r18, 0x00	; 0
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	40 e0       	ldi	r20, 0x00	; 0
    1162:	54 e0       	ldi	r21, 0x04	; 4
    1164:	62 e0       	ldi	r22, 0x02	; 2
    1166:	72 e0       	ldi	r23, 0x02	; 2
    1168:	88 e5       	ldi	r24, 0x58	; 88
    116a:	9a e0       	ldi	r25, 0x0A	; 10
    116c:	9e df       	rcall	.-196    	; 0x10aa <xTaskCreate>
    116e:	81 30       	cpi	r24, 0x01	; 1
    1170:	c1 f4       	brne	.+48     	; 0x11a2 <vTaskStartScheduler+0x5a>
    1172:	f8 94       	cli
    1174:	8f ef       	ldi	r24, 0xFF	; 255
    1176:	9f ef       	ldi	r25, 0xFF	; 255
    1178:	dc 01       	movw	r26, r24
    117a:	80 93 4f 1a 	sts	0x1A4F, r24	; 0x801a4f <xNextTaskUnblockTime>
    117e:	90 93 50 1a 	sts	0x1A50, r25	; 0x801a50 <xNextTaskUnblockTime+0x1>
    1182:	a0 93 51 1a 	sts	0x1A51, r26	; 0x801a51 <xNextTaskUnblockTime+0x2>
    1186:	b0 93 52 1a 	sts	0x1A52, r27	; 0x801a52 <xNextTaskUnblockTime+0x3>
    118a:	81 e0       	ldi	r24, 0x01	; 1
    118c:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <xSchedulerRunning>
    1190:	10 92 59 1a 	sts	0x1A59, r1	; 0x801a59 <xTickCount>
    1194:	10 92 5a 1a 	sts	0x1A5A, r1	; 0x801a5a <xTickCount+0x1>
    1198:	10 92 5b 1a 	sts	0x1A5B, r1	; 0x801a5b <xTickCount+0x2>
    119c:	10 92 5c 1a 	sts	0x1A5C, r1	; 0x801a5c <xTickCount+0x3>
    11a0:	23 da       	rcall	.-3002   	; 0x5e8 <xPortStartScheduler>
    11a2:	0f 91       	pop	r16
    11a4:	ff 90       	pop	r15
    11a6:	ef 90       	pop	r14
    11a8:	08 95       	ret

000011aa <vTaskSuspendAll>:
    11aa:	80 91 4c 1a 	lds	r24, 0x1A4C	; 0x801a4c <uxSchedulerSuspended>
    11ae:	8f 5f       	subi	r24, 0xFF	; 255
    11b0:	80 93 4c 1a 	sts	0x1A4C, r24	; 0x801a4c <uxSchedulerSuspended>
    11b4:	08 95       	ret

000011b6 <xTaskIncrementTick>:
    11b6:	bf 92       	push	r11
    11b8:	cf 92       	push	r12
    11ba:	df 92       	push	r13
    11bc:	ef 92       	push	r14
    11be:	ff 92       	push	r15
    11c0:	0f 93       	push	r16
    11c2:	1f 93       	push	r17
    11c4:	cf 93       	push	r28
    11c6:	df 93       	push	r29
    11c8:	80 91 4c 1a 	lds	r24, 0x1A4C	; 0x801a4c <uxSchedulerSuspended>
    11cc:	81 11       	cpse	r24, r1
    11ce:	a8 c0       	rjmp	.+336    	; 0x1320 <xTaskIncrementTick+0x16a>
    11d0:	c0 90 59 1a 	lds	r12, 0x1A59	; 0x801a59 <xTickCount>
    11d4:	d0 90 5a 1a 	lds	r13, 0x1A5A	; 0x801a5a <xTickCount+0x1>
    11d8:	e0 90 5b 1a 	lds	r14, 0x1A5B	; 0x801a5b <xTickCount+0x2>
    11dc:	f0 90 5c 1a 	lds	r15, 0x1A5C	; 0x801a5c <xTickCount+0x3>
    11e0:	2f ef       	ldi	r18, 0xFF	; 255
    11e2:	c2 1a       	sub	r12, r18
    11e4:	d2 0a       	sbc	r13, r18
    11e6:	e2 0a       	sbc	r14, r18
    11e8:	f2 0a       	sbc	r15, r18
    11ea:	c0 92 59 1a 	sts	0x1A59, r12	; 0x801a59 <xTickCount>
    11ee:	d0 92 5a 1a 	sts	0x1A5A, r13	; 0x801a5a <xTickCount+0x1>
    11f2:	e0 92 5b 1a 	sts	0x1A5B, r14	; 0x801a5b <xTickCount+0x2>
    11f6:	f0 92 5c 1a 	sts	0x1A5C, r15	; 0x801a5c <xTickCount+0x3>
    11fa:	c1 14       	cp	r12, r1
    11fc:	d1 04       	cpc	r13, r1
    11fe:	e1 04       	cpc	r14, r1
    1200:	f1 04       	cpc	r15, r1
    1202:	b1 f4       	brne	.+44     	; 0x1230 <xTaskIncrementTick+0x7a>
    1204:	80 91 82 1a 	lds	r24, 0x1A82	; 0x801a82 <pxDelayedTaskList>
    1208:	90 91 83 1a 	lds	r25, 0x1A83	; 0x801a83 <pxDelayedTaskList+0x1>
    120c:	20 91 80 1a 	lds	r18, 0x1A80	; 0x801a80 <pxOverflowDelayedTaskList>
    1210:	30 91 81 1a 	lds	r19, 0x1A81	; 0x801a81 <pxOverflowDelayedTaskList+0x1>
    1214:	30 93 83 1a 	sts	0x1A83, r19	; 0x801a83 <pxDelayedTaskList+0x1>
    1218:	20 93 82 1a 	sts	0x1A82, r18	; 0x801a82 <pxDelayedTaskList>
    121c:	90 93 81 1a 	sts	0x1A81, r25	; 0x801a81 <pxOverflowDelayedTaskList+0x1>
    1220:	80 93 80 1a 	sts	0x1A80, r24	; 0x801a80 <pxOverflowDelayedTaskList>
    1224:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNumOfOverflows>
    1228:	8f 5f       	subi	r24, 0xFF	; 255
    122a:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNumOfOverflows>
    122e:	aa dd       	rcall	.-1196   	; 0xd84 <prvResetNextTaskUnblockTime>
    1230:	80 91 4f 1a 	lds	r24, 0x1A4F	; 0x801a4f <xNextTaskUnblockTime>
    1234:	90 91 50 1a 	lds	r25, 0x1A50	; 0x801a50 <xNextTaskUnblockTime+0x1>
    1238:	a0 91 51 1a 	lds	r26, 0x1A51	; 0x801a51 <xNextTaskUnblockTime+0x2>
    123c:	b0 91 52 1a 	lds	r27, 0x1A52	; 0x801a52 <xNextTaskUnblockTime+0x3>
    1240:	c8 16       	cp	r12, r24
    1242:	d9 06       	cpc	r13, r25
    1244:	ea 06       	cpc	r14, r26
    1246:	fb 06       	cpc	r15, r27
    1248:	28 f4       	brcc	.+10     	; 0x1254 <xTaskIncrementTick+0x9e>
    124a:	b1 2c       	mov	r11, r1
    124c:	5a c0       	rjmp	.+180    	; 0x1302 <xTaskIncrementTick+0x14c>
    124e:	bb 24       	eor	r11, r11
    1250:	b3 94       	inc	r11
    1252:	01 c0       	rjmp	.+2      	; 0x1256 <xTaskIncrementTick+0xa0>
    1254:	b1 2c       	mov	r11, r1
    1256:	e0 91 82 1a 	lds	r30, 0x1A82	; 0x801a82 <pxDelayedTaskList>
    125a:	f0 91 83 1a 	lds	r31, 0x1A83	; 0x801a83 <pxDelayedTaskList+0x1>
    125e:	80 81       	ld	r24, Z
    1260:	81 11       	cpse	r24, r1
    1262:	0c c0       	rjmp	.+24     	; 0x127c <xTaskIncrementTick+0xc6>
    1264:	8f ef       	ldi	r24, 0xFF	; 255
    1266:	9f ef       	ldi	r25, 0xFF	; 255
    1268:	dc 01       	movw	r26, r24
    126a:	80 93 4f 1a 	sts	0x1A4F, r24	; 0x801a4f <xNextTaskUnblockTime>
    126e:	90 93 50 1a 	sts	0x1A50, r25	; 0x801a50 <xNextTaskUnblockTime+0x1>
    1272:	a0 93 51 1a 	sts	0x1A51, r26	; 0x801a51 <xNextTaskUnblockTime+0x2>
    1276:	b0 93 52 1a 	sts	0x1A52, r27	; 0x801a52 <xNextTaskUnblockTime+0x3>
    127a:	43 c0       	rjmp	.+134    	; 0x1302 <xTaskIncrementTick+0x14c>
    127c:	e0 91 82 1a 	lds	r30, 0x1A82	; 0x801a82 <pxDelayedTaskList>
    1280:	f0 91 83 1a 	lds	r31, 0x1A83	; 0x801a83 <pxDelayedTaskList+0x1>
    1284:	07 80       	ldd	r0, Z+7	; 0x07
    1286:	f0 85       	ldd	r31, Z+8	; 0x08
    1288:	e0 2d       	mov	r30, r0
    128a:	c0 85       	ldd	r28, Z+8	; 0x08
    128c:	d1 85       	ldd	r29, Z+9	; 0x09
    128e:	8a 81       	ldd	r24, Y+2	; 0x02
    1290:	9b 81       	ldd	r25, Y+3	; 0x03
    1292:	ac 81       	ldd	r26, Y+4	; 0x04
    1294:	bd 81       	ldd	r27, Y+5	; 0x05
    1296:	c8 16       	cp	r12, r24
    1298:	d9 06       	cpc	r13, r25
    129a:	ea 06       	cpc	r14, r26
    129c:	fb 06       	cpc	r15, r27
    129e:	48 f4       	brcc	.+18     	; 0x12b2 <xTaskIncrementTick+0xfc>
    12a0:	80 93 4f 1a 	sts	0x1A4F, r24	; 0x801a4f <xNextTaskUnblockTime>
    12a4:	90 93 50 1a 	sts	0x1A50, r25	; 0x801a50 <xNextTaskUnblockTime+0x1>
    12a8:	a0 93 51 1a 	sts	0x1A51, r26	; 0x801a51 <xNextTaskUnblockTime+0x2>
    12ac:	b0 93 52 1a 	sts	0x1A52, r27	; 0x801a52 <xNextTaskUnblockTime+0x3>
    12b0:	28 c0       	rjmp	.+80     	; 0x1302 <xTaskIncrementTick+0x14c>
    12b2:	8e 01       	movw	r16, r28
    12b4:	0e 5f       	subi	r16, 0xFE	; 254
    12b6:	1f 4f       	sbci	r17, 0xFF	; 255
    12b8:	c8 01       	movw	r24, r16
    12ba:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    12be:	88 8d       	ldd	r24, Y+24	; 0x18
    12c0:	99 8d       	ldd	r25, Y+25	; 0x19
    12c2:	89 2b       	or	r24, r25
    12c4:	21 f0       	breq	.+8      	; 0x12ce <xTaskIncrementTick+0x118>
    12c6:	ce 01       	movw	r24, r28
    12c8:	0e 96       	adiw	r24, 0x0e	; 14
    12ca:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    12ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12d0:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <uxTopReadyPriority>
    12d4:	98 17       	cp	r25, r24
    12d6:	10 f4       	brcc	.+4      	; 0x12dc <xTaskIncrementTick+0x126>
    12d8:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <uxTopReadyPriority>
    12dc:	2b e0       	ldi	r18, 0x0B	; 11
    12de:	82 9f       	mul	r24, r18
    12e0:	c0 01       	movw	r24, r0
    12e2:	11 24       	eor	r1, r1
    12e4:	b8 01       	movw	r22, r16
    12e6:	86 56       	subi	r24, 0x66	; 102
    12e8:	95 4e       	sbci	r25, 0xE5	; 229
    12ea:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsertEnd>
    12ee:	9a 8d       	ldd	r25, Y+26	; 0x1a
    12f0:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    12f4:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    12f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    12fa:	98 17       	cp	r25, r24
    12fc:	08 f0       	brcs	.+2      	; 0x1300 <xTaskIncrementTick+0x14a>
    12fe:	a7 cf       	rjmp	.-178    	; 0x124e <xTaskIncrementTick+0x98>
    1300:	aa cf       	rjmp	.-172    	; 0x1256 <xTaskIncrementTick+0xa0>
    1302:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    1306:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    130a:	e2 8d       	ldd	r30, Z+26	; 0x1a
    130c:	8b e0       	ldi	r24, 0x0B	; 11
    130e:	e8 9f       	mul	r30, r24
    1310:	f0 01       	movw	r30, r0
    1312:	11 24       	eor	r1, r1
    1314:	e6 56       	subi	r30, 0x66	; 102
    1316:	f5 4e       	sbci	r31, 0xE5	; 229
    1318:	80 81       	ld	r24, Z
    131a:	82 30       	cpi	r24, 0x02	; 2
    131c:	40 f4       	brcc	.+16     	; 0x132e <xTaskIncrementTick+0x178>
    131e:	09 c0       	rjmp	.+18     	; 0x1332 <xTaskIncrementTick+0x17c>
    1320:	80 91 56 1a 	lds	r24, 0x1A56	; 0x801a56 <uxPendedTicks>
    1324:	8f 5f       	subi	r24, 0xFF	; 255
    1326:	80 93 56 1a 	sts	0x1A56, r24	; 0x801a56 <uxPendedTicks>
    132a:	b1 2c       	mov	r11, r1
    132c:	02 c0       	rjmp	.+4      	; 0x1332 <xTaskIncrementTick+0x17c>
    132e:	bb 24       	eor	r11, r11
    1330:	b3 94       	inc	r11
    1332:	80 91 55 1a 	lds	r24, 0x1A55	; 0x801a55 <xYieldPending>
    1336:	88 23       	and	r24, r24
    1338:	11 f0       	breq	.+4      	; 0x133e <xTaskIncrementTick+0x188>
    133a:	bb 24       	eor	r11, r11
    133c:	b3 94       	inc	r11
    133e:	8b 2d       	mov	r24, r11
    1340:	df 91       	pop	r29
    1342:	cf 91       	pop	r28
    1344:	1f 91       	pop	r17
    1346:	0f 91       	pop	r16
    1348:	ff 90       	pop	r15
    134a:	ef 90       	pop	r14
    134c:	df 90       	pop	r13
    134e:	cf 90       	pop	r12
    1350:	bf 90       	pop	r11
    1352:	08 95       	ret

00001354 <xTaskResumeAll>:
    1354:	0f 93       	push	r16
    1356:	1f 93       	push	r17
    1358:	cf 93       	push	r28
    135a:	df 93       	push	r29
    135c:	0f b6       	in	r0, 0x3f	; 63
    135e:	f8 94       	cli
    1360:	0f 92       	push	r0
    1362:	80 91 4c 1a 	lds	r24, 0x1A4C	; 0x801a4c <uxSchedulerSuspended>
    1366:	81 50       	subi	r24, 0x01	; 1
    1368:	80 93 4c 1a 	sts	0x1A4C, r24	; 0x801a4c <uxSchedulerSuspended>
    136c:	80 91 4c 1a 	lds	r24, 0x1A4C	; 0x801a4c <uxSchedulerSuspended>
    1370:	81 11       	cpse	r24, r1
    1372:	4f c0       	rjmp	.+158    	; 0x1412 <xTaskResumeAll+0xbe>
    1374:	80 91 5d 1a 	lds	r24, 0x1A5D	; 0x801a5d <uxCurrentNumberOfTasks>
    1378:	81 11       	cpse	r24, r1
    137a:	2d c0       	rjmp	.+90     	; 0x13d6 <xTaskResumeAll+0x82>
    137c:	4d c0       	rjmp	.+154    	; 0x1418 <xTaskResumeAll+0xc4>
    137e:	e0 91 7c 1a 	lds	r30, 0x1A7C	; 0x801a7c <xPendingReadyList+0x7>
    1382:	f0 91 7d 1a 	lds	r31, 0x1A7D	; 0x801a7d <xPendingReadyList+0x8>
    1386:	c0 85       	ldd	r28, Z+8	; 0x08
    1388:	d1 85       	ldd	r29, Z+9	; 0x09
    138a:	ce 01       	movw	r24, r28
    138c:	0e 96       	adiw	r24, 0x0e	; 14
    138e:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    1392:	8e 01       	movw	r16, r28
    1394:	0e 5f       	subi	r16, 0xFE	; 254
    1396:	1f 4f       	sbci	r17, 0xFF	; 255
    1398:	c8 01       	movw	r24, r16
    139a:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    139e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13a0:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <uxTopReadyPriority>
    13a4:	98 17       	cp	r25, r24
    13a6:	10 f4       	brcc	.+4      	; 0x13ac <xTaskResumeAll+0x58>
    13a8:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <uxTopReadyPriority>
    13ac:	2b e0       	ldi	r18, 0x0B	; 11
    13ae:	82 9f       	mul	r24, r18
    13b0:	c0 01       	movw	r24, r0
    13b2:	11 24       	eor	r1, r1
    13b4:	b8 01       	movw	r22, r16
    13b6:	86 56       	subi	r24, 0x66	; 102
    13b8:	95 4e       	sbci	r25, 0xE5	; 229
    13ba:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsertEnd>
    13be:	9a 8d       	ldd	r25, Y+26	; 0x1a
    13c0:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    13c4:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    13c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    13ca:	98 17       	cp	r25, r24
    13cc:	30 f0       	brcs	.+12     	; 0x13da <xTaskResumeAll+0x86>
    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	80 93 55 1a 	sts	0x1A55, r24	; 0x801a55 <xYieldPending>
    13d4:	02 c0       	rjmp	.+4      	; 0x13da <xTaskResumeAll+0x86>
    13d6:	c0 e0       	ldi	r28, 0x00	; 0
    13d8:	d0 e0       	ldi	r29, 0x00	; 0
    13da:	80 91 75 1a 	lds	r24, 0x1A75	; 0x801a75 <xPendingReadyList>
    13de:	81 11       	cpse	r24, r1
    13e0:	ce cf       	rjmp	.-100    	; 0x137e <xTaskResumeAll+0x2a>
    13e2:	cd 2b       	or	r28, r29
    13e4:	09 f0       	breq	.+2      	; 0x13e8 <xTaskResumeAll+0x94>
    13e6:	ce dc       	rcall	.-1636   	; 0xd84 <prvResetNextTaskUnblockTime>
    13e8:	c0 91 56 1a 	lds	r28, 0x1A56	; 0x801a56 <uxPendedTicks>
    13ec:	cc 23       	and	r28, r28
    13ee:	51 f0       	breq	.+20     	; 0x1404 <xTaskResumeAll+0xb0>
    13f0:	e2 de       	rcall	.-572    	; 0x11b6 <xTaskIncrementTick>
    13f2:	88 23       	and	r24, r24
    13f4:	19 f0       	breq	.+6      	; 0x13fc <xTaskResumeAll+0xa8>
    13f6:	81 e0       	ldi	r24, 0x01	; 1
    13f8:	80 93 55 1a 	sts	0x1A55, r24	; 0x801a55 <xYieldPending>
    13fc:	c1 50       	subi	r28, 0x01	; 1
    13fe:	c1 f7       	brne	.-16     	; 0x13f0 <xTaskResumeAll+0x9c>
    1400:	10 92 56 1a 	sts	0x1A56, r1	; 0x801a56 <uxPendedTicks>
    1404:	80 91 55 1a 	lds	r24, 0x1A55	; 0x801a55 <xYieldPending>
    1408:	88 23       	and	r24, r24
    140a:	29 f0       	breq	.+10     	; 0x1416 <xTaskResumeAll+0xc2>
    140c:	1f d9       	rcall	.-3522   	; 0x64c <vPortYield>
    140e:	81 e0       	ldi	r24, 0x01	; 1
    1410:	03 c0       	rjmp	.+6      	; 0x1418 <xTaskResumeAll+0xc4>
    1412:	80 e0       	ldi	r24, 0x00	; 0
    1414:	01 c0       	rjmp	.+2      	; 0x1418 <xTaskResumeAll+0xc4>
    1416:	80 e0       	ldi	r24, 0x00	; 0
    1418:	0f 90       	pop	r0
    141a:	0f be       	out	0x3f, r0	; 63
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	08 95       	ret

00001426 <vTaskDelay>:
    1426:	cf 92       	push	r12
    1428:	df 92       	push	r13
    142a:	ef 92       	push	r14
    142c:	ff 92       	push	r15
    142e:	6b 01       	movw	r12, r22
    1430:	7c 01       	movw	r14, r24
    1432:	67 2b       	or	r22, r23
    1434:	68 2b       	or	r22, r24
    1436:	69 2b       	or	r22, r25
    1438:	39 f0       	breq	.+14     	; 0x1448 <vTaskDelay+0x22>
    143a:	b7 de       	rcall	.-658    	; 0x11aa <vTaskSuspendAll>
    143c:	40 e0       	ldi	r20, 0x00	; 0
    143e:	c7 01       	movw	r24, r14
    1440:	b6 01       	movw	r22, r12
    1442:	c0 dd       	rcall	.-1152   	; 0xfc4 <prvAddCurrentTaskToDelayedList>
    1444:	87 df       	rcall	.-242    	; 0x1354 <xTaskResumeAll>
    1446:	01 c0       	rjmp	.+2      	; 0x144a <vTaskDelay+0x24>
    1448:	80 e0       	ldi	r24, 0x00	; 0
    144a:	81 11       	cpse	r24, r1
    144c:	01 c0       	rjmp	.+2      	; 0x1450 <vTaskDelay+0x2a>
    144e:	fe d8       	rcall	.-3588   	; 0x64c <vPortYield>
    1450:	ff 90       	pop	r15
    1452:	ef 90       	pop	r14
    1454:	df 90       	pop	r13
    1456:	cf 90       	pop	r12
    1458:	08 95       	ret

0000145a <prvCheckTasksWaitingTermination>:
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
    145e:	21 c0       	rjmp	.+66     	; 0x14a2 <prvCheckTasksWaitingTermination+0x48>
    1460:	a4 de       	rcall	.-696    	; 0x11aa <vTaskSuspendAll>
    1462:	c0 91 6a 1a 	lds	r28, 0x1A6A	; 0x801a6a <xTasksWaitingTermination>
    1466:	76 df       	rcall	.-276    	; 0x1354 <xTaskResumeAll>
    1468:	cc 23       	and	r28, r28
    146a:	d9 f0       	breq	.+54     	; 0x14a2 <prvCheckTasksWaitingTermination+0x48>
    146c:	0f b6       	in	r0, 0x3f	; 63
    146e:	f8 94       	cli
    1470:	0f 92       	push	r0
    1472:	e0 91 71 1a 	lds	r30, 0x1A71	; 0x801a71 <xTasksWaitingTermination+0x7>
    1476:	f0 91 72 1a 	lds	r31, 0x1A72	; 0x801a72 <xTasksWaitingTermination+0x8>
    147a:	c0 85       	ldd	r28, Z+8	; 0x08
    147c:	d1 85       	ldd	r29, Z+9	; 0x09
    147e:	ce 01       	movw	r24, r28
    1480:	02 96       	adiw	r24, 0x02	; 2
    1482:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    1486:	80 91 5d 1a 	lds	r24, 0x1A5D	; 0x801a5d <uxCurrentNumberOfTasks>
    148a:	81 50       	subi	r24, 0x01	; 1
    148c:	80 93 5d 1a 	sts	0x1A5D, r24	; 0x801a5d <uxCurrentNumberOfTasks>
    1490:	80 91 69 1a 	lds	r24, 0x1A69	; 0x801a69 <uxDeletedTasksWaitingCleanUp>
    1494:	81 50       	subi	r24, 0x01	; 1
    1496:	80 93 69 1a 	sts	0x1A69, r24	; 0x801a69 <uxDeletedTasksWaitingCleanUp>
    149a:	0f 90       	pop	r0
    149c:	0f be       	out	0x3f, r0	; 63
    149e:	ce 01       	movw	r24, r28
    14a0:	9b dc       	rcall	.-1738   	; 0xdd8 <prvDeleteTCB>
    14a2:	80 91 69 1a 	lds	r24, 0x1A69	; 0x801a69 <uxDeletedTasksWaitingCleanUp>
    14a6:	81 11       	cpse	r24, r1
    14a8:	db cf       	rjmp	.-74     	; 0x1460 <prvCheckTasksWaitingTermination+0x6>
    14aa:	df 91       	pop	r29
    14ac:	cf 91       	pop	r28
    14ae:	08 95       	ret

000014b0 <prvIdleTask>:
    14b0:	d4 df       	rcall	.-88     	; 0x145a <prvCheckTasksWaitingTermination>
    14b2:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <pxReadyTasksLists>
    14b6:	82 30       	cpi	r24, 0x02	; 2
    14b8:	d8 f3       	brcs	.-10     	; 0x14b0 <prvIdleTask>
    14ba:	c8 d8       	rcall	.-3696   	; 0x64c <vPortYield>
    14bc:	f9 cf       	rjmp	.-14     	; 0x14b0 <prvIdleTask>

000014be <vTaskSwitchContext>:
    14be:	80 91 4c 1a 	lds	r24, 0x1A4C	; 0x801a4c <uxSchedulerSuspended>
    14c2:	88 23       	and	r24, r24
    14c4:	21 f0       	breq	.+8      	; 0x14ce <vTaskSwitchContext+0x10>
    14c6:	81 e0       	ldi	r24, 0x01	; 1
    14c8:	80 93 55 1a 	sts	0x1A55, r24	; 0x801a55 <xYieldPending>
    14cc:	08 95       	ret
    14ce:	10 92 55 1a 	sts	0x1A55, r1	; 0x801a55 <xYieldPending>
    14d2:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <uxTopReadyPriority>
    14d6:	01 c0       	rjmp	.+2      	; 0x14da <vTaskSwitchContext+0x1c>
    14d8:	81 50       	subi	r24, 0x01	; 1
    14da:	28 2f       	mov	r18, r24
    14dc:	30 e0       	ldi	r19, 0x00	; 0
    14de:	9b e0       	ldi	r25, 0x0B	; 11
    14e0:	92 9f       	mul	r25, r18
    14e2:	f0 01       	movw	r30, r0
    14e4:	93 9f       	mul	r25, r19
    14e6:	f0 0d       	add	r31, r0
    14e8:	11 24       	eor	r1, r1
    14ea:	e6 56       	subi	r30, 0x66	; 102
    14ec:	f5 4e       	sbci	r31, 0xE5	; 229
    14ee:	90 81       	ld	r25, Z
    14f0:	99 23       	and	r25, r25
    14f2:	91 f3       	breq	.-28     	; 0x14d8 <vTaskSwitchContext+0x1a>
    14f4:	9b e0       	ldi	r25, 0x0B	; 11
    14f6:	92 9f       	mul	r25, r18
    14f8:	a0 01       	movw	r20, r0
    14fa:	93 9f       	mul	r25, r19
    14fc:	50 0d       	add	r21, r0
    14fe:	11 24       	eor	r1, r1
    1500:	df 01       	movw	r26, r30
    1502:	01 80       	ldd	r0, Z+1	; 0x01
    1504:	f2 81       	ldd	r31, Z+2	; 0x02
    1506:	e0 2d       	mov	r30, r0
    1508:	04 80       	ldd	r0, Z+4	; 0x04
    150a:	f5 81       	ldd	r31, Z+5	; 0x05
    150c:	e0 2d       	mov	r30, r0
    150e:	12 96       	adiw	r26, 0x02	; 2
    1510:	fc 93       	st	X, r31
    1512:	ee 93       	st	-X, r30
    1514:	11 97       	sbiw	r26, 0x01	; 1
    1516:	43 56       	subi	r20, 0x63	; 99
    1518:	55 4e       	sbci	r21, 0xE5	; 229
    151a:	e4 17       	cp	r30, r20
    151c:	f5 07       	cpc	r31, r21
    151e:	29 f4       	brne	.+10     	; 0x152a <vTaskSwitchContext+0x6c>
    1520:	44 81       	ldd	r20, Z+4	; 0x04
    1522:	55 81       	ldd	r21, Z+5	; 0x05
    1524:	fd 01       	movw	r30, r26
    1526:	52 83       	std	Z+2, r21	; 0x02
    1528:	41 83       	std	Z+1, r20	; 0x01
    152a:	9b e0       	ldi	r25, 0x0B	; 11
    152c:	92 9f       	mul	r25, r18
    152e:	f0 01       	movw	r30, r0
    1530:	93 9f       	mul	r25, r19
    1532:	f0 0d       	add	r31, r0
    1534:	11 24       	eor	r1, r1
    1536:	e6 56       	subi	r30, 0x66	; 102
    1538:	f5 4e       	sbci	r31, 0xE5	; 229
    153a:	01 80       	ldd	r0, Z+1	; 0x01
    153c:	f2 81       	ldd	r31, Z+2	; 0x02
    153e:	e0 2d       	mov	r30, r0
    1540:	20 85       	ldd	r18, Z+8	; 0x08
    1542:	31 85       	ldd	r19, Z+9	; 0x09
    1544:	30 93 d2 1a 	sts	0x1AD2, r19	; 0x801ad2 <pxCurrentTCB+0x1>
    1548:	20 93 d1 1a 	sts	0x1AD1, r18	; 0x801ad1 <pxCurrentTCB>
    154c:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <uxTopReadyPriority>
    1550:	08 95       	ret

00001552 <vTaskPlaceOnEventList>:
    1552:	cf 92       	push	r12
    1554:	df 92       	push	r13
    1556:	ef 92       	push	r14
    1558:	ff 92       	push	r15
    155a:	6a 01       	movw	r12, r20
    155c:	7b 01       	movw	r14, r22
    155e:	60 91 d1 1a 	lds	r22, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    1562:	70 91 d2 1a 	lds	r23, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    1566:	62 5f       	subi	r22, 0xF2	; 242
    1568:	7f 4f       	sbci	r23, 0xFF	; 255
    156a:	0e 94 ca 00 	call	0x194	; 0x194 <vListInsert>
    156e:	41 e0       	ldi	r20, 0x01	; 1
    1570:	c7 01       	movw	r24, r14
    1572:	b6 01       	movw	r22, r12
    1574:	27 dd       	rcall	.-1458   	; 0xfc4 <prvAddCurrentTaskToDelayedList>
    1576:	ff 90       	pop	r15
    1578:	ef 90       	pop	r14
    157a:	df 90       	pop	r13
    157c:	cf 90       	pop	r12
    157e:	08 95       	ret

00001580 <xTaskRemoveFromEventList>:
    1580:	0f 93       	push	r16
    1582:	1f 93       	push	r17
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	dc 01       	movw	r26, r24
    158a:	17 96       	adiw	r26, 0x07	; 7
    158c:	ed 91       	ld	r30, X+
    158e:	fc 91       	ld	r31, X
    1590:	18 97       	sbiw	r26, 0x08	; 8
    1592:	c0 85       	ldd	r28, Z+8	; 0x08
    1594:	d1 85       	ldd	r29, Z+9	; 0x09
    1596:	8e 01       	movw	r16, r28
    1598:	02 5f       	subi	r16, 0xF2	; 242
    159a:	1f 4f       	sbci	r17, 0xFF	; 255
    159c:	c8 01       	movw	r24, r16
    159e:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    15a2:	80 91 4c 1a 	lds	r24, 0x1A4C	; 0x801a4c <uxSchedulerSuspended>
    15a6:	81 11       	cpse	r24, r1
    15a8:	16 c0       	rjmp	.+44     	; 0x15d6 <xTaskRemoveFromEventList+0x56>
    15aa:	0c 50       	subi	r16, 0x0C	; 12
    15ac:	11 09       	sbc	r17, r1
    15ae:	c8 01       	movw	r24, r16
    15b0:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    15b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    15b6:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <uxTopReadyPriority>
    15ba:	98 17       	cp	r25, r24
    15bc:	10 f4       	brcc	.+4      	; 0x15c2 <xTaskRemoveFromEventList+0x42>
    15be:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <uxTopReadyPriority>
    15c2:	bb e0       	ldi	r27, 0x0B	; 11
    15c4:	8b 9f       	mul	r24, r27
    15c6:	c0 01       	movw	r24, r0
    15c8:	11 24       	eor	r1, r1
    15ca:	b8 01       	movw	r22, r16
    15cc:	86 56       	subi	r24, 0x66	; 102
    15ce:	95 4e       	sbci	r25, 0xE5	; 229
    15d0:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsertEnd>
    15d4:	05 c0       	rjmp	.+10     	; 0x15e0 <xTaskRemoveFromEventList+0x60>
    15d6:	b8 01       	movw	r22, r16
    15d8:	85 e7       	ldi	r24, 0x75	; 117
    15da:	9a e1       	ldi	r25, 0x1A	; 26
    15dc:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsertEnd>
    15e0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    15e2:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    15e6:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    15ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    15ec:	89 17       	cp	r24, r25
    15ee:	20 f4       	brcc	.+8      	; 0x15f8 <xTaskRemoveFromEventList+0x78>
    15f0:	81 e0       	ldi	r24, 0x01	; 1
    15f2:	80 93 55 1a 	sts	0x1A55, r24	; 0x801a55 <xYieldPending>
    15f6:	01 c0       	rjmp	.+2      	; 0x15fa <xTaskRemoveFromEventList+0x7a>
    15f8:	80 e0       	ldi	r24, 0x00	; 0
    15fa:	df 91       	pop	r29
    15fc:	cf 91       	pop	r28
    15fe:	1f 91       	pop	r17
    1600:	0f 91       	pop	r16
    1602:	08 95       	ret

00001604 <vTaskSetTimeOutState>:
    1604:	20 91 54 1a 	lds	r18, 0x1A54	; 0x801a54 <xNumOfOverflows>
    1608:	fc 01       	movw	r30, r24
    160a:	20 83       	st	Z, r18
    160c:	40 91 59 1a 	lds	r20, 0x1A59	; 0x801a59 <xTickCount>
    1610:	50 91 5a 1a 	lds	r21, 0x1A5A	; 0x801a5a <xTickCount+0x1>
    1614:	60 91 5b 1a 	lds	r22, 0x1A5B	; 0x801a5b <xTickCount+0x2>
    1618:	70 91 5c 1a 	lds	r23, 0x1A5C	; 0x801a5c <xTickCount+0x3>
    161c:	41 83       	std	Z+1, r20	; 0x01
    161e:	52 83       	std	Z+2, r21	; 0x02
    1620:	63 83       	std	Z+3, r22	; 0x03
    1622:	74 83       	std	Z+4, r23	; 0x04
    1624:	08 95       	ret

00001626 <xTaskCheckForTimeOut>:
    1626:	8f 92       	push	r8
    1628:	9f 92       	push	r9
    162a:	af 92       	push	r10
    162c:	bf 92       	push	r11
    162e:	cf 92       	push	r12
    1630:	df 92       	push	r13
    1632:	ef 92       	push	r14
    1634:	ff 92       	push	r15
    1636:	0f 93       	push	r16
    1638:	1f 93       	push	r17
    163a:	cf 93       	push	r28
    163c:	df 93       	push	r29
    163e:	fb 01       	movw	r30, r22
    1640:	0f b6       	in	r0, 0x3f	; 63
    1642:	f8 94       	cli
    1644:	0f 92       	push	r0
    1646:	00 91 59 1a 	lds	r16, 0x1A59	; 0x801a59 <xTickCount>
    164a:	10 91 5a 1a 	lds	r17, 0x1A5A	; 0x801a5a <xTickCount+0x1>
    164e:	20 91 5b 1a 	lds	r18, 0x1A5B	; 0x801a5b <xTickCount+0x2>
    1652:	30 91 5c 1a 	lds	r19, 0x1A5C	; 0x801a5c <xTickCount+0x3>
    1656:	40 81       	ld	r20, Z
    1658:	51 81       	ldd	r21, Z+1	; 0x01
    165a:	62 81       	ldd	r22, Z+2	; 0x02
    165c:	73 81       	ldd	r23, Z+3	; 0x03
    165e:	4f 3f       	cpi	r20, 0xFF	; 255
    1660:	af ef       	ldi	r26, 0xFF	; 255
    1662:	5a 07       	cpc	r21, r26
    1664:	6a 07       	cpc	r22, r26
    1666:	7a 07       	cpc	r23, r26
    1668:	81 f1       	breq	.+96     	; 0x16ca <xTaskCheckForTimeOut+0xa4>
    166a:	ec 01       	movw	r28, r24
    166c:	b8 81       	ld	r27, Y
    166e:	a0 91 54 1a 	lds	r26, 0x1A54	; 0x801a54 <xNumOfOverflows>
    1672:	ba 17       	cp	r27, r26
    1674:	49 f0       	breq	.+18     	; 0x1688 <xTaskCheckForTimeOut+0x62>
    1676:	c9 80       	ldd	r12, Y+1	; 0x01
    1678:	da 80       	ldd	r13, Y+2	; 0x02
    167a:	eb 80       	ldd	r14, Y+3	; 0x03
    167c:	fc 80       	ldd	r15, Y+4	; 0x04
    167e:	0c 15       	cp	r16, r12
    1680:	1d 05       	cpc	r17, r13
    1682:	2e 05       	cpc	r18, r14
    1684:	3f 05       	cpc	r19, r15
    1686:	18 f5       	brcc	.+70     	; 0x16ce <xTaskCheckForTimeOut+0xa8>
    1688:	dc 01       	movw	r26, r24
    168a:	11 96       	adiw	r26, 0x01	; 1
    168c:	cd 90       	ld	r12, X+
    168e:	dd 90       	ld	r13, X+
    1690:	ed 90       	ld	r14, X+
    1692:	fc 90       	ld	r15, X
    1694:	14 97       	sbiw	r26, 0x04	; 4
    1696:	48 01       	movw	r8, r16
    1698:	59 01       	movw	r10, r18
    169a:	8c 18       	sub	r8, r12
    169c:	9d 08       	sbc	r9, r13
    169e:	ae 08       	sbc	r10, r14
    16a0:	bf 08       	sbc	r11, r15
    16a2:	84 16       	cp	r8, r20
    16a4:	95 06       	cpc	r9, r21
    16a6:	a6 06       	cpc	r10, r22
    16a8:	b7 06       	cpc	r11, r23
    16aa:	98 f4       	brcc	.+38     	; 0x16d2 <xTaskCheckForTimeOut+0xac>
    16ac:	c0 1a       	sub	r12, r16
    16ae:	d1 0a       	sbc	r13, r17
    16b0:	e2 0a       	sbc	r14, r18
    16b2:	f3 0a       	sbc	r15, r19
    16b4:	4c 0d       	add	r20, r12
    16b6:	5d 1d       	adc	r21, r13
    16b8:	6e 1d       	adc	r22, r14
    16ba:	7f 1d       	adc	r23, r15
    16bc:	40 83       	st	Z, r20
    16be:	51 83       	std	Z+1, r21	; 0x01
    16c0:	62 83       	std	Z+2, r22	; 0x02
    16c2:	73 83       	std	Z+3, r23	; 0x03
    16c4:	9f df       	rcall	.-194    	; 0x1604 <vTaskSetTimeOutState>
    16c6:	80 e0       	ldi	r24, 0x00	; 0
    16c8:	05 c0       	rjmp	.+10     	; 0x16d4 <xTaskCheckForTimeOut+0xae>
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	03 c0       	rjmp	.+6      	; 0x16d4 <xTaskCheckForTimeOut+0xae>
    16ce:	81 e0       	ldi	r24, 0x01	; 1
    16d0:	01 c0       	rjmp	.+2      	; 0x16d4 <xTaskCheckForTimeOut+0xae>
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	0f 90       	pop	r0
    16d6:	0f be       	out	0x3f, r0	; 63
    16d8:	df 91       	pop	r29
    16da:	cf 91       	pop	r28
    16dc:	1f 91       	pop	r17
    16de:	0f 91       	pop	r16
    16e0:	ff 90       	pop	r15
    16e2:	ef 90       	pop	r14
    16e4:	df 90       	pop	r13
    16e6:	cf 90       	pop	r12
    16e8:	bf 90       	pop	r11
    16ea:	af 90       	pop	r10
    16ec:	9f 90       	pop	r9
    16ee:	8f 90       	pop	r8
    16f0:	08 95       	ret

000016f2 <vTaskMissedYield>:
    16f2:	81 e0       	ldi	r24, 0x01	; 1
    16f4:	80 93 55 1a 	sts	0x1A55, r24	; 0x801a55 <xYieldPending>
    16f8:	08 95       	ret

000016fa <vTaskPriorityInherit>:
    16fa:	0f 93       	push	r16
    16fc:	1f 93       	push	r17
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
    1702:	fc 01       	movw	r30, r24
    1704:	89 2b       	or	r24, r25
    1706:	09 f4       	brne	.+2      	; 0x170a <vTaskPriorityInherit+0x10>
    1708:	51 c0       	rjmp	.+162    	; 0x17ac <vTaskPriorityInherit+0xb2>
    170a:	82 8d       	ldd	r24, Z+26	; 0x1a
    170c:	a0 91 d1 1a 	lds	r26, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    1710:	b0 91 d2 1a 	lds	r27, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    1714:	5a 96       	adiw	r26, 0x1a	; 26
    1716:	9c 91       	ld	r25, X
    1718:	89 17       	cp	r24, r25
    171a:	08 f0       	brcs	.+2      	; 0x171e <vTaskPriorityInherit+0x24>
    171c:	47 c0       	rjmp	.+142    	; 0x17ac <vTaskPriorityInherit+0xb2>
    171e:	46 85       	ldd	r20, Z+14	; 0x0e
    1720:	57 85       	ldd	r21, Z+15	; 0x0f
    1722:	60 89       	ldd	r22, Z+16	; 0x10
    1724:	71 89       	ldd	r23, Z+17	; 0x11
    1726:	77 23       	and	r23, r23
    1728:	94 f0       	brlt	.+36     	; 0x174e <vTaskPriorityInherit+0x54>
    172a:	a0 91 d1 1a 	lds	r26, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    172e:	b0 91 d2 1a 	lds	r27, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    1732:	5a 96       	adiw	r26, 0x1a	; 26
    1734:	9c 91       	ld	r25, X
    1736:	45 e0       	ldi	r20, 0x05	; 5
    1738:	50 e0       	ldi	r21, 0x00	; 0
    173a:	60 e0       	ldi	r22, 0x00	; 0
    173c:	70 e0       	ldi	r23, 0x00	; 0
    173e:	49 1b       	sub	r20, r25
    1740:	51 09       	sbc	r21, r1
    1742:	61 09       	sbc	r22, r1
    1744:	71 09       	sbc	r23, r1
    1746:	46 87       	std	Z+14, r20	; 0x0e
    1748:	57 87       	std	Z+15, r21	; 0x0f
    174a:	60 8b       	std	Z+16, r22	; 0x10
    174c:	71 8b       	std	Z+17, r23	; 0x11
    174e:	24 85       	ldd	r18, Z+12	; 0x0c
    1750:	35 85       	ldd	r19, Z+13	; 0x0d
    1752:	4b e0       	ldi	r20, 0x0B	; 11
    1754:	84 9f       	mul	r24, r20
    1756:	c0 01       	movw	r24, r0
    1758:	11 24       	eor	r1, r1
    175a:	86 56       	subi	r24, 0x66	; 102
    175c:	95 4e       	sbci	r25, 0xE5	; 229
    175e:	28 17       	cp	r18, r24
    1760:	39 07       	cpc	r19, r25
    1762:	e9 f4       	brne	.+58     	; 0x179e <vTaskPriorityInherit+0xa4>
    1764:	8f 01       	movw	r16, r30
    1766:	ef 01       	movw	r28, r30
    1768:	22 96       	adiw	r28, 0x02	; 2
    176a:	ce 01       	movw	r24, r28
    176c:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    1770:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    1774:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    1778:	82 8d       	ldd	r24, Z+26	; 0x1a
    177a:	f8 01       	movw	r30, r16
    177c:	82 8f       	std	Z+26, r24	; 0x1a
    177e:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <uxTopReadyPriority>
    1782:	98 17       	cp	r25, r24
    1784:	10 f4       	brcc	.+4      	; 0x178a <vTaskPriorityInherit+0x90>
    1786:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <uxTopReadyPriority>
    178a:	fb e0       	ldi	r31, 0x0B	; 11
    178c:	8f 9f       	mul	r24, r31
    178e:	c0 01       	movw	r24, r0
    1790:	11 24       	eor	r1, r1
    1792:	be 01       	movw	r22, r28
    1794:	86 56       	subi	r24, 0x66	; 102
    1796:	95 4e       	sbci	r25, 0xE5	; 229
    1798:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsertEnd>
    179c:	07 c0       	rjmp	.+14     	; 0x17ac <vTaskPriorityInherit+0xb2>
    179e:	a0 91 d1 1a 	lds	r26, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    17a2:	b0 91 d2 1a 	lds	r27, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    17a6:	5a 96       	adiw	r26, 0x1a	; 26
    17a8:	8c 91       	ld	r24, X
    17aa:	82 8f       	std	Z+26, r24	; 0x1a
    17ac:	df 91       	pop	r29
    17ae:	cf 91       	pop	r28
    17b0:	1f 91       	pop	r17
    17b2:	0f 91       	pop	r16
    17b4:	08 95       	ret

000017b6 <xTaskPriorityDisinherit>:
    17b6:	0f 93       	push	r16
    17b8:	1f 93       	push	r17
    17ba:	cf 93       	push	r28
    17bc:	df 93       	push	r29
    17be:	fc 01       	movw	r30, r24
    17c0:	89 2b       	or	r24, r25
    17c2:	79 f1       	breq	.+94     	; 0x1822 <xTaskPriorityDisinherit+0x6c>
    17c4:	82 a9       	ldd	r24, Z+50	; 0x32
    17c6:	81 50       	subi	r24, 0x01	; 1
    17c8:	82 ab       	std	Z+50, r24	; 0x32
    17ca:	22 8d       	ldd	r18, Z+26	; 0x1a
    17cc:	91 a9       	ldd	r25, Z+49	; 0x31
    17ce:	29 17       	cp	r18, r25
    17d0:	51 f1       	breq	.+84     	; 0x1826 <xTaskPriorityDisinherit+0x70>
    17d2:	81 11       	cpse	r24, r1
    17d4:	2a c0       	rjmp	.+84     	; 0x182a <xTaskPriorityDisinherit+0x74>
    17d6:	ef 01       	movw	r28, r30
    17d8:	8f 01       	movw	r16, r30
    17da:	0e 5f       	subi	r16, 0xFE	; 254
    17dc:	1f 4f       	sbci	r17, 0xFF	; 255
    17de:	c8 01       	movw	r24, r16
    17e0:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
    17e4:	89 a9       	ldd	r24, Y+49	; 0x31
    17e6:	8a 8f       	std	Y+26, r24	; 0x1a
    17e8:	45 e0       	ldi	r20, 0x05	; 5
    17ea:	50 e0       	ldi	r21, 0x00	; 0
    17ec:	60 e0       	ldi	r22, 0x00	; 0
    17ee:	70 e0       	ldi	r23, 0x00	; 0
    17f0:	48 1b       	sub	r20, r24
    17f2:	51 09       	sbc	r21, r1
    17f4:	61 09       	sbc	r22, r1
    17f6:	71 09       	sbc	r23, r1
    17f8:	4e 87       	std	Y+14, r20	; 0x0e
    17fa:	5f 87       	std	Y+15, r21	; 0x0f
    17fc:	68 8b       	std	Y+16, r22	; 0x10
    17fe:	79 8b       	std	Y+17, r23	; 0x11
    1800:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <uxTopReadyPriority>
    1804:	98 17       	cp	r25, r24
    1806:	10 f4       	brcc	.+4      	; 0x180c <xTaskPriorityDisinherit+0x56>
    1808:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <uxTopReadyPriority>
    180c:	2b e0       	ldi	r18, 0x0B	; 11
    180e:	82 9f       	mul	r24, r18
    1810:	c0 01       	movw	r24, r0
    1812:	11 24       	eor	r1, r1
    1814:	b8 01       	movw	r22, r16
    1816:	86 56       	subi	r24, 0x66	; 102
    1818:	95 4e       	sbci	r25, 0xE5	; 229
    181a:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsertEnd>
    181e:	81 e0       	ldi	r24, 0x01	; 1
    1820:	05 c0       	rjmp	.+10     	; 0x182c <xTaskPriorityDisinherit+0x76>
    1822:	80 e0       	ldi	r24, 0x00	; 0
    1824:	03 c0       	rjmp	.+6      	; 0x182c <xTaskPriorityDisinherit+0x76>
    1826:	80 e0       	ldi	r24, 0x00	; 0
    1828:	01 c0       	rjmp	.+2      	; 0x182c <xTaskPriorityDisinherit+0x76>
    182a:	80 e0       	ldi	r24, 0x00	; 0
    182c:	df 91       	pop	r29
    182e:	cf 91       	pop	r28
    1830:	1f 91       	pop	r17
    1832:	0f 91       	pop	r16
    1834:	08 95       	ret

00001836 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1836:	80 91 d1 1a 	lds	r24, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    183a:	90 91 d2 1a 	lds	r25, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    183e:	89 2b       	or	r24, r25
    1840:	39 f0       	breq	.+14     	; 0x1850 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1842:	e0 91 d1 1a 	lds	r30, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    1846:	f0 91 d2 1a 	lds	r31, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
    184a:	82 a9       	ldd	r24, Z+50	; 0x32
    184c:	8f 5f       	subi	r24, 0xFF	; 255
    184e:	82 ab       	std	Z+50, r24	; 0x32
		}

		return pxCurrentTCB;
    1850:	80 91 d1 1a 	lds	r24, 0x1AD1	; 0x801ad1 <pxCurrentTCB>
    1854:	90 91 d2 1a 	lds	r25, 0x1AD2	; 0x801ad2 <pxCurrentTCB+0x1>
	}
    1858:	08 95       	ret

0000185a <main>:
#define SIM_PRESSURE_LEN 10

int main(void)
{
	
	sei();
    185a:	78 94       	sei
	
	UART_init(UBBR);
    185c:	87 e6       	ldi	r24, 0x67	; 103
    185e:	90 e0       	ldi	r25, 0x00	; 0
    1860:	5c d1       	rcall	.+696    	; 0x1b1a <UART_init>
	SPI_init();
    1862:	47 d0       	rcall	.+142    	; 0x18f2 <SPI_init>
	
	stateMutex = xSemaphoreCreateMutex(); // mutex for universal telemetry; in hindsight could also use a queue since state_handler doesn't use it
    1864:	81 e0       	ldi	r24, 0x01	; 1
    1866:	92 d9       	rcall	.-3292   	; 0xb8c <xQueueCreateMutex>
    1868:	90 93 d4 1a 	sts	0x1AD4, r25	; 0x801ad4 <stateMutex+0x1>
    186c:	80 93 d3 1a 	sts	0x1AD3, r24	; 0x801ad3 <stateMutex>
    1870:	40 e0       	ldi	r20, 0x00	; 0
	uart1_rx_queue = xQueueCreate(RX_QUEUE_LEN, sizeof(uint8_t));
    1872:	61 e0       	ldi	r22, 0x01	; 1
    1874:	8e e1       	ldi	r24, 0x1E	; 30
    1876:	c5 d8       	rcall	.-3702   	; 0xa02 <xQueueGenericCreate>
    1878:	90 93 e5 1a 	sts	0x1AE5, r25	; 0x801ae5 <uart1_rx_queue+0x1>
    187c:	80 93 e4 1a 	sts	0x1AE4, r24	; 0x801ae4 <uart1_rx_queue>
    1880:	40 e0       	ldi	r20, 0x00	; 0
	events_queue = xQueueCreate(EVENTS_QUEUE_LEN, sizeof(CanSatEvents_t));
    1882:	61 e0       	ldi	r22, 0x01	; 1
    1884:	8a e0       	ldi	r24, 0x0A	; 10
    1886:	bd d8       	rcall	.-3718   	; 0xa02 <xQueueGenericCreate>
    1888:	90 93 e1 1a 	sts	0x1AE1, r25	; 0x801ae1 <events_queue+0x1>
    188c:	80 93 e0 1a 	sts	0x1AE0, r24	; 0x801ae0 <events_queue>
    1890:	40 e0       	ldi	r20, 0x00	; 0
	simulated_pressure_queue = xQueueCreate(SIM_PRESSURE_LEN, sizeof(float));
    1892:	64 e0       	ldi	r22, 0x04	; 4
    1894:	8a e0       	ldi	r24, 0x0A	; 10
    1896:	b5 d8       	rcall	.-3734   	; 0xa02 <xQueueGenericCreate>
    1898:	90 93 e3 1a 	sts	0x1AE3, r25	; 0x801ae3 <simulated_pressure_queue+0x1>
    189c:	80 93 e2 1a 	sts	0x1AE2, r24	; 0x801ae2 <simulated_pressure_queue>
    18a0:	e1 2c       	mov	r14, r1
    18a2:	f1 2c       	mov	r15, r1
	
	// Additional task to see that multiple tasks can run at the same time
	extern void simulated_data_reading (void *pvParameters);
	xTaskCreate(simulated_data_reading, "Task to simulate reading data from W25Q32, will include other sensors", 100, NULL, 2, NULL);
    18a4:	02 e0       	ldi	r16, 0x02	; 2
    18a6:	20 e0       	ldi	r18, 0x00	; 0
    18a8:	30 e0       	ldi	r19, 0x00	; 0
    18aa:	44 e6       	ldi	r20, 0x64	; 100
    18ac:	50 e0       	ldi	r21, 0x00	; 0
    18ae:	67 e0       	ldi	r22, 0x07	; 7
    18b0:	72 e0       	ldi	r23, 0x02	; 2
    18b2:	8a ea       	ldi	r24, 0xAA	; 170
    18b4:	9c e0       	ldi	r25, 0x0C	; 12
    18b6:	f9 db       	rcall	.-2062   	; 0x10aa <xTaskCreate>
    18b8:	20 e0       	ldi	r18, 0x00	; 0
    18ba:	30 e0       	ldi	r19, 0x00	; 0
	
	extern void send_to_ground (void *pvParameters);
	xTaskCreate(send_to_ground, "Task to send telemetry to ground", 200, NULL, 2, NULL);
    18bc:	48 ec       	ldi	r20, 0xC8	; 200
    18be:	50 e0       	ldi	r21, 0x00	; 0
    18c0:	6d e4       	ldi	r22, 0x4D	; 77
    18c2:	72 e0       	ldi	r23, 0x02	; 2
    18c4:	88 e0       	ldi	r24, 0x08	; 8
    18c6:	9d e0       	ldi	r25, 0x0D	; 13
    18c8:	f0 db       	rcall	.-2080   	; 0x10aa <xTaskCreate>
    18ca:	20 e0       	ldi	r18, 0x00	; 0
    18cc:	30 e0       	ldi	r19, 0x00	; 0
	
	extern void receive_from_ground (void *pvParameters);
	xTaskCreate(receive_from_ground, "Task to receive commands from ground", 200, NULL, 2, NULL);
    18ce:	48 ec       	ldi	r20, 0xC8	; 200
    18d0:	50 e0       	ldi	r21, 0x00	; 0
    18d2:	6e e6       	ldi	r22, 0x6E	; 110
    18d4:	72 e0       	ldi	r23, 0x02	; 2
    18d6:	8c e4       	ldi	r24, 0x4C	; 76
    18d8:	9d e0       	ldi	r25, 0x0D	; 13
    18da:	e7 db       	rcall	.-2098   	; 0x10aa <xTaskCreate>
    18dc:	20 e0       	ldi	r18, 0x00	; 0
    18de:	30 e0       	ldi	r19, 0x00	; 0
	
	extern void state_manager (void *pvParameters);
	xTaskCreate(state_manager, "Task to handle all events", 100, NULL, 2, NULL);
    18e0:	44 e6       	ldi	r20, 0x64	; 100
    18e2:	50 e0       	ldi	r21, 0x00	; 0
    18e4:	63 e9       	ldi	r22, 0x93	; 147
    18e6:	72 e0       	ldi	r23, 0x02	; 2
    18e8:	88 e8       	ldi	r24, 0x88	; 136
    18ea:	9c e0       	ldi	r25, 0x0C	; 12
    18ec:	de db       	rcall	.-2116   	; 0x10aa <xTaskCreate>
    18ee:	2c dc       	rcall	.-1960   	; 0x1148 <vTaskStartScheduler>
    18f0:	ff cf       	rjmp	.-2      	; 0x18f0 <main+0x96>

000018f2 <SPI_init>:
 */ 

#include "spi.h"

void SPI_init(void) {
	DDR_SPI = (1<<SS) | (1<<SCK) | (1<<MOSI); // set relevant pins to output
    18f2:	87 e0       	ldi	r24, 0x07	; 7
    18f4:	84 b9       	out	0x04, r24	; 4
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0); // enable spi, set as master, use mode 0, set sck = f/16
    18f6:	81 e5       	ldi	r24, 0x51	; 81
    18f8:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1<<SS); // add when more slaves added
    18fa:	85 b1       	in	r24, 0x05	; 5
    18fc:	81 60       	ori	r24, 0x01	; 1
    18fe:	85 b9       	out	0x05, r24	; 5
    1900:	08 95       	ret

00001902 <ascent_handler>:
HandlerFunc functionTable[] = {
	ascent_handler};

void ascent_handler()
{
	universal_telemetry.stage = ASCENT;
    1902:	81 e0       	ldi	r24, 0x01	; 1
    1904:	80 93 de 1a 	sts	0x1ADE, r24	; 0x801ade <universal_telemetry+0x9>

	print("Launched!");
    1908:	8d ea       	ldi	r24, 0xAD	; 173
    190a:	92 e0       	ldi	r25, 0x02	; 2
    190c:	28 c1       	rjmp	.+592    	; 0x1b5e <print>
    190e:	08 95       	ret

00001910 <state_manager>:
}

void state_manager(void *pvParameters)
{
    1910:	cf 93       	push	r28
    1912:	df 93       	push	r29
    1914:	1f 92       	push	r1
    1916:	cd b7       	in	r28, 0x3d	; 61
    1918:	de b7       	in	r29, 0x3e	; 62
	universal_telemetry.mode = MODE_SIMULATION; // hard code until all sensors come
    191a:	e5 ed       	ldi	r30, 0xD5	; 213
    191c:	fa e1       	ldi	r31, 0x1A	; 26
    191e:	10 86       	std	Z+8, r1	; 0x08
	universal_telemetry.stage = LAUNCH_PAD;		// cansat starts off on ground
    1920:	11 86       	std	Z+9, r1	; 0x09

	CanSatEvents_t current_event;

	while (1)
	{
		if (xQueueReceive(events_queue, &current_event, portMAX_DELAY) == pdTRUE)
    1922:	00 e0       	ldi	r16, 0x00	; 0
    1924:	2f ef       	ldi	r18, 0xFF	; 255
    1926:	3f ef       	ldi	r19, 0xFF	; 255
    1928:	a9 01       	movw	r20, r18
    192a:	be 01       	movw	r22, r28
    192c:	6f 5f       	subi	r22, 0xFF	; 255
    192e:	7f 4f       	sbci	r23, 0xFF	; 255
    1930:	80 91 e0 1a 	lds	r24, 0x1AE0	; 0x801ae0 <events_queue>
    1934:	90 91 e1 1a 	lds	r25, 0x1AE1	; 0x801ae1 <events_queue+0x1>
    1938:	6d d9       	rcall	.-3366   	; 0xc14 <xQueueGenericReceive>
    193a:	81 30       	cpi	r24, 0x01	; 1
    193c:	91 f7       	brne	.-28     	; 0x1922 <state_manager+0x12>
		{
			functionTable[current_event]();
    193e:	e9 81       	ldd	r30, Y+1	; 0x01
    1940:	f0 e0       	ldi	r31, 0x00	; 0
    1942:	ee 0f       	add	r30, r30
    1944:	ff 1f       	adc	r31, r31
    1946:	e0 50       	subi	r30, 0x00	; 0
    1948:	fe 4f       	sbci	r31, 0xFE	; 254
    194a:	01 90       	ld	r0, Z+
    194c:	f0 81       	ld	r31, Z
    194e:	e0 2d       	mov	r30, r0
    1950:	19 95       	eicall
    1952:	e7 cf       	rjmp	.-50     	; 0x1922 <state_manager+0x12>

00001954 <simulated_data_reading>:
		PORTB ^= (1<<PB7);
		vTaskDelay(pdMS_TO_TICKS(2000));
	}
}

void simulated_data_reading (void *pvParameters) {
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	00 d0       	rcall	.+0      	; 0x195a <simulated_data_reading+0x6>
    195a:	1f 92       	push	r1
    195c:	cd b7       	in	r28, 0x3d	; 61
    195e:	de b7       	in	r29, 0x3e	; 62
	float pressure;
	while (1) {
		// read queue with pressure data
		if (xQueueReceive(simulated_pressure_queue, &pressure, portMAX_DELAY) == pdTRUE) {
    1960:	00 e0       	ldi	r16, 0x00	; 0
    1962:	2f ef       	ldi	r18, 0xFF	; 255
    1964:	3f ef       	ldi	r19, 0xFF	; 255
    1966:	a9 01       	movw	r20, r18
    1968:	be 01       	movw	r22, r28
    196a:	6f 5f       	subi	r22, 0xFF	; 255
    196c:	7f 4f       	sbci	r23, 0xFF	; 255
    196e:	80 91 e2 1a 	lds	r24, 0x1AE2	; 0x801ae2 <simulated_pressure_queue>
    1972:	90 91 e3 1a 	lds	r25, 0x1AE3	; 0x801ae3 <simulated_pressure_queue+0x1>
    1976:	4e d9       	rcall	.-3428   	; 0xc14 <xQueueGenericReceive>
    1978:	81 30       	cpi	r24, 0x01	; 1
    197a:	31 f5       	brne	.+76     	; 0x19c8 <simulated_data_reading+0x74>
			xSemaphoreTake(stateMutex, portMAX_DELAY);
    197c:	2f ef       	ldi	r18, 0xFF	; 255
    197e:	3f ef       	ldi	r19, 0xFF	; 255
    1980:	a9 01       	movw	r20, r18
    1982:	60 e0       	ldi	r22, 0x00	; 0
    1984:	70 e0       	ldi	r23, 0x00	; 0
    1986:	80 91 d3 1a 	lds	r24, 0x1AD3	; 0x801ad3 <stateMutex>
    198a:	90 91 d4 1a 	lds	r25, 0x1AD4	; 0x801ad4 <stateMutex+0x1>
    198e:	42 d9       	rcall	.-3452   	; 0xc14 <xQueueGenericReceive>
			universal_telemetry.pressure = pressure;
    1990:	e5 ed       	ldi	r30, 0xD5	; 213
    1992:	fa e1       	ldi	r31, 0x1A	; 26
    1994:	89 81       	ldd	r24, Y+1	; 0x01
    1996:	9a 81       	ldd	r25, Y+2	; 0x02
    1998:	ab 81       	ldd	r26, Y+3	; 0x03
    199a:	bc 81       	ldd	r27, Y+4	; 0x04
    199c:	80 83       	st	Z, r24
    199e:	91 83       	std	Z+1, r25	; 0x01
    19a0:	a2 83       	std	Z+2, r26	; 0x02
    19a2:	b3 83       	std	Z+3, r27	; 0x03
			universal_telemetry.altitude = 10.0;
    19a4:	80 e0       	ldi	r24, 0x00	; 0
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	a0 e2       	ldi	r26, 0x20	; 32
    19aa:	b1 e4       	ldi	r27, 0x41	; 65
    19ac:	84 83       	std	Z+4, r24	; 0x04
    19ae:	95 83       	std	Z+5, r25	; 0x05
    19b0:	a6 83       	std	Z+6, r26	; 0x06
    19b2:	b7 83       	std	Z+7, r27	; 0x07
			
			// send events if altitude is high enough
			
			xSemaphoreGive(stateMutex);
    19b4:	20 e0       	ldi	r18, 0x00	; 0
    19b6:	30 e0       	ldi	r19, 0x00	; 0
    19b8:	a9 01       	movw	r20, r18
    19ba:	60 e0       	ldi	r22, 0x00	; 0
    19bc:	70 e0       	ldi	r23, 0x00	; 0
    19be:	80 91 d3 1a 	lds	r24, 0x1AD3	; 0x801ad3 <stateMutex>
    19c2:	90 91 d4 1a 	lds	r25, 0x1AD4	; 0x801ad4 <stateMutex+0x1>
    19c6:	45 d8       	rcall	.-3958   	; 0xa52 <xQueueGenericSend>
		}
		
		vTaskDelay(pdMS_TO_TICKS(2000));
    19c8:	60 ed       	ldi	r22, 0xD0	; 208
    19ca:	77 e0       	ldi	r23, 0x07	; 7
    19cc:	80 e0       	ldi	r24, 0x00	; 0
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	2a dd       	rcall	.-1452   	; 0x1426 <vTaskDelay>
	}
    19d2:	c6 cf       	rjmp	.-116    	; 0x1960 <simulated_data_reading+0xc>

000019d4 <checksum_calculator>:
#include "tasks.h"

QueueHandle_t telemetryQueue;

uint8_t checksum_calculator(TelemetryData *tm_data)
{
    19d4:	ac 01       	movw	r20, r24
	uint8_t checksum = 0;

	// =============== For Automation ===============
	for (size_t i = 0; i < sizeof(tm_data->pressure); i++)
    19d6:	20 e0       	ldi	r18, 0x00	; 0
    19d8:	30 e0       	ldi	r19, 0x00	; 0

QueueHandle_t telemetryQueue;

uint8_t checksum_calculator(TelemetryData *tm_data)
{
	uint8_t checksum = 0;
    19da:	80 e0       	ldi	r24, 0x00	; 0

	// =============== For Automation ===============
	for (size_t i = 0; i < sizeof(tm_data->pressure); i++)
    19dc:	07 c0       	rjmp	.+14     	; 0x19ec <checksum_calculator+0x18>
	{
		checksum ^= *((uint8_t *)(&(tm_data->pressure)) + i);
    19de:	fa 01       	movw	r30, r20
    19e0:	e2 0f       	add	r30, r18
    19e2:	f3 1f       	adc	r31, r19
    19e4:	90 81       	ld	r25, Z
    19e6:	89 27       	eor	r24, r25
uint8_t checksum_calculator(TelemetryData *tm_data)
{
	uint8_t checksum = 0;

	// =============== For Automation ===============
	for (size_t i = 0; i < sizeof(tm_data->pressure); i++)
    19e8:	2f 5f       	subi	r18, 0xFF	; 255
    19ea:	3f 4f       	sbci	r19, 0xFF	; 255
    19ec:	24 30       	cpi	r18, 0x04	; 4
    19ee:	31 05       	cpc	r19, r1
    19f0:	b0 f3       	brcs	.-20     	; 0x19de <checksum_calculator+0xa>
    19f2:	20 e0       	ldi	r18, 0x00	; 0
    19f4:	30 e0       	ldi	r19, 0x00	; 0
    19f6:	08 c0       	rjmp	.+16     	; 0x1a08 <checksum_calculator+0x34>
		checksum ^= *((uint8_t *)(&(tm_data->pressure)) + i);
	}

	for (size_t i = 0; i < sizeof(tm_data->altitude); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->altitude)) + i);
    19f8:	fa 01       	movw	r30, r20
    19fa:	34 96       	adiw	r30, 0x04	; 4
    19fc:	e2 0f       	add	r30, r18
    19fe:	f3 1f       	adc	r31, r19
    1a00:	90 81       	ld	r25, Z
    1a02:	89 27       	eor	r24, r25
	for (size_t i = 0; i < sizeof(tm_data->pressure); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->pressure)) + i);
	}

	for (size_t i = 0; i < sizeof(tm_data->altitude); i++)
    1a04:	2f 5f       	subi	r18, 0xFF	; 255
    1a06:	3f 4f       	sbci	r19, 0xFF	; 255
    1a08:	24 30       	cpi	r18, 0x04	; 4
    1a0a:	31 05       	cpc	r19, r1
    1a0c:	a8 f3       	brcs	.-22     	; 0x19f8 <checksum_calculator+0x24>
		checksum ^= *((uint8_t *)(&(tm_data->altitude)) + i);
	}
	// ==============================================

	return checksum;
}
    1a0e:	08 95       	ret

00001a10 <send_to_ground>:

void send_to_ground(void *pvParameters)
{
    1a10:	cf 93       	push	r28
    1a12:	df 93       	push	r29
    1a14:	1f 92       	push	r1
    1a16:	1f 92       	push	r1
    1a18:	cd b7       	in	r28, 0x3d	; 61
    1a1a:	de b7       	in	r29, 0x3e	; 62
	uint8_t start = START_BYTE;
    1a1c:	8f ef       	ldi	r24, 0xFF	; 255
    1a1e:	89 83       	std	Y+1, r24	; 0x01
	uint8_t end = END_BYTE;
    1a20:	8a e0       	ldi	r24, 0x0A	; 10
    1a22:	8a 83       	std	Y+2, r24	; 0x02
	while (1)
	{
		xSemaphoreTake(stateMutex, portMAX_DELAY);
    1a24:	00 e0       	ldi	r16, 0x00	; 0
    1a26:	2f ef       	ldi	r18, 0xFF	; 255
    1a28:	3f ef       	ldi	r19, 0xFF	; 255
    1a2a:	a9 01       	movw	r20, r18
    1a2c:	60 e0       	ldi	r22, 0x00	; 0
    1a2e:	70 e0       	ldi	r23, 0x00	; 0
    1a30:	80 91 d3 1a 	lds	r24, 0x1AD3	; 0x801ad3 <stateMutex>
    1a34:	90 91 d4 1a 	lds	r25, 0x1AD4	; 0x801ad4 <stateMutex+0x1>
    1a38:	ed d8       	rcall	.-3622   	; 0xc14 <xQueueGenericReceive>

		// calculate checksum
		universal_telemetry.checksum = checksum_calculator(&universal_telemetry);
    1a3a:	85 ed       	ldi	r24, 0xD5	; 213
    1a3c:	9a e1       	ldi	r25, 0x1A	; 26
    1a3e:	ca df       	rcall	.-108    	; 0x19d4 <checksum_calculator>
    1a40:	80 93 df 1a 	sts	0x1ADF, r24	; 0x801adf <universal_telemetry+0xa>

		UART1_send_bytes(&start, 1);
    1a44:	61 e0       	ldi	r22, 0x01	; 1
    1a46:	70 e0       	ldi	r23, 0x00	; 0
    1a48:	ce 01       	movw	r24, r28
    1a4a:	01 96       	adiw	r24, 0x01	; 1
    1a4c:	94 d0       	rcall	.+296    	; 0x1b76 <UART1_send_bytes>

		// =============== For Automation ===============
		UART1_send_bytes(&(universal_telemetry.pressure), sizeof(universal_telemetry.pressure));
    1a4e:	64 e0       	ldi	r22, 0x04	; 4
    1a50:	70 e0       	ldi	r23, 0x00	; 0
    1a52:	85 ed       	ldi	r24, 0xD5	; 213
    1a54:	9a e1       	ldi	r25, 0x1A	; 26
    1a56:	8f d0       	rcall	.+286    	; 0x1b76 <UART1_send_bytes>
		UART1_send_bytes(&(universal_telemetry.altitude), sizeof(universal_telemetry.altitude));
    1a58:	64 e0       	ldi	r22, 0x04	; 4
    1a5a:	70 e0       	ldi	r23, 0x00	; 0
    1a5c:	89 ed       	ldi	r24, 0xD9	; 217
    1a5e:	9a e1       	ldi	r25, 0x1A	; 26
    1a60:	8a d0       	rcall	.+276    	; 0x1b76 <UART1_send_bytes>
		// ==============================================

		UART1_send_bytes(&(universal_telemetry.checksum), sizeof(universal_telemetry.checksum));
    1a62:	61 e0       	ldi	r22, 0x01	; 1
    1a64:	70 e0       	ldi	r23, 0x00	; 0
    1a66:	8f ed       	ldi	r24, 0xDF	; 223
    1a68:	9a e1       	ldi	r25, 0x1A	; 26
    1a6a:	85 d0       	rcall	.+266    	; 0x1b76 <UART1_send_bytes>
		UART1_send_bytes(&end, 1);
    1a6c:	61 e0       	ldi	r22, 0x01	; 1
    1a6e:	70 e0       	ldi	r23, 0x00	; 0
    1a70:	ce 01       	movw	r24, r28
    1a72:	02 96       	adiw	r24, 0x02	; 2
    1a74:	80 d0       	rcall	.+256    	; 0x1b76 <UART1_send_bytes>
    1a76:	20 e0       	ldi	r18, 0x00	; 0

		xSemaphoreGive(stateMutex);
    1a78:	30 e0       	ldi	r19, 0x00	; 0
    1a7a:	a9 01       	movw	r20, r18
    1a7c:	60 e0       	ldi	r22, 0x00	; 0
    1a7e:	70 e0       	ldi	r23, 0x00	; 0
    1a80:	80 91 d3 1a 	lds	r24, 0x1AD3	; 0x801ad3 <stateMutex>
    1a84:	90 91 d4 1a 	lds	r25, 0x1AD4	; 0x801ad4 <stateMutex+0x1>
    1a88:	0e 94 29 05 	call	0xa52	; 0xa52 <xQueueGenericSend>

		vTaskDelay(pdMS_TO_TICKS(2000));
    1a8c:	60 ed       	ldi	r22, 0xD0	; 208
    1a8e:	77 e0       	ldi	r23, 0x07	; 7
    1a90:	80 e0       	ldi	r24, 0x00	; 0
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	c8 dc       	rcall	.-1648   	; 0x1426 <vTaskDelay>
    1a96:	c6 cf       	rjmp	.-116    	; 0x1a24 <send_to_ground+0x14>

00001a98 <receive_from_ground>:
    1a98:	cf 93       	push	r28
	}
}

void receive_from_ground(void *pvParameters) {
    1a9a:	df 93       	push	r29
    1a9c:	cd b7       	in	r28, 0x3d	; 61
    1a9e:	de b7       	in	r29, 0x3e	; 62
    1aa0:	68 97       	sbiw	r28, 0x18	; 24
    1aa2:	0f b6       	in	r0, 0x3f	; 63
    1aa4:	f8 94       	cli
    1aa6:	de bf       	out	0x3e, r29	; 62
    1aa8:	0f be       	out	0x3f, r0	; 63
    1aaa:	cd bf       	out	0x3d, r28	; 61
	while (1) {
		// check if valid packet
		// print("Listening for Commands!\r\n");
		
			// print("Read smth!\r\n");
			UART1_receive_bytes(buf);
    1aac:	ce 01       	movw	r24, r28
    1aae:	01 96       	adiw	r24, 0x01	; 1
    1ab0:	75 d0       	rcall	.+234    	; 0x1b9c <UART1_receive_bytes>

			// =============== For Automation ===============
			// for now I'm assuming the command is just a single byte
			// will eventually verify checksum and allow for command arguments

			uint8_t command_id = buf[0];
    1ab2:	89 81       	ldd	r24, Y+1	; 0x01
			CanSatEvents_t event;

			switch (command_id) {
    1ab4:	81 30       	cpi	r24, 0x01	; 1
    1ab6:	19 f0       	breq	.+6      	; 0x1abe <receive_from_ground+0x26>
    1ab8:	82 30       	cpi	r24, 0x02	; 2
    1aba:	81 f0       	breq	.+32     	; 0x1adc <receive_from_ground+0x44>
    1abc:	25 c0       	rjmp	.+74     	; 0x1b08 <receive_from_ground+0x70>
			case 0x01:
				event = LAUNCH_OK;
    1abe:	1d 8a       	std	Y+21, r1	; 0x15
				xQueueSend(events_queue, &event, portMAX_DELAY);
    1ac0:	00 e0       	ldi	r16, 0x00	; 0
    1ac2:	2f ef       	ldi	r18, 0xFF	; 255
    1ac4:	3f ef       	ldi	r19, 0xFF	; 255
    1ac6:	a9 01       	movw	r20, r18
    1ac8:	be 01       	movw	r22, r28
    1aca:	6b 5e       	subi	r22, 0xEB	; 235
    1acc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ace:	80 91 e0 1a 	lds	r24, 0x1AE0	; 0x801ae0 <events_queue>
    1ad2:	90 91 e1 1a 	lds	r25, 0x1AE1	; 0x801ae1 <events_queue+0x1>
    1ad6:	0e 94 29 05 	call	0xa52	; 0xa52 <xQueueGenericSend>
				break;
    1ada:	19 c0       	rjmp	.+50     	; 0x1b0e <receive_from_ground+0x76>
			case 0x02: ;
				float pressure;
				memcpy(&pressure, &buf[1], sizeof(float));
    1adc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ade:	9b 81       	ldd	r25, Y+3	; 0x03
    1ae0:	ac 81       	ldd	r26, Y+4	; 0x04
    1ae2:	bd 81       	ldd	r27, Y+5	; 0x05
    1ae4:	8d 8b       	std	Y+21, r24	; 0x15
    1ae6:	9e 8b       	std	Y+22, r25	; 0x16
    1ae8:	af 8b       	std	Y+23, r26	; 0x17
    1aea:	b8 8f       	std	Y+24, r27	; 0x18
				xQueueSend(simulated_pressure_queue, &pressure, portMAX_DELAY);
    1aec:	00 e0       	ldi	r16, 0x00	; 0
    1aee:	2f ef       	ldi	r18, 0xFF	; 255
    1af0:	3f ef       	ldi	r19, 0xFF	; 255
    1af2:	a9 01       	movw	r20, r18
    1af4:	be 01       	movw	r22, r28
    1af6:	6b 5e       	subi	r22, 0xEB	; 235
    1af8:	7f 4f       	sbci	r23, 0xFF	; 255
    1afa:	80 91 e2 1a 	lds	r24, 0x1AE2	; 0x801ae2 <simulated_pressure_queue>
    1afe:	90 91 e3 1a 	lds	r25, 0x1AE3	; 0x801ae3 <simulated_pressure_queue+0x1>
    1b02:	0e 94 29 05 	call	0xa52	; 0xa52 <xQueueGenericSend>
				break;
    1b06:	03 c0       	rjmp	.+6      	; 0x1b0e <receive_from_ground+0x76>
			default:
				print("Something went wrong!\r\n");
    1b08:	87 eb       	ldi	r24, 0xB7	; 183
    1b0a:	92 e0       	ldi	r25, 0x02	; 2
    1b0c:	28 d0       	rcall	.+80     	; 0x1b5e <print>
				break;
			}

		vTaskDelay(pdMS_TO_TICKS(2000));
    1b0e:	60 ed       	ldi	r22, 0xD0	; 208
    1b10:	77 e0       	ldi	r23, 0x07	; 7
    1b12:	80 e0       	ldi	r24, 0x00	; 0
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	87 dc       	rcall	.-1778   	; 0x1426 <vTaskDelay>
	}
    1b18:	c9 cf       	rjmp	.-110    	; 0x1aac <receive_from_ground+0x14>

00001b1a <UART_init>:

// Deprecated, do not use
uint8_t UART1_rx() {
	while (!(UCSR1A & (1<<RXC1)));
	return UDR1;
}
    1b1a:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
    1b1e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
    1b22:	28 e1       	ldi	r18, 0x18	; 24
    1b24:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7c00c1>
    1b28:	26 e0       	ldi	r18, 0x06	; 6
    1b2a:	20 93 c2 00 	sts	0x00C2, r18	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7c00c2>
    1b2e:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7c00cd>
    1b32:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7c00cc>
    1b36:	88 e9       	ldi	r24, 0x98	; 152
    1b38:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7c00c9>
    1b3c:	20 93 ca 00 	sts	0x00CA, r18	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7c00ca>
    1b40:	08 95       	ret

00001b42 <UART0_tx>:
    1b42:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7c00c0>
    1b46:	95 ff       	sbrs	r25, 5
    1b48:	fc cf       	rjmp	.-8      	; 0x1b42 <UART0_tx>
    1b4a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    1b4e:	08 95       	ret

00001b50 <UART1_tx>:
    1b50:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7c00c8>
    1b54:	95 ff       	sbrs	r25, 5
    1b56:	fc cf       	rjmp	.-8      	; 0x1b50 <UART1_tx>
    1b58:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7c00ce>
    1b5c:	08 95       	ret

00001b5e <print>:

void print(char *s) {
    1b5e:	cf 93       	push	r28
    1b60:	df 93       	push	r29
    1b62:	ec 01       	movw	r28, r24
	while (*s != '\0') {
    1b64:	02 c0       	rjmp	.+4      	; 0x1b6a <print+0xc>
		UART0_tx(*s);
    1b66:	ed df       	rcall	.-38     	; 0x1b42 <UART0_tx>
		s++;
    1b68:	21 96       	adiw	r28, 0x01	; 1
	while (!(UCSR1A & (1<<RXC1)));
	return UDR1;
}

void print(char *s) {
	while (*s != '\0') {
    1b6a:	88 81       	ld	r24, Y
    1b6c:	81 11       	cpse	r24, r1
    1b6e:	fb cf       	rjmp	.-10     	; 0x1b66 <print+0x8>
		UART0_tx(*s);
		s++;
	}
}
    1b70:	df 91       	pop	r29
    1b72:	cf 91       	pop	r28
    1b74:	08 95       	ret

00001b76 <UART1_send_bytes>:

void UART1_send_bytes(char *s, size_t size) {
    1b76:	0f 93       	push	r16
    1b78:	1f 93       	push	r17
    1b7a:	cf 93       	push	r28
    1b7c:	df 93       	push	r29
    1b7e:	ec 01       	movw	r28, r24
	char* end = s + size;
    1b80:	8c 01       	movw	r16, r24
    1b82:	06 0f       	add	r16, r22
    1b84:	17 1f       	adc	r17, r23
	while (s < end) {
    1b86:	02 c0       	rjmp	.+4      	; 0x1b8c <UART1_send_bytes+0x16>
		UART1_tx(*s);
    1b88:	89 91       	ld	r24, Y+
    1b8a:	e2 df       	rcall	.-60     	; 0x1b50 <UART1_tx>
	}
}

void UART1_send_bytes(char *s, size_t size) {
	char* end = s + size;
	while (s < end) {
    1b8c:	c0 17       	cp	r28, r16
    1b8e:	d1 07       	cpc	r29, r17
    1b90:	d8 f3       	brcs	.-10     	; 0x1b88 <UART1_send_bytes+0x12>
		UART1_tx(*s);
		s++;
	}
}
    1b92:	df 91       	pop	r29
    1b94:	cf 91       	pop	r28
    1b96:	1f 91       	pop	r17
    1b98:	0f 91       	pop	r16
    1b9a:	08 95       	ret

00001b9c <UART1_receive_bytes>:

// need find a way to drop command if no 0x0A
void UART1_receive_bytes(uint8_t *buf) {
    1b9c:	cf 92       	push	r12
    1b9e:	df 92       	push	r13
    1ba0:	ef 92       	push	r14
    1ba2:	ff 92       	push	r15
    1ba4:	0f 93       	push	r16
    1ba6:	cf 93       	push	r28
    1ba8:	df 93       	push	r29
    1baa:	1f 92       	push	r1
    1bac:	cd b7       	in	r28, 0x3d	; 61
    1bae:	de b7       	in	r29, 0x3e	; 62
    1bb0:	6c 01       	movw	r12, r24
	//}
	uint8_t c;
	size_t i = 0;

	while (1) {
		if (xQueueReceive(uart1_rx_queue, &c, portMAX_DELAY) == pdTRUE) {
    1bb2:	00 e0       	ldi	r16, 0x00	; 0
    1bb4:	2f ef       	ldi	r18, 0xFF	; 255
    1bb6:	3f ef       	ldi	r19, 0xFF	; 255
    1bb8:	a9 01       	movw	r20, r18
    1bba:	be 01       	movw	r22, r28
    1bbc:	6f 5f       	subi	r22, 0xFF	; 255
    1bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    1bc0:	80 91 e4 1a 	lds	r24, 0x1AE4	; 0x801ae4 <uart1_rx_queue>
    1bc4:	90 91 e5 1a 	lds	r25, 0x1AE5	; 0x801ae5 <uart1_rx_queue+0x1>
    1bc8:	25 d8       	rcall	.-4022   	; 0xc14 <xQueueGenericReceive>
    1bca:	81 30       	cpi	r24, 0x01	; 1
    1bcc:	91 f7       	brne	.-28     	; 0x1bb2 <UART1_receive_bytes+0x16>
			if (c == 0xFF) {
    1bce:	89 81       	ldd	r24, Y+1	; 0x01
    1bd0:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd2:	79 f7       	brne	.-34     	; 0x1bb2 <UART1_receive_bytes+0x16>
    1bd4:	e1 2c       	mov	r14, r1
    1bd6:	f1 2c       	mov	r15, r1
				i = 0;
				do {
					xQueueReceive(uart1_rx_queue, &c, portMAX_DELAY);
    1bd8:	00 e0       	ldi	r16, 0x00	; 0
    1bda:	2f ef       	ldi	r18, 0xFF	; 255
    1bdc:	3f ef       	ldi	r19, 0xFF	; 255
    1bde:	a9 01       	movw	r20, r18
    1be0:	be 01       	movw	r22, r28
    1be2:	6f 5f       	subi	r22, 0xFF	; 255
    1be4:	7f 4f       	sbci	r23, 0xFF	; 255
    1be6:	80 91 e4 1a 	lds	r24, 0x1AE4	; 0x801ae4 <uart1_rx_queue>
    1bea:	90 91 e5 1a 	lds	r25, 0x1AE5	; 0x801ae5 <uart1_rx_queue+0x1>
    1bee:	12 d8       	rcall	.-4060   	; 0xc14 <xQueueGenericReceive>
					if (c != 0x0A) {
    1bf0:	89 81       	ldd	r24, Y+1	; 0x01
    1bf2:	8a 30       	cpi	r24, 0x0A	; 10
    1bf4:	39 f0       	breq	.+14     	; 0x1c04 <UART1_receive_bytes+0x68>
						buf[i++] = c; 
    1bf6:	f6 01       	movw	r30, r12
    1bf8:	ee 0d       	add	r30, r14
    1bfa:	ff 1d       	adc	r31, r15
    1bfc:	80 83       	st	Z, r24
    1bfe:	c7 01       	movw	r24, r14
    1c00:	01 96       	adiw	r24, 0x01	; 1
    1c02:	7c 01       	movw	r14, r24
					}
				} while (c != 0x0A);
    1c04:	89 81       	ldd	r24, Y+1	; 0x01
    1c06:	8a 30       	cpi	r24, 0x0A	; 10
    1c08:	39 f7       	brne	.-50     	; 0x1bd8 <UART1_receive_bytes+0x3c>
				
				buf[i] = '\0';
    1c0a:	f6 01       	movw	r30, r12
    1c0c:	ee 0d       	add	r30, r14
    1c0e:	ff 1d       	adc	r31, r15
    1c10:	10 82       	st	Z, r1
				break;
			}
		}
	}
}
    1c12:	0f 90       	pop	r0
    1c14:	df 91       	pop	r29
    1c16:	cf 91       	pop	r28
    1c18:	0f 91       	pop	r16
    1c1a:	ff 90       	pop	r15
    1c1c:	ef 90       	pop	r14
    1c1e:	df 90       	pop	r13
    1c20:	cf 90       	pop	r12
    1c22:	08 95       	ret

00001c24 <__vector_36>:

ISR(USART1_RX_vect) {
    1c24:	1f 92       	push	r1
    1c26:	0f 92       	push	r0
    1c28:	0f b6       	in	r0, 0x3f	; 63
    1c2a:	0f 92       	push	r0
    1c2c:	11 24       	eor	r1, r1
    1c2e:	0b b6       	in	r0, 0x3b	; 59
    1c30:	0f 92       	push	r0
    1c32:	2f 93       	push	r18
    1c34:	3f 93       	push	r19
    1c36:	4f 93       	push	r20
    1c38:	5f 93       	push	r21
    1c3a:	6f 93       	push	r22
    1c3c:	7f 93       	push	r23
    1c3e:	8f 93       	push	r24
    1c40:	9f 93       	push	r25
    1c42:	af 93       	push	r26
    1c44:	bf 93       	push	r27
    1c46:	ef 93       	push	r30
    1c48:	ff 93       	push	r31
    1c4a:	cf 93       	push	r28
    1c4c:	df 93       	push	r29
    1c4e:	1f 92       	push	r1
    1c50:	1f 92       	push	r1
    1c52:	cd b7       	in	r28, 0x3d	; 61
    1c54:	de b7       	in	r29, 0x3e	; 62
	uint8_t c = UDR1;
    1c56:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7c00ce>
    1c5a:	89 83       	std	Y+1, r24	; 0x01
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    1c5c:	1a 82       	std	Y+2, r1	; 0x02
	xQueueSendFromISR(uart1_rx_queue, &c, &xHigherPriorityTaskWoken);
    1c5e:	20 e0       	ldi	r18, 0x00	; 0
    1c60:	ae 01       	movw	r20, r28
    1c62:	4e 5f       	subi	r20, 0xFE	; 254
    1c64:	5f 4f       	sbci	r21, 0xFF	; 255
    1c66:	be 01       	movw	r22, r28
    1c68:	6f 5f       	subi	r22, 0xFF	; 255
    1c6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6c:	80 91 e4 1a 	lds	r24, 0x1AE4	; 0x801ae4 <uart1_rx_queue>
    1c70:	90 91 e5 1a 	lds	r25, 0x1AE5	; 0x801ae5 <uart1_rx_queue+0x1>
    1c74:	0e 94 d2 05 	call	0xba4	; 0xba4 <xQueueGenericSendFromISR>
	
	if (xHigherPriorityTaskWoken) {
    1c78:	8a 81       	ldd	r24, Y+2	; 0x02
    1c7a:	81 11       	cpse	r24, r1
		portYIELD();
    1c7c:	0e 94 26 03 	call	0x64c	; 0x64c <vPortYield>
	}
}
    1c80:	0f 90       	pop	r0
    1c82:	0f 90       	pop	r0
    1c84:	df 91       	pop	r29
    1c86:	cf 91       	pop	r28
    1c88:	ff 91       	pop	r31
    1c8a:	ef 91       	pop	r30
    1c8c:	bf 91       	pop	r27
    1c8e:	af 91       	pop	r26
    1c90:	9f 91       	pop	r25
    1c92:	8f 91       	pop	r24
    1c94:	7f 91       	pop	r23
    1c96:	6f 91       	pop	r22
    1c98:	5f 91       	pop	r21
    1c9a:	4f 91       	pop	r20
    1c9c:	3f 91       	pop	r19
    1c9e:	2f 91       	pop	r18
    1ca0:	0f 90       	pop	r0
    1ca2:	0b be       	out	0x3b, r0	; 59
    1ca4:	0f 90       	pop	r0
    1ca6:	0f be       	out	0x3f, r0	; 63
    1ca8:	0f 90       	pop	r0
    1caa:	1f 90       	pop	r1
    1cac:	18 95       	reti

00001cae <memcpy>:
    1cae:	fb 01       	movw	r30, r22
    1cb0:	dc 01       	movw	r26, r24
    1cb2:	02 c0       	rjmp	.+4      	; 0x1cb8 <memcpy+0xa>
    1cb4:	01 90       	ld	r0, Z+
    1cb6:	0d 92       	st	X+, r0
    1cb8:	41 50       	subi	r20, 0x01	; 1
    1cba:	50 40       	sbci	r21, 0x00	; 0
    1cbc:	d8 f7       	brcc	.-10     	; 0x1cb4 <memcpy+0x6>
    1cbe:	08 95       	ret

00001cc0 <_exit>:
    1cc0:	f8 94       	cli

00001cc2 <__stop_program>:
    1cc2:	ff cf       	rjmp	.-2      	; 0x1cc2 <__stop_program>
