
obc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800200  00000fce  00001062  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000fce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001803  0080021e  0080021e  00001080  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001080  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000010b0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002b0  00000000  00000000  000010f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000033fe  00000000  00000000  000013a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001338  00000000  00000000  0000479e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001e3c  00000000  00000000  00005ad6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008d8  00000000  00000000  00007914  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001375  00000000  00000000  000081ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002a60  00000000  00000000  00009561  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000290  00000000  00000000  0000bfc1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	8e c0       	rjmp	.+284    	; 0x122 <__bad_interrupt>
   6:	00 00       	nop
   8:	8c c0       	rjmp	.+280    	; 0x122 <__bad_interrupt>
   a:	00 00       	nop
   c:	8a c0       	rjmp	.+276    	; 0x122 <__bad_interrupt>
   e:	00 00       	nop
  10:	88 c0       	rjmp	.+272    	; 0x122 <__bad_interrupt>
  12:	00 00       	nop
  14:	86 c0       	rjmp	.+268    	; 0x122 <__bad_interrupt>
  16:	00 00       	nop
  18:	84 c0       	rjmp	.+264    	; 0x122 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	82 c0       	rjmp	.+260    	; 0x122 <__bad_interrupt>
  1e:	00 00       	nop
  20:	80 c0       	rjmp	.+256    	; 0x122 <__bad_interrupt>
  22:	00 00       	nop
  24:	7e c0       	rjmp	.+252    	; 0x122 <__bad_interrupt>
  26:	00 00       	nop
  28:	7c c0       	rjmp	.+248    	; 0x122 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	7a c0       	rjmp	.+244    	; 0x122 <__bad_interrupt>
  2e:	00 00       	nop
  30:	78 c0       	rjmp	.+240    	; 0x122 <__bad_interrupt>
  32:	00 00       	nop
  34:	76 c0       	rjmp	.+236    	; 0x122 <__bad_interrupt>
  36:	00 00       	nop
  38:	74 c0       	rjmp	.+232    	; 0x122 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	72 c0       	rjmp	.+228    	; 0x122 <__bad_interrupt>
  3e:	00 00       	nop
  40:	70 c0       	rjmp	.+224    	; 0x122 <__bad_interrupt>
  42:	00 00       	nop
  44:	c3 c3       	rjmp	.+1926   	; 0x7cc <__vector_17>
  46:	00 00       	nop
  48:	6c c0       	rjmp	.+216    	; 0x122 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	6a c0       	rjmp	.+212    	; 0x122 <__bad_interrupt>
  4e:	00 00       	nop
  50:	68 c0       	rjmp	.+208    	; 0x122 <__bad_interrupt>
  52:	00 00       	nop
  54:	66 c0       	rjmp	.+204    	; 0x122 <__bad_interrupt>
  56:	00 00       	nop
  58:	64 c0       	rjmp	.+200    	; 0x122 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	62 c0       	rjmp	.+196    	; 0x122 <__bad_interrupt>
  5e:	00 00       	nop
  60:	60 c0       	rjmp	.+192    	; 0x122 <__bad_interrupt>
  62:	00 00       	nop
  64:	5e c0       	rjmp	.+188    	; 0x122 <__bad_interrupt>
  66:	00 00       	nop
  68:	5c c0       	rjmp	.+184    	; 0x122 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	5a c0       	rjmp	.+180    	; 0x122 <__bad_interrupt>
  6e:	00 00       	nop
  70:	58 c0       	rjmp	.+176    	; 0x122 <__bad_interrupt>
  72:	00 00       	nop
  74:	56 c0       	rjmp	.+172    	; 0x122 <__bad_interrupt>
  76:	00 00       	nop
  78:	54 c0       	rjmp	.+168    	; 0x122 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	52 c0       	rjmp	.+164    	; 0x122 <__bad_interrupt>
  7e:	00 00       	nop
  80:	50 c0       	rjmp	.+160    	; 0x122 <__bad_interrupt>
  82:	00 00       	nop
  84:	4e c0       	rjmp	.+156    	; 0x122 <__bad_interrupt>
  86:	00 00       	nop
  88:	4c c0       	rjmp	.+152    	; 0x122 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	4a c0       	rjmp	.+148    	; 0x122 <__bad_interrupt>
  8e:	00 00       	nop
  90:	48 c0       	rjmp	.+144    	; 0x122 <__bad_interrupt>
  92:	00 00       	nop
  94:	46 c0       	rjmp	.+140    	; 0x122 <__bad_interrupt>
  96:	00 00       	nop
  98:	44 c0       	rjmp	.+136    	; 0x122 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	42 c0       	rjmp	.+132    	; 0x122 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	40 c0       	rjmp	.+128    	; 0x122 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	3e c0       	rjmp	.+124    	; 0x122 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	3c c0       	rjmp	.+120    	; 0x122 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	3a c0       	rjmp	.+116    	; 0x122 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	38 c0       	rjmp	.+112    	; 0x122 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	36 c0       	rjmp	.+108    	; 0x122 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	34 c0       	rjmp	.+104    	; 0x122 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	32 c0       	rjmp	.+100    	; 0x122 <__bad_interrupt>
  be:	00 00       	nop
  c0:	30 c0       	rjmp	.+96     	; 0x122 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	2e c0       	rjmp	.+92     	; 0x122 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	2c c0       	rjmp	.+88     	; 0x122 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	2a c0       	rjmp	.+84     	; 0x122 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	28 c0       	rjmp	.+80     	; 0x122 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	26 c0       	rjmp	.+76     	; 0x122 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	24 c0       	rjmp	.+72     	; 0x122 <__bad_interrupt>
  da:	00 00       	nop
  dc:	22 c0       	rjmp	.+68     	; 0x122 <__bad_interrupt>
  de:	00 00       	nop
  e0:	20 c0       	rjmp	.+64     	; 0x122 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	ee ec       	ldi	r30, 0xCE	; 206
  fc:	ff e0       	ldi	r31, 0x0F	; 15
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	ae 31       	cpi	r26, 0x1E	; 30
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	2a e1       	ldi	r18, 0x1A	; 26
 110:	ae e1       	ldi	r26, 0x1E	; 30
 112:	b2 e0       	ldi	r27, 0x02	; 2
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	a1 32       	cpi	r26, 0x21	; 33
 11a:	b2 07       	cpc	r27, r18
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	38 d7       	rcall	.+3696   	; 0xf90 <main>
 120:	54 c7       	rjmp	.+3752   	; 0xfca <_exit>

00000122 <__bad_interrupt>:
 122:	6e cf       	rjmp	.-292    	; 0x0 <__vectors>

00000124 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 124:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 126:	03 96       	adiw	r24, 0x03	; 3
 128:	92 83       	std	Z+2, r25	; 0x02
 12a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 12c:	4f ef       	ldi	r20, 0xFF	; 255
 12e:	5f ef       	ldi	r21, 0xFF	; 255
 130:	ba 01       	movw	r22, r20
 132:	43 83       	std	Z+3, r20	; 0x03
 134:	54 83       	std	Z+4, r21	; 0x04
 136:	65 83       	std	Z+5, r22	; 0x05
 138:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 13a:	90 87       	std	Z+8, r25	; 0x08
 13c:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 13e:	92 87       	std	Z+10, r25	; 0x0a
 140:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 142:	10 82       	st	Z, r1
 144:	08 95       	ret

00000146 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 146:	fc 01       	movw	r30, r24
 148:	13 86       	std	Z+11, r1	; 0x0b
 14a:	12 86       	std	Z+10, r1	; 0x0a
 14c:	08 95       	ret

0000014e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 14e:	cf 93       	push	r28
 150:	df 93       	push	r29
 152:	9c 01       	movw	r18, r24
 154:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 156:	dc 01       	movw	r26, r24
 158:	11 96       	adiw	r26, 0x01	; 1
 15a:	cd 91       	ld	r28, X+
 15c:	dc 91       	ld	r29, X
 15e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 160:	d5 83       	std	Z+5, r29	; 0x05
 162:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 164:	8e 81       	ldd	r24, Y+6	; 0x06
 166:	9f 81       	ldd	r25, Y+7	; 0x07
 168:	97 83       	std	Z+7, r25	; 0x07
 16a:	86 83       	std	Z+6, r24	; 0x06

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 16c:	8e 81       	ldd	r24, Y+6	; 0x06
 16e:	9f 81       	ldd	r25, Y+7	; 0x07
 170:	dc 01       	movw	r26, r24
 172:	15 96       	adiw	r26, 0x05	; 5
 174:	7c 93       	st	X, r23
 176:	6e 93       	st	-X, r22
 178:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
 17a:	7f 83       	std	Y+7, r23	; 0x07
 17c:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 17e:	33 87       	std	Z+11, r19	; 0x0b
 180:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
 182:	f9 01       	movw	r30, r18
 184:	80 81       	ld	r24, Z
 186:	8f 5f       	subi	r24, 0xFF	; 255
 188:	80 83       	st	Z, r24
}
 18a:	df 91       	pop	r29
 18c:	cf 91       	pop	r28
 18e:	08 95       	ret

00000190 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 190:	0f 93       	push	r16
 192:	1f 93       	push	r17
 194:	cf 93       	push	r28
 196:	df 93       	push	r29
 198:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 19a:	08 81       	ld	r16, Y
 19c:	19 81       	ldd	r17, Y+1	; 0x01
 19e:	2a 81       	ldd	r18, Y+2	; 0x02
 1a0:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1a2:	0f 3f       	cpi	r16, 0xFF	; 255
 1a4:	4f ef       	ldi	r20, 0xFF	; 255
 1a6:	14 07       	cpc	r17, r20
 1a8:	24 07       	cpc	r18, r20
 1aa:	34 07       	cpc	r19, r20
 1ac:	21 f4       	brne	.+8      	; 0x1b6 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1ae:	fc 01       	movw	r30, r24
 1b0:	a1 85       	ldd	r26, Z+9	; 0x09
 1b2:	b2 85       	ldd	r27, Z+10	; 0x0a
 1b4:	11 c0       	rjmp	.+34     	; 0x1d8 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1b6:	dc 01       	movw	r26, r24
 1b8:	13 96       	adiw	r26, 0x03	; 3
 1ba:	01 c0       	rjmp	.+2      	; 0x1be <vListInsert+0x2e>
 1bc:	df 01       	movw	r26, r30
 1be:	14 96       	adiw	r26, 0x04	; 4
 1c0:	ed 91       	ld	r30, X+
 1c2:	fc 91       	ld	r31, X
 1c4:	15 97       	sbiw	r26, 0x05	; 5
 1c6:	40 81       	ld	r20, Z
 1c8:	51 81       	ldd	r21, Z+1	; 0x01
 1ca:	62 81       	ldd	r22, Z+2	; 0x02
 1cc:	73 81       	ldd	r23, Z+3	; 0x03
 1ce:	04 17       	cp	r16, r20
 1d0:	15 07       	cpc	r17, r21
 1d2:	26 07       	cpc	r18, r22
 1d4:	37 07       	cpc	r19, r23
 1d6:	90 f7       	brcc	.-28     	; 0x1bc <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1d8:	14 96       	adiw	r26, 0x04	; 4
 1da:	ed 91       	ld	r30, X+
 1dc:	fc 91       	ld	r31, X
 1de:	15 97       	sbiw	r26, 0x05	; 5
 1e0:	fd 83       	std	Y+5, r31	; 0x05
 1e2:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1e4:	d7 83       	std	Z+7, r29	; 0x07
 1e6:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
 1e8:	bf 83       	std	Y+7, r27	; 0x07
 1ea:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
 1ec:	15 96       	adiw	r26, 0x05	; 5
 1ee:	dc 93       	st	X, r29
 1f0:	ce 93       	st	-X, r28
 1f2:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1f4:	9b 87       	std	Y+11, r25	; 0x0b
 1f6:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
 1f8:	fc 01       	movw	r30, r24
 1fa:	20 81       	ld	r18, Z
 1fc:	2f 5f       	subi	r18, 0xFF	; 255
 1fe:	20 83       	st	Z, r18
}
 200:	df 91       	pop	r29
 202:	cf 91       	pop	r28
 204:	1f 91       	pop	r17
 206:	0f 91       	pop	r16
 208:	08 95       	ret

0000020a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 20a:	cf 93       	push	r28
 20c:	df 93       	push	r29
 20e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 210:	a2 85       	ldd	r26, Z+10	; 0x0a
 212:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 214:	c4 81       	ldd	r28, Z+4	; 0x04
 216:	d5 81       	ldd	r29, Z+5	; 0x05
 218:	86 81       	ldd	r24, Z+6	; 0x06
 21a:	97 81       	ldd	r25, Z+7	; 0x07
 21c:	9f 83       	std	Y+7, r25	; 0x07
 21e:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 220:	c6 81       	ldd	r28, Z+6	; 0x06
 222:	d7 81       	ldd	r29, Z+7	; 0x07
 224:	84 81       	ldd	r24, Z+4	; 0x04
 226:	95 81       	ldd	r25, Z+5	; 0x05
 228:	9d 83       	std	Y+5, r25	; 0x05
 22a:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 22c:	11 96       	adiw	r26, 0x01	; 1
 22e:	8d 91       	ld	r24, X+
 230:	9c 91       	ld	r25, X
 232:	12 97       	sbiw	r26, 0x02	; 2
 234:	e8 17       	cp	r30, r24
 236:	f9 07       	cpc	r31, r25
 238:	31 f4       	brne	.+12     	; 0x246 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 23a:	86 81       	ldd	r24, Z+6	; 0x06
 23c:	97 81       	ldd	r25, Z+7	; 0x07
 23e:	12 96       	adiw	r26, 0x02	; 2
 240:	9c 93       	st	X, r25
 242:	8e 93       	st	-X, r24
 244:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 246:	13 86       	std	Z+11, r1	; 0x0b
 248:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
 24a:	8c 91       	ld	r24, X
 24c:	81 50       	subi	r24, 0x01	; 1
 24e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 250:	df 91       	pop	r29
 252:	cf 91       	pop	r28
 254:	08 95       	ret

00000256 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 256:	cf 93       	push	r28
 258:	df 93       	push	r29
uint8_t *pucAlignedHeap;
uint32_t ulAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	ulAddress = ( uint32_t ) ucHeap;
 25a:	ea e2       	ldi	r30, 0x2A	; 42
 25c:	f2 e0       	ldi	r31, 0x02	; 2

	pucAlignedHeap = ( uint8_t * ) ulAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 25e:	a6 e2       	ldi	r26, 0x26	; 38
 260:	b2 e0       	ldi	r27, 0x02	; 2
 262:	11 96       	adiw	r26, 0x01	; 1
 264:	fc 93       	st	X, r31
 266:	ee 93       	st	-X, r30
	xStart.xBlockSize = ( size_t ) 0;
 268:	13 96       	adiw	r26, 0x03	; 3
 26a:	1c 92       	st	X, r1
 26c:	1e 92       	st	-X, r1
 26e:	12 97       	sbiw	r26, 0x02	; 2

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
 270:	cf 01       	movw	r24, r30
 272:	0f 2e       	mov	r0, r31
 274:	00 0c       	add	r0, r0
 276:	aa 0b       	sbc	r26, r26
 278:	bb 0b       	sbc	r27, r27
	ulAddress -= xHeapStructSize;
 27a:	84 59       	subi	r24, 0x94	; 148
 27c:	98 4e       	sbci	r25, 0xE8	; 232
 27e:	af 4f       	sbci	r26, 0xFF	; 255
 280:	bf 4f       	sbci	r27, 0xFF	; 255
	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
	pxEnd = ( void * ) ulAddress;
 282:	ec 01       	movw	r28, r24
 284:	90 93 25 02 	sts	0x0225, r25	; 0x800225 <pxEnd+0x1>
 288:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <pxEnd>
	pxEnd->xBlockSize = 0;
 28c:	1b 82       	std	Y+3, r1	; 0x03
 28e:	1a 82       	std	Y+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
 290:	19 82       	std	Y+1, r1	; 0x01
 292:	18 82       	st	Y, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
 294:	9c 01       	movw	r18, r24
 296:	2a 52       	subi	r18, 0x2A	; 42
 298:	32 40       	sbci	r19, 0x02	; 2
 29a:	33 83       	std	Z+3, r19	; 0x03
 29c:	22 83       	std	Z+2, r18	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 29e:	91 83       	std	Z+1, r25	; 0x01
 2a0:	80 83       	st	Z, r24

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 2a2:	30 93 21 02 	sts	0x0221, r19	; 0x800221 <xMinimumEverFreeBytesRemaining+0x1>
 2a6:	20 93 20 02 	sts	0x0220, r18	; 0x800220 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 2aa:	30 93 23 02 	sts	0x0223, r19	; 0x800223 <xFreeBytesRemaining+0x1>
 2ae:	20 93 22 02 	sts	0x0222, r18	; 0x800222 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 2b2:	80 e0       	ldi	r24, 0x00	; 0
 2b4:	90 e8       	ldi	r25, 0x80	; 128
 2b6:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <__data_end+0x1>
 2ba:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <__data_end>
}
 2be:	df 91       	pop	r29
 2c0:	cf 91       	pop	r28
 2c2:	08 95       	ret

000002c4 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 2c4:	cf 93       	push	r28
 2c6:	df 93       	push	r29
 2c8:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 2ca:	a6 e2       	ldi	r26, 0x26	; 38
 2cc:	b2 e0       	ldi	r27, 0x02	; 2
 2ce:	01 c0       	rjmp	.+2      	; 0x2d2 <prvInsertBlockIntoFreeList+0xe>
 2d0:	df 01       	movw	r26, r30
 2d2:	ed 91       	ld	r30, X+
 2d4:	fc 91       	ld	r31, X
 2d6:	11 97       	sbiw	r26, 0x01	; 1
 2d8:	ec 17       	cp	r30, r28
 2da:	fd 07       	cpc	r31, r29
 2dc:	c8 f3       	brcs	.-14     	; 0x2d0 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 2de:	12 96       	adiw	r26, 0x02	; 2
 2e0:	8d 91       	ld	r24, X+
 2e2:	9c 91       	ld	r25, X
 2e4:	13 97       	sbiw	r26, 0x03	; 3
 2e6:	9d 01       	movw	r18, r26
 2e8:	28 0f       	add	r18, r24
 2ea:	39 1f       	adc	r19, r25
 2ec:	c2 17       	cp	r28, r18
 2ee:	d3 07       	cpc	r29, r19
 2f0:	49 f4       	brne	.+18     	; 0x304 <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 2f2:	2a 81       	ldd	r18, Y+2	; 0x02
 2f4:	3b 81       	ldd	r19, Y+3	; 0x03
 2f6:	82 0f       	add	r24, r18
 2f8:	93 1f       	adc	r25, r19
 2fa:	13 96       	adiw	r26, 0x03	; 3
 2fc:	9c 93       	st	X, r25
 2fe:	8e 93       	st	-X, r24
 300:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
 302:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 304:	8a 81       	ldd	r24, Y+2	; 0x02
 306:	9b 81       	ldd	r25, Y+3	; 0x03
 308:	9e 01       	movw	r18, r28
 30a:	28 0f       	add	r18, r24
 30c:	39 1f       	adc	r19, r25
 30e:	e2 17       	cp	r30, r18
 310:	f3 07       	cpc	r31, r19
 312:	c1 f4       	brne	.+48     	; 0x344 <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 314:	20 91 24 02 	lds	r18, 0x0224	; 0x800224 <pxEnd>
 318:	30 91 25 02 	lds	r19, 0x0225	; 0x800225 <pxEnd+0x1>
 31c:	e2 17       	cp	r30, r18
 31e:	f3 07       	cpc	r31, r19
 320:	71 f0       	breq	.+28     	; 0x33e <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 322:	22 81       	ldd	r18, Z+2	; 0x02
 324:	33 81       	ldd	r19, Z+3	; 0x03
 326:	82 0f       	add	r24, r18
 328:	93 1f       	adc	r25, r19
 32a:	9b 83       	std	Y+3, r25	; 0x03
 32c:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 32e:	ed 91       	ld	r30, X+
 330:	fc 91       	ld	r31, X
 332:	11 97       	sbiw	r26, 0x01	; 1
 334:	80 81       	ld	r24, Z
 336:	91 81       	ldd	r25, Z+1	; 0x01
 338:	99 83       	std	Y+1, r25	; 0x01
 33a:	88 83       	st	Y, r24
 33c:	05 c0       	rjmp	.+10     	; 0x348 <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 33e:	39 83       	std	Y+1, r19	; 0x01
 340:	28 83       	st	Y, r18
 342:	02 c0       	rjmp	.+4      	; 0x348 <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 344:	f9 83       	std	Y+1, r31	; 0x01
 346:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 348:	ca 17       	cp	r28, r26
 34a:	db 07       	cpc	r29, r27
 34c:	11 f0       	breq	.+4      	; 0x352 <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 34e:	cd 93       	st	X+, r28
 350:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 352:	df 91       	pop	r29
 354:	cf 91       	pop	r28
 356:	08 95       	ret

00000358 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 358:	ef 92       	push	r14
 35a:	ff 92       	push	r15
 35c:	0f 93       	push	r16
 35e:	1f 93       	push	r17
 360:	cf 93       	push	r28
 362:	df 93       	push	r29
 364:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 366:	47 d4       	rcall	.+2190   	; 0xbf6 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 368:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <pxEnd>
 36c:	90 91 25 02 	lds	r25, 0x0225	; 0x800225 <pxEnd+0x1>
 370:	89 2b       	or	r24, r25
		{
			prvHeapInit();
 372:	09 f4       	brne	.+2      	; 0x376 <pvPortMalloc+0x1e>
 374:	70 df       	rcall	.-288    	; 0x256 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 376:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <__data_end>
 37a:	90 91 1f 02 	lds	r25, 0x021F	; 0x80021f <__data_end+0x1>
 37e:	80 23       	and	r24, r16
 380:	91 23       	and	r25, r17
 382:	89 2b       	or	r24, r25
 384:	09 f0       	breq	.+2      	; 0x388 <pvPortMalloc+0x30>
 386:	66 c0       	rjmp	.+204    	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 388:	01 15       	cp	r16, r1
 38a:	11 05       	cpc	r17, r1
 38c:	11 f0       	breq	.+4      	; 0x392 <pvPortMalloc+0x3a>
			{
				xWantedSize += xHeapStructSize;
 38e:	0c 5f       	subi	r16, 0xFC	; 252
 390:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 392:	01 15       	cp	r16, r1
 394:	11 05       	cpc	r17, r1
 396:	09 f4       	brne	.+2      	; 0x39a <pvPortMalloc+0x42>
 398:	60 c0       	rjmp	.+192    	; 0x45a <__LOCK_REGION_LENGTH__+0x5a>
 39a:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <xFreeBytesRemaining>
 39e:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <xFreeBytesRemaining+0x1>
 3a2:	80 17       	cp	r24, r16
 3a4:	91 07       	cpc	r25, r17
 3a6:	08 f4       	brcc	.+2      	; 0x3aa <pvPortMalloc+0x52>
 3a8:	5b c0       	rjmp	.+182    	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 3aa:	c0 91 26 02 	lds	r28, 0x0226	; 0x800226 <xStart>
 3ae:	d0 91 27 02 	lds	r29, 0x0227	; 0x800227 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 3b2:	e6 e2       	ldi	r30, 0x26	; 38
 3b4:	f2 e0       	ldi	r31, 0x02	; 2
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 3b6:	02 c0       	rjmp	.+4      	; 0x3bc <pvPortMalloc+0x64>
				{
					pxPreviousBlock = pxBlock;
 3b8:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
 3ba:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 3bc:	8a 81       	ldd	r24, Y+2	; 0x02
 3be:	9b 81       	ldd	r25, Y+3	; 0x03
 3c0:	80 17       	cp	r24, r16
 3c2:	91 07       	cpc	r25, r17
 3c4:	20 f4       	brcc	.+8      	; 0x3ce <pvPortMalloc+0x76>
 3c6:	88 81       	ld	r24, Y
 3c8:	99 81       	ldd	r25, Y+1	; 0x01
 3ca:	00 97       	sbiw	r24, 0x00	; 0
 3cc:	a9 f7       	brne	.-22     	; 0x3b8 <pvPortMalloc+0x60>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 3ce:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <pxEnd>
 3d2:	90 91 25 02 	lds	r25, 0x0225	; 0x800225 <pxEnd+0x1>
 3d6:	c8 17       	cp	r28, r24
 3d8:	d9 07       	cpc	r29, r25
 3da:	09 f4       	brne	.+2      	; 0x3de <pvPortMalloc+0x86>
 3dc:	44 c0       	rjmp	.+136    	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 3de:	e0 80       	ld	r14, Z
 3e0:	f1 80       	ldd	r15, Z+1	; 0x01
 3e2:	84 e0       	ldi	r24, 0x04	; 4
 3e4:	e8 0e       	add	r14, r24
 3e6:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 3e8:	88 81       	ld	r24, Y
 3ea:	99 81       	ldd	r25, Y+1	; 0x01
 3ec:	91 83       	std	Z+1, r25	; 0x01
 3ee:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 3f0:	2a 81       	ldd	r18, Y+2	; 0x02
 3f2:	3b 81       	ldd	r19, Y+3	; 0x03
 3f4:	20 1b       	sub	r18, r16
 3f6:	31 0b       	sbc	r19, r17
 3f8:	29 30       	cpi	r18, 0x09	; 9
 3fa:	31 05       	cpc	r19, r1
 3fc:	48 f0       	brcs	.+18     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 3fe:	ce 01       	movw	r24, r28
 400:	80 0f       	add	r24, r16
 402:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 404:	fc 01       	movw	r30, r24
 406:	33 83       	std	Z+3, r19	; 0x03
 408:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
 40a:	1b 83       	std	Y+3, r17	; 0x03

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 40c:	0a 83       	std	Y+2, r16	; 0x02
 40e:	5a df       	rcall	.-332    	; 0x2c4 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 410:	2a 81       	ldd	r18, Y+2	; 0x02
 412:	3b 81       	ldd	r19, Y+3	; 0x03
 414:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <xFreeBytesRemaining>
 418:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <xFreeBytesRemaining+0x1>
 41c:	82 1b       	sub	r24, r18
 41e:	93 0b       	sbc	r25, r19
 420:	90 93 23 02 	sts	0x0223, r25	; 0x800223 <xFreeBytesRemaining+0x1>
 424:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 428:	40 91 20 02 	lds	r20, 0x0220	; 0x800220 <xMinimumEverFreeBytesRemaining>
 42c:	50 91 21 02 	lds	r21, 0x0221	; 0x800221 <xMinimumEverFreeBytesRemaining+0x1>
 430:	84 17       	cp	r24, r20
 432:	95 07       	cpc	r25, r21
 434:	20 f4       	brcc	.+8      	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 436:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <xMinimumEverFreeBytesRemaining+0x1>
 43a:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 43e:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <__data_end>
 442:	90 91 1f 02 	lds	r25, 0x021F	; 0x80021f <__data_end+0x1>
 446:	28 2b       	or	r18, r24
 448:	39 2b       	or	r19, r25
 44a:	3b 83       	std	Y+3, r19	; 0x03
 44c:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
 44e:	19 82       	std	Y+1, r1	; 0x01
 450:	18 82       	st	Y, r1
 452:	0b c0       	rjmp	.+22     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 454:	e1 2c       	mov	r14, r1
 456:	f1 2c       	mov	r15, r1
 458:	08 c0       	rjmp	.+16     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
 45a:	e1 2c       	mov	r14, r1
 45c:	f1 2c       	mov	r15, r1
 45e:	05 c0       	rjmp	.+10     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
 460:	e1 2c       	mov	r14, r1
 462:	f1 2c       	mov	r15, r1
 464:	02 c0       	rjmp	.+4      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
 466:	e1 2c       	mov	r14, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 468:	f1 2c       	mov	r15, r1
 46a:	97 d4       	rcall	.+2350   	; 0xd9a <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 46c:	c7 01       	movw	r24, r14
 46e:	df 91       	pop	r29
 470:	cf 91       	pop	r28
 472:	1f 91       	pop	r17
 474:	0f 91       	pop	r16
 476:	ff 90       	pop	r15
 478:	ef 90       	pop	r14
 47a:	08 95       	ret

0000047c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 47c:	0f 93       	push	r16
 47e:	1f 93       	push	r17
 480:	cf 93       	push	r28
 482:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 484:	00 97       	sbiw	r24, 0x00	; 0
 486:	39 f1       	breq	.+78     	; 0x4d6 <vPortFree+0x5a>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
 488:	ec 01       	movw	r28, r24
 48a:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 48c:	4a 81       	ldd	r20, Y+2	; 0x02
 48e:	5b 81       	ldd	r21, Y+3	; 0x03
 490:	20 91 1e 02 	lds	r18, 0x021E	; 0x80021e <__data_end>
 494:	30 91 1f 02 	lds	r19, 0x021F	; 0x80021f <__data_end+0x1>
 498:	ba 01       	movw	r22, r20
 49a:	62 23       	and	r22, r18
 49c:	73 23       	and	r23, r19
 49e:	67 2b       	or	r22, r23
 4a0:	d1 f0       	breq	.+52     	; 0x4d6 <vPortFree+0x5a>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 4a2:	68 81       	ld	r22, Y
 4a4:	79 81       	ldd	r23, Y+1	; 0x01
 4a6:	67 2b       	or	r22, r23
 4a8:	b1 f4       	brne	.+44     	; 0x4d6 <vPortFree+0x5a>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 4aa:	20 95       	com	r18
 4ac:	30 95       	com	r19
 4ae:	24 23       	and	r18, r20
 4b0:	35 23       	and	r19, r21
 4b2:	3b 83       	std	Y+3, r19	; 0x03
 4b4:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
 4b6:	9f d3       	rcall	.+1854   	; 0xbf6 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 4b8:	8a 81       	ldd	r24, Y+2	; 0x02
 4ba:	9b 81       	ldd	r25, Y+3	; 0x03
 4bc:	20 91 22 02 	lds	r18, 0x0222	; 0x800222 <xFreeBytesRemaining>
 4c0:	30 91 23 02 	lds	r19, 0x0223	; 0x800223 <xFreeBytesRemaining+0x1>
 4c4:	82 0f       	add	r24, r18
 4c6:	93 1f       	adc	r25, r19
 4c8:	90 93 23 02 	sts	0x0223, r25	; 0x800223 <xFreeBytesRemaining+0x1>
 4cc:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 4d0:	ce 01       	movw	r24, r28
				}
				( void ) xTaskResumeAll();
 4d2:	f8 de       	rcall	.-528    	; 0x2c4 <prvInsertBlockIntoFreeList>
 4d4:	62 d4       	rcall	.+2244   	; 0xd9a <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 4d6:	df 91       	pop	r29
 4d8:	cf 91       	pop	r28
 4da:	1f 91       	pop	r17
 4dc:	0f 91       	pop	r16
 4de:	08 95       	ret

000004e0 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 4e0:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7c0089>
 4e4:	89 ef       	ldi	r24, 0xF9	; 249
 4e6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7c0088>
 4ea:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7c0080>
 4ee:	8b e0       	ldi	r24, 0x0B	; 11
 4f0:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7c0081>
 4f4:	ef e6       	ldi	r30, 0x6F	; 111
 4f6:	f0 e0       	ldi	r31, 0x00	; 0
 4f8:	80 81       	ld	r24, Z
 4fa:	82 60       	ori	r24, 0x02	; 2
 4fc:	80 83       	st	Z, r24
 4fe:	08 95       	ret

00000500 <pxPortInitialiseStack>:
 500:	31 e1       	ldi	r19, 0x11	; 17
 502:	fc 01       	movw	r30, r24
 504:	30 83       	st	Z, r19
 506:	31 97       	sbiw	r30, 0x01	; 1
 508:	22 e2       	ldi	r18, 0x22	; 34
 50a:	20 83       	st	Z, r18
 50c:	31 97       	sbiw	r30, 0x01	; 1
 50e:	a3 e3       	ldi	r26, 0x33	; 51
 510:	a0 83       	st	Z, r26
 512:	31 97       	sbiw	r30, 0x01	; 1
 514:	60 83       	st	Z, r22
 516:	31 97       	sbiw	r30, 0x01	; 1
 518:	70 83       	st	Z, r23
 51a:	31 97       	sbiw	r30, 0x01	; 1
 51c:	10 82       	st	Z, r1
 51e:	31 97       	sbiw	r30, 0x01	; 1
 520:	10 82       	st	Z, r1
 522:	31 97       	sbiw	r30, 0x01	; 1
 524:	60 e8       	ldi	r22, 0x80	; 128
 526:	60 83       	st	Z, r22
 528:	31 97       	sbiw	r30, 0x01	; 1
 52a:	10 82       	st	Z, r1
 52c:	31 97       	sbiw	r30, 0x01	; 1
 52e:	10 82       	st	Z, r1
 530:	31 97       	sbiw	r30, 0x01	; 1
 532:	10 82       	st	Z, r1
 534:	31 97       	sbiw	r30, 0x01	; 1
 536:	62 e0       	ldi	r22, 0x02	; 2
 538:	60 83       	st	Z, r22
 53a:	31 97       	sbiw	r30, 0x01	; 1
 53c:	63 e0       	ldi	r22, 0x03	; 3
 53e:	60 83       	st	Z, r22
 540:	31 97       	sbiw	r30, 0x01	; 1
 542:	64 e0       	ldi	r22, 0x04	; 4
 544:	60 83       	st	Z, r22
 546:	31 97       	sbiw	r30, 0x01	; 1
 548:	65 e0       	ldi	r22, 0x05	; 5
 54a:	60 83       	st	Z, r22
 54c:	31 97       	sbiw	r30, 0x01	; 1
 54e:	66 e0       	ldi	r22, 0x06	; 6
 550:	60 83       	st	Z, r22
 552:	31 97       	sbiw	r30, 0x01	; 1
 554:	67 e0       	ldi	r22, 0x07	; 7
 556:	60 83       	st	Z, r22
 558:	31 97       	sbiw	r30, 0x01	; 1
 55a:	68 e0       	ldi	r22, 0x08	; 8
 55c:	60 83       	st	Z, r22
 55e:	31 97       	sbiw	r30, 0x01	; 1
 560:	69 e0       	ldi	r22, 0x09	; 9
 562:	60 83       	st	Z, r22
 564:	31 97       	sbiw	r30, 0x01	; 1
 566:	60 e1       	ldi	r22, 0x10	; 16
 568:	60 83       	st	Z, r22
 56a:	31 97       	sbiw	r30, 0x01	; 1
 56c:	30 83       	st	Z, r19
 56e:	31 97       	sbiw	r30, 0x01	; 1
 570:	32 e1       	ldi	r19, 0x12	; 18
 572:	30 83       	st	Z, r19
 574:	31 97       	sbiw	r30, 0x01	; 1
 576:	33 e1       	ldi	r19, 0x13	; 19
 578:	30 83       	st	Z, r19
 57a:	31 97       	sbiw	r30, 0x01	; 1
 57c:	34 e1       	ldi	r19, 0x14	; 20
 57e:	30 83       	st	Z, r19
 580:	31 97       	sbiw	r30, 0x01	; 1
 582:	35 e1       	ldi	r19, 0x15	; 21
 584:	30 83       	st	Z, r19
 586:	31 97       	sbiw	r30, 0x01	; 1
 588:	36 e1       	ldi	r19, 0x16	; 22
 58a:	30 83       	st	Z, r19
 58c:	31 97       	sbiw	r30, 0x01	; 1
 58e:	37 e1       	ldi	r19, 0x17	; 23
 590:	30 83       	st	Z, r19
 592:	31 97       	sbiw	r30, 0x01	; 1
 594:	38 e1       	ldi	r19, 0x18	; 24
 596:	30 83       	st	Z, r19
 598:	31 97       	sbiw	r30, 0x01	; 1
 59a:	39 e1       	ldi	r19, 0x19	; 25
 59c:	30 83       	st	Z, r19
 59e:	31 97       	sbiw	r30, 0x01	; 1
 5a0:	30 e2       	ldi	r19, 0x20	; 32
 5a2:	30 83       	st	Z, r19
 5a4:	31 97       	sbiw	r30, 0x01	; 1
 5a6:	31 e2       	ldi	r19, 0x21	; 33
 5a8:	30 83       	st	Z, r19
 5aa:	31 97       	sbiw	r30, 0x01	; 1
 5ac:	20 83       	st	Z, r18
 5ae:	31 97       	sbiw	r30, 0x01	; 1
 5b0:	23 e2       	ldi	r18, 0x23	; 35
 5b2:	20 83       	st	Z, r18
 5b4:	31 97       	sbiw	r30, 0x01	; 1
 5b6:	40 83       	st	Z, r20
 5b8:	31 97       	sbiw	r30, 0x01	; 1
 5ba:	50 83       	st	Z, r21
 5bc:	31 97       	sbiw	r30, 0x01	; 1
 5be:	26 e2       	ldi	r18, 0x26	; 38
 5c0:	20 83       	st	Z, r18
 5c2:	31 97       	sbiw	r30, 0x01	; 1
 5c4:	27 e2       	ldi	r18, 0x27	; 39
 5c6:	20 83       	st	Z, r18
 5c8:	31 97       	sbiw	r30, 0x01	; 1
 5ca:	28 e2       	ldi	r18, 0x28	; 40
 5cc:	20 83       	st	Z, r18
 5ce:	31 97       	sbiw	r30, 0x01	; 1
 5d0:	29 e2       	ldi	r18, 0x29	; 41
 5d2:	20 83       	st	Z, r18
 5d4:	31 97       	sbiw	r30, 0x01	; 1
 5d6:	20 e3       	ldi	r18, 0x30	; 48
 5d8:	20 83       	st	Z, r18
 5da:	31 97       	sbiw	r30, 0x01	; 1
 5dc:	21 e3       	ldi	r18, 0x31	; 49
 5de:	20 83       	st	Z, r18
 5e0:	89 97       	sbiw	r24, 0x29	; 41
 5e2:	08 95       	ret

000005e4 <xPortStartScheduler>:
 5e4:	7d df       	rcall	.-262    	; 0x4e0 <prvSetupTimerInterrupt>
 5e6:	a0 91 1f 1a 	lds	r26, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 5ea:	b0 91 20 1a 	lds	r27, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 5ee:	cd 91       	ld	r28, X+
 5f0:	cd bf       	out	0x3d, r28	; 61
 5f2:	dd 91       	ld	r29, X+
 5f4:	de bf       	out	0x3e, r29	; 62
 5f6:	ff 91       	pop	r31
 5f8:	ef 91       	pop	r30
 5fa:	df 91       	pop	r29
 5fc:	cf 91       	pop	r28
 5fe:	bf 91       	pop	r27
 600:	af 91       	pop	r26
 602:	9f 91       	pop	r25
 604:	8f 91       	pop	r24
 606:	7f 91       	pop	r23
 608:	6f 91       	pop	r22
 60a:	5f 91       	pop	r21
 60c:	4f 91       	pop	r20
 60e:	3f 91       	pop	r19
 610:	2f 91       	pop	r18
 612:	1f 91       	pop	r17
 614:	0f 91       	pop	r16
 616:	ff 90       	pop	r15
 618:	ef 90       	pop	r14
 61a:	df 90       	pop	r13
 61c:	cf 90       	pop	r12
 61e:	bf 90       	pop	r11
 620:	af 90       	pop	r10
 622:	9f 90       	pop	r9
 624:	8f 90       	pop	r8
 626:	7f 90       	pop	r7
 628:	6f 90       	pop	r6
 62a:	5f 90       	pop	r5
 62c:	4f 90       	pop	r4
 62e:	3f 90       	pop	r3
 630:	2f 90       	pop	r2
 632:	1f 90       	pop	r1
 634:	0f 90       	pop	r0
 636:	0c be       	out	0x3c, r0	; 60
 638:	0f 90       	pop	r0
 63a:	0b be       	out	0x3b, r0	; 59
 63c:	0f 90       	pop	r0
 63e:	0f be       	out	0x3f, r0	; 63
 640:	0f 90       	pop	r0
 642:	08 95       	ret
 644:	81 e0       	ldi	r24, 0x01	; 1
 646:	08 95       	ret

00000648 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 648:	0f 92       	push	r0
 64a:	0f b6       	in	r0, 0x3f	; 63
 64c:	f8 94       	cli
 64e:	0f 92       	push	r0
 650:	0b b6       	in	r0, 0x3b	; 59
 652:	0f 92       	push	r0
 654:	0c b6       	in	r0, 0x3c	; 60
 656:	0f 92       	push	r0
 658:	1f 92       	push	r1
 65a:	11 24       	eor	r1, r1
 65c:	2f 92       	push	r2
 65e:	3f 92       	push	r3
 660:	4f 92       	push	r4
 662:	5f 92       	push	r5
 664:	6f 92       	push	r6
 666:	7f 92       	push	r7
 668:	8f 92       	push	r8
 66a:	9f 92       	push	r9
 66c:	af 92       	push	r10
 66e:	bf 92       	push	r11
 670:	cf 92       	push	r12
 672:	df 92       	push	r13
 674:	ef 92       	push	r14
 676:	ff 92       	push	r15
 678:	0f 93       	push	r16
 67a:	1f 93       	push	r17
 67c:	2f 93       	push	r18
 67e:	3f 93       	push	r19
 680:	4f 93       	push	r20
 682:	5f 93       	push	r21
 684:	6f 93       	push	r22
 686:	7f 93       	push	r23
 688:	8f 93       	push	r24
 68a:	9f 93       	push	r25
 68c:	af 93       	push	r26
 68e:	bf 93       	push	r27
 690:	cf 93       	push	r28
 692:	df 93       	push	r29
 694:	ef 93       	push	r30
 696:	ff 93       	push	r31
 698:	a0 91 1f 1a 	lds	r26, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 69c:	b0 91 20 1a 	lds	r27, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 6a0:	0d b6       	in	r0, 0x3d	; 61
 6a2:	0d 92       	st	X+, r0
 6a4:	0e b6       	in	r0, 0x3e	; 62
 6a6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 6a8:	29 d4       	rcall	.+2130   	; 0xefc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 6aa:	a0 91 1f 1a 	lds	r26, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 6ae:	b0 91 20 1a 	lds	r27, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 6b2:	cd 91       	ld	r28, X+
 6b4:	cd bf       	out	0x3d, r28	; 61
 6b6:	dd 91       	ld	r29, X+
 6b8:	de bf       	out	0x3e, r29	; 62
 6ba:	ff 91       	pop	r31
 6bc:	ef 91       	pop	r30
 6be:	df 91       	pop	r29
 6c0:	cf 91       	pop	r28
 6c2:	bf 91       	pop	r27
 6c4:	af 91       	pop	r26
 6c6:	9f 91       	pop	r25
 6c8:	8f 91       	pop	r24
 6ca:	7f 91       	pop	r23
 6cc:	6f 91       	pop	r22
 6ce:	5f 91       	pop	r21
 6d0:	4f 91       	pop	r20
 6d2:	3f 91       	pop	r19
 6d4:	2f 91       	pop	r18
 6d6:	1f 91       	pop	r17
 6d8:	0f 91       	pop	r16
 6da:	ff 90       	pop	r15
 6dc:	ef 90       	pop	r14
 6de:	df 90       	pop	r13
 6e0:	cf 90       	pop	r12
 6e2:	bf 90       	pop	r11
 6e4:	af 90       	pop	r10
 6e6:	9f 90       	pop	r9
 6e8:	8f 90       	pop	r8
 6ea:	7f 90       	pop	r7
 6ec:	6f 90       	pop	r6
 6ee:	5f 90       	pop	r5
 6f0:	4f 90       	pop	r4
 6f2:	3f 90       	pop	r3
 6f4:	2f 90       	pop	r2
 6f6:	1f 90       	pop	r1
 6f8:	0f 90       	pop	r0
 6fa:	0c be       	out	0x3c, r0	; 60
 6fc:	0f 90       	pop	r0
 6fe:	0b be       	out	0x3b, r0	; 59
 700:	0f 90       	pop	r0
 702:	0f be       	out	0x3f, r0	; 63
 704:	0f 90       	pop	r0

	asm volatile ( "ret" );
 706:	08 95       	ret

00000708 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 708:	0f 92       	push	r0
 70a:	0f b6       	in	r0, 0x3f	; 63
 70c:	f8 94       	cli
 70e:	0f 92       	push	r0
 710:	0b b6       	in	r0, 0x3b	; 59
 712:	0f 92       	push	r0
 714:	0c b6       	in	r0, 0x3c	; 60
 716:	0f 92       	push	r0
 718:	1f 92       	push	r1
 71a:	11 24       	eor	r1, r1
 71c:	2f 92       	push	r2
 71e:	3f 92       	push	r3
 720:	4f 92       	push	r4
 722:	5f 92       	push	r5
 724:	6f 92       	push	r6
 726:	7f 92       	push	r7
 728:	8f 92       	push	r8
 72a:	9f 92       	push	r9
 72c:	af 92       	push	r10
 72e:	bf 92       	push	r11
 730:	cf 92       	push	r12
 732:	df 92       	push	r13
 734:	ef 92       	push	r14
 736:	ff 92       	push	r15
 738:	0f 93       	push	r16
 73a:	1f 93       	push	r17
 73c:	2f 93       	push	r18
 73e:	3f 93       	push	r19
 740:	4f 93       	push	r20
 742:	5f 93       	push	r21
 744:	6f 93       	push	r22
 746:	7f 93       	push	r23
 748:	8f 93       	push	r24
 74a:	9f 93       	push	r25
 74c:	af 93       	push	r26
 74e:	bf 93       	push	r27
 750:	cf 93       	push	r28
 752:	df 93       	push	r29
 754:	ef 93       	push	r30
 756:	ff 93       	push	r31
 758:	a0 91 1f 1a 	lds	r26, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 75c:	b0 91 20 1a 	lds	r27, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 760:	0d b6       	in	r0, 0x3d	; 61
 762:	0d 92       	st	X+, r0
 764:	0e b6       	in	r0, 0x3e	; 62
 766:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 768:	4c d2       	rcall	.+1176   	; 0xc02 <xTaskIncrementTick>
 76a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 76c:	c7 d3       	rcall	.+1934   	; 0xefc <vTaskSwitchContext>
 76e:	a0 91 1f 1a 	lds	r26, 0x1A1F	; 0x801a1f <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
 772:	b0 91 20 1a 	lds	r27, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 776:	cd 91       	ld	r28, X+
 778:	cd bf       	out	0x3d, r28	; 61
 77a:	dd 91       	ld	r29, X+
 77c:	de bf       	out	0x3e, r29	; 62
 77e:	ff 91       	pop	r31
 780:	ef 91       	pop	r30
 782:	df 91       	pop	r29
 784:	cf 91       	pop	r28
 786:	bf 91       	pop	r27
 788:	af 91       	pop	r26
 78a:	9f 91       	pop	r25
 78c:	8f 91       	pop	r24
 78e:	7f 91       	pop	r23
 790:	6f 91       	pop	r22
 792:	5f 91       	pop	r21
 794:	4f 91       	pop	r20
 796:	3f 91       	pop	r19
 798:	2f 91       	pop	r18
 79a:	1f 91       	pop	r17
 79c:	0f 91       	pop	r16
 79e:	ff 90       	pop	r15
 7a0:	ef 90       	pop	r14
 7a2:	df 90       	pop	r13
 7a4:	cf 90       	pop	r12
 7a6:	bf 90       	pop	r11
 7a8:	af 90       	pop	r10
 7aa:	9f 90       	pop	r9
 7ac:	8f 90       	pop	r8
 7ae:	7f 90       	pop	r7
 7b0:	6f 90       	pop	r6
 7b2:	5f 90       	pop	r5
 7b4:	4f 90       	pop	r4
 7b6:	3f 90       	pop	r3
 7b8:	2f 90       	pop	r2
 7ba:	1f 90       	pop	r1
 7bc:	0f 90       	pop	r0
 7be:	0c be       	out	0x3c, r0	; 60
 7c0:	0f 90       	pop	r0
 7c2:	0b be       	out	0x3b, r0	; 59
 7c4:	0f 90       	pop	r0
 7c6:	0f be       	out	0x3f, r0	; 63
 7c8:	0f 90       	pop	r0
 7ca:	08 95       	ret

000007cc <__vector_17>:

	asm volatile ( "ret" );
 7cc:	9d df       	rcall	.-198    	; 0x708 <vPortYieldFromTick>
	 */
	ISR(TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR(TIMER1_COMPA_vect)
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
 7ce:	18 95       	reti

000007d0 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 7d0:	e0 91 d0 19 	lds	r30, 0x19D0	; 0x8019d0 <pxDelayedTaskList>
 7d4:	f0 91 d1 19 	lds	r31, 0x19D1	; 0x8019d1 <pxDelayedTaskList+0x1>
 7d8:	80 81       	ld	r24, Z
 7da:	81 11       	cpse	r24, r1
 7dc:	0c c0       	rjmp	.+24     	; 0x7f6 <prvResetNextTaskUnblockTime+0x26>
 7de:	8f ef       	ldi	r24, 0xFF	; 255
 7e0:	9f ef       	ldi	r25, 0xFF	; 255
 7e2:	dc 01       	movw	r26, r24
 7e4:	80 93 9d 19 	sts	0x199D, r24	; 0x80199d <xNextTaskUnblockTime>
 7e8:	90 93 9e 19 	sts	0x199E, r25	; 0x80199e <xNextTaskUnblockTime+0x1>
 7ec:	a0 93 9f 19 	sts	0x199F, r26	; 0x80199f <xNextTaskUnblockTime+0x2>
 7f0:	b0 93 a0 19 	sts	0x19A0, r27	; 0x8019a0 <xNextTaskUnblockTime+0x3>
 7f4:	08 95       	ret
 7f6:	e0 91 d0 19 	lds	r30, 0x19D0	; 0x8019d0 <pxDelayedTaskList>
 7fa:	f0 91 d1 19 	lds	r31, 0x19D1	; 0x8019d1 <pxDelayedTaskList+0x1>
 7fe:	07 80       	ldd	r0, Z+7	; 0x07
 800:	f0 85       	ldd	r31, Z+8	; 0x08
 802:	e0 2d       	mov	r30, r0
 804:	00 84       	ldd	r0, Z+8	; 0x08
 806:	f1 85       	ldd	r31, Z+9	; 0x09
 808:	e0 2d       	mov	r30, r0
 80a:	82 81       	ldd	r24, Z+2	; 0x02
 80c:	93 81       	ldd	r25, Z+3	; 0x03
 80e:	a4 81       	ldd	r26, Z+4	; 0x04
 810:	b5 81       	ldd	r27, Z+5	; 0x05
 812:	80 93 9d 19 	sts	0x199D, r24	; 0x80199d <xNextTaskUnblockTime>
 816:	90 93 9e 19 	sts	0x199E, r25	; 0x80199e <xNextTaskUnblockTime+0x1>
 81a:	a0 93 9f 19 	sts	0x199F, r26	; 0x80199f <xNextTaskUnblockTime+0x2>
 81e:	b0 93 a0 19 	sts	0x19A0, r27	; 0x8019a0 <xNextTaskUnblockTime+0x3>
 822:	08 95       	ret

00000824 <prvDeleteTCB>:
 824:	cf 93       	push	r28
 826:	df 93       	push	r29
 828:	ec 01       	movw	r28, r24
 82a:	8b 8d       	ldd	r24, Y+27	; 0x1b
 82c:	9c 8d       	ldd	r25, Y+28	; 0x1c
 82e:	26 de       	rcall	.-948    	; 0x47c <vPortFree>
 830:	ce 01       	movw	r24, r28
 832:	24 de       	rcall	.-952    	; 0x47c <vPortFree>
 834:	df 91       	pop	r29
 836:	cf 91       	pop	r28
 838:	08 95       	ret

0000083a <prvInitialiseNewTask>:
 83a:	6f 92       	push	r6
 83c:	7f 92       	push	r7
 83e:	8f 92       	push	r8
 840:	9f 92       	push	r9
 842:	af 92       	push	r10
 844:	bf 92       	push	r11
 846:	cf 92       	push	r12
 848:	df 92       	push	r13
 84a:	ef 92       	push	r14
 84c:	0f 93       	push	r16
 84e:	1f 93       	push	r17
 850:	cf 93       	push	r28
 852:	df 93       	push	r29
 854:	cd b7       	in	r28, 0x3d	; 61
 856:	de b7       	in	r29, 0x3e	; 62
 858:	4c 01       	movw	r8, r24
 85a:	f5 01       	movw	r30, r10
 85c:	83 8d       	ldd	r24, Z+27	; 0x1b
 85e:	94 8d       	ldd	r25, Z+28	; 0x1c
 860:	21 50       	subi	r18, 0x01	; 1
 862:	31 09       	sbc	r19, r1
 864:	3c 01       	movw	r6, r24
 866:	62 0e       	add	r6, r18
 868:	73 1e       	adc	r7, r19
 86a:	20 e0       	ldi	r18, 0x00	; 0
 86c:	0f c0       	rjmp	.+30     	; 0x88c <prvInitialiseNewTask+0x52>
 86e:	82 2f       	mov	r24, r18
 870:	90 e0       	ldi	r25, 0x00	; 0
 872:	fb 01       	movw	r30, r22
 874:	e8 0f       	add	r30, r24
 876:	f9 1f       	adc	r31, r25
 878:	30 81       	ld	r19, Z
 87a:	d5 01       	movw	r26, r10
 87c:	a8 0f       	add	r26, r24
 87e:	b9 1f       	adc	r27, r25
 880:	5d 96       	adiw	r26, 0x1d	; 29
 882:	3c 93       	st	X, r19
 884:	80 81       	ld	r24, Z
 886:	88 23       	and	r24, r24
 888:	19 f0       	breq	.+6      	; 0x890 <prvInitialiseNewTask+0x56>
 88a:	2f 5f       	subi	r18, 0xFF	; 255
 88c:	24 31       	cpi	r18, 0x14	; 20
 88e:	78 f3       	brcs	.-34     	; 0x86e <prvInitialiseNewTask+0x34>
 890:	f5 01       	movw	r30, r10
 892:	10 aa       	std	Z+48, r1	; 0x30
 894:	f4 e0       	ldi	r31, 0x04	; 4
 896:	fe 15       	cp	r31, r14
 898:	18 f4       	brcc	.+6      	; 0x8a0 <prvInitialiseNewTask+0x66>
 89a:	68 94       	set
 89c:	ee 24       	eor	r14, r14
 89e:	e2 f8       	bld	r14, 2
 8a0:	f5 01       	movw	r30, r10
 8a2:	e2 8e       	std	Z+26, r14	; 0x1a
 8a4:	e1 aa       	std	Z+49, r14	; 0x31
 8a6:	12 aa       	std	Z+50, r1	; 0x32
 8a8:	c5 01       	movw	r24, r10
 8aa:	02 96       	adiw	r24, 0x02	; 2
 8ac:	4c dc       	rcall	.-1896   	; 0x146 <vListInitialiseItem>
 8ae:	c5 01       	movw	r24, r10
 8b0:	0e 96       	adiw	r24, 0x0e	; 14
 8b2:	49 dc       	rcall	.-1902   	; 0x146 <vListInitialiseItem>
 8b4:	f5 01       	movw	r30, r10
 8b6:	b3 86       	std	Z+11, r11	; 0x0b
 8b8:	a2 86       	std	Z+10, r10	; 0x0a
 8ba:	85 e0       	ldi	r24, 0x05	; 5
 8bc:	90 e0       	ldi	r25, 0x00	; 0
 8be:	a0 e0       	ldi	r26, 0x00	; 0
 8c0:	b0 e0       	ldi	r27, 0x00	; 0
 8c2:	8e 19       	sub	r24, r14
 8c4:	91 09       	sbc	r25, r1
 8c6:	a1 09       	sbc	r26, r1
 8c8:	b1 09       	sbc	r27, r1
 8ca:	86 87       	std	Z+14, r24	; 0x0e
 8cc:	97 87       	std	Z+15, r25	; 0x0f
 8ce:	a0 8b       	std	Z+16, r26	; 0x10
 8d0:	b1 8b       	std	Z+17, r27	; 0x11
 8d2:	b7 8a       	std	Z+23, r11	; 0x17
 8d4:	a6 8a       	std	Z+22, r10	; 0x16
 8d6:	13 aa       	std	Z+51, r1	; 0x33
 8d8:	14 aa       	std	Z+52, r1	; 0x34
 8da:	15 aa       	std	Z+53, r1	; 0x35
 8dc:	16 aa       	std	Z+54, r1	; 0x36
 8de:	17 aa       	std	Z+55, r1	; 0x37
 8e0:	a8 01       	movw	r20, r16
 8e2:	b4 01       	movw	r22, r8
 8e4:	c3 01       	movw	r24, r6
 8e6:	0c de       	rcall	.-1000   	; 0x500 <pxPortInitialiseStack>
 8e8:	f5 01       	movw	r30, r10
 8ea:	91 83       	std	Z+1, r25	; 0x01
 8ec:	80 83       	st	Z, r24
 8ee:	c1 14       	cp	r12, r1
 8f0:	d1 04       	cpc	r13, r1
 8f2:	19 f0       	breq	.+6      	; 0x8fa <prvInitialiseNewTask+0xc0>
 8f4:	f6 01       	movw	r30, r12
 8f6:	b1 82       	std	Z+1, r11	; 0x01
 8f8:	a0 82       	st	Z, r10
 8fa:	df 91       	pop	r29
 8fc:	cf 91       	pop	r28
 8fe:	1f 91       	pop	r17
 900:	0f 91       	pop	r16
 902:	ef 90       	pop	r14
 904:	df 90       	pop	r13
 906:	cf 90       	pop	r12
 908:	bf 90       	pop	r11
 90a:	af 90       	pop	r10
 90c:	9f 90       	pop	r9
 90e:	8f 90       	pop	r8
 910:	7f 90       	pop	r7
 912:	6f 90       	pop	r6
 914:	08 95       	ret

00000916 <prvInitialiseTaskLists>:
 916:	cf 93       	push	r28
 918:	c0 e0       	ldi	r28, 0x00	; 0
 91a:	08 c0       	rjmp	.+16     	; 0x92c <prvInitialiseTaskLists+0x16>
 91c:	2b e0       	ldi	r18, 0x0B	; 11
 91e:	c2 9f       	mul	r28, r18
 920:	c0 01       	movw	r24, r0
 922:	11 24       	eor	r1, r1
 924:	88 51       	subi	r24, 0x18	; 24
 926:	96 4e       	sbci	r25, 0xE6	; 230
 928:	fd db       	rcall	.-2054   	; 0x124 <vListInitialise>
 92a:	cf 5f       	subi	r28, 0xFF	; 255
 92c:	c5 30       	cpi	r28, 0x05	; 5
 92e:	b0 f3       	brcs	.-20     	; 0x91c <prvInitialiseTaskLists+0x6>
 930:	8d ed       	ldi	r24, 0xDD	; 221
 932:	99 e1       	ldi	r25, 0x19	; 25
 934:	f7 db       	rcall	.-2066   	; 0x124 <vListInitialise>
 936:	82 ed       	ldi	r24, 0xD2	; 210
 938:	99 e1       	ldi	r25, 0x19	; 25
 93a:	f4 db       	rcall	.-2072   	; 0x124 <vListInitialise>
 93c:	83 ec       	ldi	r24, 0xC3	; 195
 93e:	99 e1       	ldi	r25, 0x19	; 25
 940:	f1 db       	rcall	.-2078   	; 0x124 <vListInitialise>
 942:	88 eb       	ldi	r24, 0xB8	; 184
 944:	99 e1       	ldi	r25, 0x19	; 25
 946:	ee db       	rcall	.-2084   	; 0x124 <vListInitialise>
 948:	8c ea       	ldi	r24, 0xAC	; 172
 94a:	99 e1       	ldi	r25, 0x19	; 25
 94c:	eb db       	rcall	.-2090   	; 0x124 <vListInitialise>
 94e:	8d ed       	ldi	r24, 0xDD	; 221
 950:	99 e1       	ldi	r25, 0x19	; 25
 952:	90 93 d1 19 	sts	0x19D1, r25	; 0x8019d1 <pxDelayedTaskList+0x1>
 956:	80 93 d0 19 	sts	0x19D0, r24	; 0x8019d0 <pxDelayedTaskList>
 95a:	82 ed       	ldi	r24, 0xD2	; 210
 95c:	99 e1       	ldi	r25, 0x19	; 25
 95e:	90 93 cf 19 	sts	0x19CF, r25	; 0x8019cf <pxOverflowDelayedTaskList+0x1>
 962:	80 93 ce 19 	sts	0x19CE, r24	; 0x8019ce <pxOverflowDelayedTaskList>
 966:	cf 91       	pop	r28
 968:	08 95       	ret

0000096a <prvAddNewTaskToReadyList>:
 96a:	cf 93       	push	r28
 96c:	df 93       	push	r29
 96e:	ec 01       	movw	r28, r24
 970:	0f b6       	in	r0, 0x3f	; 63
 972:	f8 94       	cli
 974:	0f 92       	push	r0
 976:	80 91 ab 19 	lds	r24, 0x19AB	; 0x8019ab <uxCurrentNumberOfTasks>
 97a:	8f 5f       	subi	r24, 0xFF	; 255
 97c:	80 93 ab 19 	sts	0x19AB, r24	; 0x8019ab <uxCurrentNumberOfTasks>
 980:	80 91 1f 1a 	lds	r24, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 984:	90 91 20 1a 	lds	r25, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 988:	89 2b       	or	r24, r25
 98a:	51 f4       	brne	.+20     	; 0x9a0 <prvAddNewTaskToReadyList+0x36>
 98c:	d0 93 20 1a 	sts	0x1A20, r29	; 0x801a20 <pxCurrentTCB+0x1>
 990:	c0 93 1f 1a 	sts	0x1A1F, r28	; 0x801a1f <pxCurrentTCB>
 994:	80 91 ab 19 	lds	r24, 0x19AB	; 0x8019ab <uxCurrentNumberOfTasks>
 998:	81 30       	cpi	r24, 0x01	; 1
 99a:	91 f4       	brne	.+36     	; 0x9c0 <prvAddNewTaskToReadyList+0x56>
 99c:	bc df       	rcall	.-136    	; 0x916 <prvInitialiseTaskLists>
 99e:	10 c0       	rjmp	.+32     	; 0x9c0 <prvAddNewTaskToReadyList+0x56>
 9a0:	80 91 a5 19 	lds	r24, 0x19A5	; 0x8019a5 <xSchedulerRunning>
 9a4:	81 11       	cpse	r24, r1
 9a6:	0c c0       	rjmp	.+24     	; 0x9c0 <prvAddNewTaskToReadyList+0x56>
 9a8:	e0 91 1f 1a 	lds	r30, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 9ac:	f0 91 20 1a 	lds	r31, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 9b0:	92 8d       	ldd	r25, Z+26	; 0x1a
 9b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 9b4:	89 17       	cp	r24, r25
 9b6:	20 f0       	brcs	.+8      	; 0x9c0 <prvAddNewTaskToReadyList+0x56>
 9b8:	d0 93 20 1a 	sts	0x1A20, r29	; 0x801a20 <pxCurrentTCB+0x1>
 9bc:	c0 93 1f 1a 	sts	0x1A1F, r28	; 0x801a1f <pxCurrentTCB>
 9c0:	80 91 a1 19 	lds	r24, 0x19A1	; 0x8019a1 <uxTaskNumber>
 9c4:	8f 5f       	subi	r24, 0xFF	; 255
 9c6:	80 93 a1 19 	sts	0x19A1, r24	; 0x8019a1 <uxTaskNumber>
 9ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
 9cc:	90 91 a6 19 	lds	r25, 0x19A6	; 0x8019a6 <uxTopReadyPriority>
 9d0:	98 17       	cp	r25, r24
 9d2:	10 f4       	brcc	.+4      	; 0x9d8 <prvAddNewTaskToReadyList+0x6e>
 9d4:	80 93 a6 19 	sts	0x19A6, r24	; 0x8019a6 <uxTopReadyPriority>
 9d8:	2b e0       	ldi	r18, 0x0B	; 11
 9da:	82 9f       	mul	r24, r18
 9dc:	c0 01       	movw	r24, r0
 9de:	11 24       	eor	r1, r1
 9e0:	be 01       	movw	r22, r28
 9e2:	6e 5f       	subi	r22, 0xFE	; 254
 9e4:	7f 4f       	sbci	r23, 0xFF	; 255
 9e6:	88 51       	subi	r24, 0x18	; 24
 9e8:	96 4e       	sbci	r25, 0xE6	; 230
 9ea:	b1 db       	rcall	.-2206   	; 0x14e <vListInsertEnd>
 9ec:	0f 90       	pop	r0
 9ee:	0f be       	out	0x3f, r0	; 63
 9f0:	80 91 a5 19 	lds	r24, 0x19A5	; 0x8019a5 <xSchedulerRunning>
 9f4:	88 23       	and	r24, r24
 9f6:	49 f0       	breq	.+18     	; 0xa0a <prvAddNewTaskToReadyList+0xa0>
 9f8:	e0 91 1f 1a 	lds	r30, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 9fc:	f0 91 20 1a 	lds	r31, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 a00:	92 8d       	ldd	r25, Z+26	; 0x1a
 a02:	8a 8d       	ldd	r24, Y+26	; 0x1a
 a04:	98 17       	cp	r25, r24
 a06:	08 f4       	brcc	.+2      	; 0xa0a <prvAddNewTaskToReadyList+0xa0>
 a08:	1f de       	rcall	.-962    	; 0x648 <vPortYield>
 a0a:	df 91       	pop	r29
 a0c:	cf 91       	pop	r28
 a0e:	08 95       	ret

00000a10 <prvAddCurrentTaskToDelayedList>:
 a10:	8f 92       	push	r8
 a12:	9f 92       	push	r9
 a14:	af 92       	push	r10
 a16:	bf 92       	push	r11
 a18:	cf 92       	push	r12
 a1a:	df 92       	push	r13
 a1c:	ef 92       	push	r14
 a1e:	ff 92       	push	r15
 a20:	cf 93       	push	r28
 a22:	6b 01       	movw	r12, r22
 a24:	7c 01       	movw	r14, r24
 a26:	c4 2f       	mov	r28, r20
 a28:	80 90 a7 19 	lds	r8, 0x19A7	; 0x8019a7 <xTickCount>
 a2c:	90 90 a8 19 	lds	r9, 0x19A8	; 0x8019a8 <xTickCount+0x1>
 a30:	a0 90 a9 19 	lds	r10, 0x19A9	; 0x8019a9 <xTickCount+0x2>
 a34:	b0 90 aa 19 	lds	r11, 0x19AA	; 0x8019aa <xTickCount+0x3>
 a38:	80 91 1f 1a 	lds	r24, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 a3c:	90 91 20 1a 	lds	r25, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 a40:	02 96       	adiw	r24, 0x02	; 2
 a42:	e3 db       	rcall	.-2106   	; 0x20a <uxListRemove>
 a44:	8f ef       	ldi	r24, 0xFF	; 255
 a46:	c8 16       	cp	r12, r24
 a48:	d8 06       	cpc	r13, r24
 a4a:	e8 06       	cpc	r14, r24
 a4c:	f8 06       	cpc	r15, r24
 a4e:	61 f4       	brne	.+24     	; 0xa68 <prvAddCurrentTaskToDelayedList+0x58>
 a50:	cc 23       	and	r28, r28
 a52:	51 f0       	breq	.+20     	; 0xa68 <prvAddCurrentTaskToDelayedList+0x58>
 a54:	60 91 1f 1a 	lds	r22, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 a58:	70 91 20 1a 	lds	r23, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 a5c:	6e 5f       	subi	r22, 0xFE	; 254
 a5e:	7f 4f       	sbci	r23, 0xFF	; 255
 a60:	8c ea       	ldi	r24, 0xAC	; 172
 a62:	99 e1       	ldi	r25, 0x19	; 25
 a64:	74 db       	rcall	.-2328   	; 0x14e <vListInsertEnd>
 a66:	3d c0       	rjmp	.+122    	; 0xae2 <prvAddCurrentTaskToDelayedList+0xd2>
 a68:	c8 0c       	add	r12, r8
 a6a:	d9 1c       	adc	r13, r9
 a6c:	ea 1c       	adc	r14, r10
 a6e:	fb 1c       	adc	r15, r11
 a70:	e0 91 1f 1a 	lds	r30, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 a74:	f0 91 20 1a 	lds	r31, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 a78:	c2 82       	std	Z+2, r12	; 0x02
 a7a:	d3 82       	std	Z+3, r13	; 0x03
 a7c:	e4 82       	std	Z+4, r14	; 0x04
 a7e:	f5 82       	std	Z+5, r15	; 0x05
 a80:	c8 14       	cp	r12, r8
 a82:	d9 04       	cpc	r13, r9
 a84:	ea 04       	cpc	r14, r10
 a86:	fb 04       	cpc	r15, r11
 a88:	60 f4       	brcc	.+24     	; 0xaa2 <prvAddCurrentTaskToDelayedList+0x92>
 a8a:	60 91 1f 1a 	lds	r22, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 a8e:	70 91 20 1a 	lds	r23, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 a92:	80 91 ce 19 	lds	r24, 0x19CE	; 0x8019ce <pxOverflowDelayedTaskList>
 a96:	90 91 cf 19 	lds	r25, 0x19CF	; 0x8019cf <pxOverflowDelayedTaskList+0x1>
 a9a:	6e 5f       	subi	r22, 0xFE	; 254
 a9c:	7f 4f       	sbci	r23, 0xFF	; 255
 a9e:	78 db       	rcall	.-2320   	; 0x190 <vListInsert>
 aa0:	20 c0       	rjmp	.+64     	; 0xae2 <prvAddCurrentTaskToDelayedList+0xd2>
 aa2:	60 91 1f 1a 	lds	r22, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 aa6:	70 91 20 1a 	lds	r23, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 aaa:	80 91 d0 19 	lds	r24, 0x19D0	; 0x8019d0 <pxDelayedTaskList>
 aae:	90 91 d1 19 	lds	r25, 0x19D1	; 0x8019d1 <pxDelayedTaskList+0x1>
 ab2:	6e 5f       	subi	r22, 0xFE	; 254
 ab4:	7f 4f       	sbci	r23, 0xFF	; 255
 ab6:	6c db       	rcall	.-2344   	; 0x190 <vListInsert>
 ab8:	80 91 9d 19 	lds	r24, 0x199D	; 0x80199d <xNextTaskUnblockTime>
 abc:	90 91 9e 19 	lds	r25, 0x199E	; 0x80199e <xNextTaskUnblockTime+0x1>
 ac0:	a0 91 9f 19 	lds	r26, 0x199F	; 0x80199f <xNextTaskUnblockTime+0x2>
 ac4:	b0 91 a0 19 	lds	r27, 0x19A0	; 0x8019a0 <xNextTaskUnblockTime+0x3>
 ac8:	c8 16       	cp	r12, r24
 aca:	d9 06       	cpc	r13, r25
 acc:	ea 06       	cpc	r14, r26
 ace:	fb 06       	cpc	r15, r27
 ad0:	40 f4       	brcc	.+16     	; 0xae2 <prvAddCurrentTaskToDelayedList+0xd2>
 ad2:	c0 92 9d 19 	sts	0x199D, r12	; 0x80199d <xNextTaskUnblockTime>
 ad6:	d0 92 9e 19 	sts	0x199E, r13	; 0x80199e <xNextTaskUnblockTime+0x1>
 ada:	e0 92 9f 19 	sts	0x199F, r14	; 0x80199f <xNextTaskUnblockTime+0x2>
 ade:	f0 92 a0 19 	sts	0x19A0, r15	; 0x8019a0 <xNextTaskUnblockTime+0x3>
 ae2:	cf 91       	pop	r28
 ae4:	ff 90       	pop	r15
 ae6:	ef 90       	pop	r14
 ae8:	df 90       	pop	r13
 aea:	cf 90       	pop	r12
 aec:	bf 90       	pop	r11
 aee:	af 90       	pop	r10
 af0:	9f 90       	pop	r9
 af2:	8f 90       	pop	r8
 af4:	08 95       	ret

00000af6 <xTaskCreate>:
 af6:	2f 92       	push	r2
 af8:	3f 92       	push	r3
 afa:	4f 92       	push	r4
 afc:	5f 92       	push	r5
 afe:	6f 92       	push	r6
 b00:	7f 92       	push	r7
 b02:	8f 92       	push	r8
 b04:	9f 92       	push	r9
 b06:	af 92       	push	r10
 b08:	bf 92       	push	r11
 b0a:	cf 92       	push	r12
 b0c:	df 92       	push	r13
 b0e:	ef 92       	push	r14
 b10:	ff 92       	push	r15
 b12:	0f 93       	push	r16
 b14:	1f 93       	push	r17
 b16:	cf 93       	push	r28
 b18:	df 93       	push	r29
 b1a:	3c 01       	movw	r6, r24
 b1c:	1b 01       	movw	r2, r22
 b1e:	5a 01       	movw	r10, r20
 b20:	29 01       	movw	r4, r18
 b22:	ca 01       	movw	r24, r20
 b24:	19 dc       	rcall	.-1998   	; 0x358 <pvPortMalloc>
 b26:	6c 01       	movw	r12, r24
 b28:	89 2b       	or	r24, r25
 b2a:	61 f0       	breq	.+24     	; 0xb44 <xTaskCreate+0x4e>
 b2c:	88 e3       	ldi	r24, 0x38	; 56
 b2e:	90 e0       	ldi	r25, 0x00	; 0
 b30:	13 dc       	rcall	.-2010   	; 0x358 <pvPortMalloc>
 b32:	ec 01       	movw	r28, r24
 b34:	89 2b       	or	r24, r25
 b36:	19 f0       	breq	.+6      	; 0xb3e <xTaskCreate+0x48>
 b38:	dc 8e       	std	Y+28, r13	; 0x1c
 b3a:	cb 8e       	std	Y+27, r12	; 0x1b
 b3c:	05 c0       	rjmp	.+10     	; 0xb48 <xTaskCreate+0x52>
 b3e:	c6 01       	movw	r24, r12
 b40:	9d dc       	rcall	.-1734   	; 0x47c <vPortFree>
 b42:	02 c0       	rjmp	.+4      	; 0xb48 <xTaskCreate+0x52>
 b44:	c0 e0       	ldi	r28, 0x00	; 0
 b46:	d0 e0       	ldi	r29, 0x00	; 0
 b48:	20 97       	sbiw	r28, 0x00	; 0
 b4a:	81 f0       	breq	.+32     	; 0xb6c <xTaskCreate+0x76>
 b4c:	95 01       	movw	r18, r10
 b4e:	40 e0       	ldi	r20, 0x00	; 0
 b50:	50 e0       	ldi	r21, 0x00	; 0
 b52:	81 2c       	mov	r8, r1
 b54:	91 2c       	mov	r9, r1
 b56:	5e 01       	movw	r10, r28
 b58:	67 01       	movw	r12, r14
 b5a:	e0 2e       	mov	r14, r16
 b5c:	82 01       	movw	r16, r4
 b5e:	b1 01       	movw	r22, r2
 b60:	c3 01       	movw	r24, r6
 b62:	6b de       	rcall	.-810    	; 0x83a <prvInitialiseNewTask>
 b64:	ce 01       	movw	r24, r28
 b66:	01 df       	rcall	.-510    	; 0x96a <prvAddNewTaskToReadyList>
 b68:	81 e0       	ldi	r24, 0x01	; 1
 b6a:	01 c0       	rjmp	.+2      	; 0xb6e <xTaskCreate+0x78>
 b6c:	8f ef       	ldi	r24, 0xFF	; 255
 b6e:	df 91       	pop	r29
 b70:	cf 91       	pop	r28
 b72:	1f 91       	pop	r17
 b74:	0f 91       	pop	r16
 b76:	ff 90       	pop	r15
 b78:	ef 90       	pop	r14
 b7a:	df 90       	pop	r13
 b7c:	cf 90       	pop	r12
 b7e:	bf 90       	pop	r11
 b80:	af 90       	pop	r10
 b82:	9f 90       	pop	r9
 b84:	8f 90       	pop	r8
 b86:	7f 90       	pop	r7
 b88:	6f 90       	pop	r6
 b8a:	5f 90       	pop	r5
 b8c:	4f 90       	pop	r4
 b8e:	3f 90       	pop	r3
 b90:	2f 90       	pop	r2
 b92:	08 95       	ret

00000b94 <vTaskStartScheduler>:
 b94:	ef 92       	push	r14
 b96:	ff 92       	push	r15
 b98:	0f 93       	push	r16
 b9a:	0f 2e       	mov	r0, r31
 b9c:	fb e9       	ldi	r31, 0x9B	; 155
 b9e:	ef 2e       	mov	r14, r31
 ba0:	f9 e1       	ldi	r31, 0x19	; 25
 ba2:	ff 2e       	mov	r15, r31
 ba4:	f0 2d       	mov	r31, r0
 ba6:	00 e0       	ldi	r16, 0x00	; 0
 ba8:	20 e0       	ldi	r18, 0x00	; 0
 baa:	30 e0       	ldi	r19, 0x00	; 0
 bac:	40 e0       	ldi	r20, 0x00	; 0
 bae:	54 e0       	ldi	r21, 0x04	; 4
 bb0:	60 e0       	ldi	r22, 0x00	; 0
 bb2:	72 e0       	ldi	r23, 0x02	; 2
 bb4:	87 e7       	ldi	r24, 0x77	; 119
 bb6:	97 e0       	ldi	r25, 0x07	; 7
 bb8:	9e df       	rcall	.-196    	; 0xaf6 <xTaskCreate>
 bba:	81 30       	cpi	r24, 0x01	; 1
 bbc:	c1 f4       	brne	.+48     	; 0xbee <vTaskStartScheduler+0x5a>
 bbe:	f8 94       	cli
 bc0:	8f ef       	ldi	r24, 0xFF	; 255
 bc2:	9f ef       	ldi	r25, 0xFF	; 255
 bc4:	dc 01       	movw	r26, r24
 bc6:	80 93 9d 19 	sts	0x199D, r24	; 0x80199d <xNextTaskUnblockTime>
 bca:	90 93 9e 19 	sts	0x199E, r25	; 0x80199e <xNextTaskUnblockTime+0x1>
 bce:	a0 93 9f 19 	sts	0x199F, r26	; 0x80199f <xNextTaskUnblockTime+0x2>
 bd2:	b0 93 a0 19 	sts	0x19A0, r27	; 0x8019a0 <xNextTaskUnblockTime+0x3>
 bd6:	81 e0       	ldi	r24, 0x01	; 1
 bd8:	80 93 a5 19 	sts	0x19A5, r24	; 0x8019a5 <xSchedulerRunning>
 bdc:	10 92 a7 19 	sts	0x19A7, r1	; 0x8019a7 <xTickCount>
 be0:	10 92 a8 19 	sts	0x19A8, r1	; 0x8019a8 <xTickCount+0x1>
 be4:	10 92 a9 19 	sts	0x19A9, r1	; 0x8019a9 <xTickCount+0x2>
 be8:	10 92 aa 19 	sts	0x19AA, r1	; 0x8019aa <xTickCount+0x3>
 bec:	fb dc       	rcall	.-1546   	; 0x5e4 <xPortStartScheduler>
 bee:	0f 91       	pop	r16
 bf0:	ff 90       	pop	r15
 bf2:	ef 90       	pop	r14
 bf4:	08 95       	ret

00000bf6 <vTaskSuspendAll>:
 bf6:	80 91 9a 19 	lds	r24, 0x199A	; 0x80199a <uxSchedulerSuspended>
 bfa:	8f 5f       	subi	r24, 0xFF	; 255
 bfc:	80 93 9a 19 	sts	0x199A, r24	; 0x80199a <uxSchedulerSuspended>
 c00:	08 95       	ret

00000c02 <xTaskIncrementTick>:
 c02:	bf 92       	push	r11
 c04:	cf 92       	push	r12
 c06:	df 92       	push	r13
 c08:	ef 92       	push	r14
 c0a:	ff 92       	push	r15
 c0c:	0f 93       	push	r16
 c0e:	1f 93       	push	r17
 c10:	cf 93       	push	r28
 c12:	df 93       	push	r29
 c14:	80 91 9a 19 	lds	r24, 0x199A	; 0x80199a <uxSchedulerSuspended>
 c18:	81 11       	cpse	r24, r1
 c1a:	a5 c0       	rjmp	.+330    	; 0xd66 <xTaskIncrementTick+0x164>
 c1c:	c0 90 a7 19 	lds	r12, 0x19A7	; 0x8019a7 <xTickCount>
 c20:	d0 90 a8 19 	lds	r13, 0x19A8	; 0x8019a8 <xTickCount+0x1>
 c24:	e0 90 a9 19 	lds	r14, 0x19A9	; 0x8019a9 <xTickCount+0x2>
 c28:	f0 90 aa 19 	lds	r15, 0x19AA	; 0x8019aa <xTickCount+0x3>
 c2c:	2f ef       	ldi	r18, 0xFF	; 255
 c2e:	c2 1a       	sub	r12, r18
 c30:	d2 0a       	sbc	r13, r18
 c32:	e2 0a       	sbc	r14, r18
 c34:	f2 0a       	sbc	r15, r18
 c36:	c0 92 a7 19 	sts	0x19A7, r12	; 0x8019a7 <xTickCount>
 c3a:	d0 92 a8 19 	sts	0x19A8, r13	; 0x8019a8 <xTickCount+0x1>
 c3e:	e0 92 a9 19 	sts	0x19A9, r14	; 0x8019a9 <xTickCount+0x2>
 c42:	f0 92 aa 19 	sts	0x19AA, r15	; 0x8019aa <xTickCount+0x3>
 c46:	c1 14       	cp	r12, r1
 c48:	d1 04       	cpc	r13, r1
 c4a:	e1 04       	cpc	r14, r1
 c4c:	f1 04       	cpc	r15, r1
 c4e:	b1 f4       	brne	.+44     	; 0xc7c <xTaskIncrementTick+0x7a>
 c50:	80 91 d0 19 	lds	r24, 0x19D0	; 0x8019d0 <pxDelayedTaskList>
 c54:	90 91 d1 19 	lds	r25, 0x19D1	; 0x8019d1 <pxDelayedTaskList+0x1>
 c58:	20 91 ce 19 	lds	r18, 0x19CE	; 0x8019ce <pxOverflowDelayedTaskList>
 c5c:	30 91 cf 19 	lds	r19, 0x19CF	; 0x8019cf <pxOverflowDelayedTaskList+0x1>
 c60:	30 93 d1 19 	sts	0x19D1, r19	; 0x8019d1 <pxDelayedTaskList+0x1>
 c64:	20 93 d0 19 	sts	0x19D0, r18	; 0x8019d0 <pxDelayedTaskList>
 c68:	90 93 cf 19 	sts	0x19CF, r25	; 0x8019cf <pxOverflowDelayedTaskList+0x1>
 c6c:	80 93 ce 19 	sts	0x19CE, r24	; 0x8019ce <pxOverflowDelayedTaskList>
 c70:	80 91 a2 19 	lds	r24, 0x19A2	; 0x8019a2 <xNumOfOverflows>
 c74:	8f 5f       	subi	r24, 0xFF	; 255
 c76:	80 93 a2 19 	sts	0x19A2, r24	; 0x8019a2 <xNumOfOverflows>
 c7a:	aa dd       	rcall	.-1196   	; 0x7d0 <prvResetNextTaskUnblockTime>
 c7c:	80 91 9d 19 	lds	r24, 0x199D	; 0x80199d <xNextTaskUnblockTime>
 c80:	90 91 9e 19 	lds	r25, 0x199E	; 0x80199e <xNextTaskUnblockTime+0x1>
 c84:	a0 91 9f 19 	lds	r26, 0x199F	; 0x80199f <xNextTaskUnblockTime+0x2>
 c88:	b0 91 a0 19 	lds	r27, 0x19A0	; 0x8019a0 <xNextTaskUnblockTime+0x3>
 c8c:	c8 16       	cp	r12, r24
 c8e:	d9 06       	cpc	r13, r25
 c90:	ea 06       	cpc	r14, r26
 c92:	fb 06       	cpc	r15, r27
 c94:	28 f4       	brcc	.+10     	; 0xca0 <xTaskIncrementTick+0x9e>
 c96:	b1 2c       	mov	r11, r1
 c98:	57 c0       	rjmp	.+174    	; 0xd48 <xTaskIncrementTick+0x146>
 c9a:	bb 24       	eor	r11, r11
 c9c:	b3 94       	inc	r11
 c9e:	01 c0       	rjmp	.+2      	; 0xca2 <xTaskIncrementTick+0xa0>
 ca0:	b1 2c       	mov	r11, r1
 ca2:	e0 91 d0 19 	lds	r30, 0x19D0	; 0x8019d0 <pxDelayedTaskList>
 ca6:	f0 91 d1 19 	lds	r31, 0x19D1	; 0x8019d1 <pxDelayedTaskList+0x1>
 caa:	80 81       	ld	r24, Z
 cac:	81 11       	cpse	r24, r1
 cae:	0c c0       	rjmp	.+24     	; 0xcc8 <xTaskIncrementTick+0xc6>
 cb0:	8f ef       	ldi	r24, 0xFF	; 255
 cb2:	9f ef       	ldi	r25, 0xFF	; 255
 cb4:	dc 01       	movw	r26, r24
 cb6:	80 93 9d 19 	sts	0x199D, r24	; 0x80199d <xNextTaskUnblockTime>
 cba:	90 93 9e 19 	sts	0x199E, r25	; 0x80199e <xNextTaskUnblockTime+0x1>
 cbe:	a0 93 9f 19 	sts	0x199F, r26	; 0x80199f <xNextTaskUnblockTime+0x2>
 cc2:	b0 93 a0 19 	sts	0x19A0, r27	; 0x8019a0 <xNextTaskUnblockTime+0x3>
 cc6:	40 c0       	rjmp	.+128    	; 0xd48 <xTaskIncrementTick+0x146>
 cc8:	e0 91 d0 19 	lds	r30, 0x19D0	; 0x8019d0 <pxDelayedTaskList>
 ccc:	f0 91 d1 19 	lds	r31, 0x19D1	; 0x8019d1 <pxDelayedTaskList+0x1>
 cd0:	07 80       	ldd	r0, Z+7	; 0x07
 cd2:	f0 85       	ldd	r31, Z+8	; 0x08
 cd4:	e0 2d       	mov	r30, r0
 cd6:	c0 85       	ldd	r28, Z+8	; 0x08
 cd8:	d1 85       	ldd	r29, Z+9	; 0x09
 cda:	8a 81       	ldd	r24, Y+2	; 0x02
 cdc:	9b 81       	ldd	r25, Y+3	; 0x03
 cde:	ac 81       	ldd	r26, Y+4	; 0x04
 ce0:	bd 81       	ldd	r27, Y+5	; 0x05
 ce2:	c8 16       	cp	r12, r24
 ce4:	d9 06       	cpc	r13, r25
 ce6:	ea 06       	cpc	r14, r26
 ce8:	fb 06       	cpc	r15, r27
 cea:	48 f4       	brcc	.+18     	; 0xcfe <xTaskIncrementTick+0xfc>
 cec:	80 93 9d 19 	sts	0x199D, r24	; 0x80199d <xNextTaskUnblockTime>
 cf0:	90 93 9e 19 	sts	0x199E, r25	; 0x80199e <xNextTaskUnblockTime+0x1>
 cf4:	a0 93 9f 19 	sts	0x199F, r26	; 0x80199f <xNextTaskUnblockTime+0x2>
 cf8:	b0 93 a0 19 	sts	0x19A0, r27	; 0x8019a0 <xNextTaskUnblockTime+0x3>
 cfc:	25 c0       	rjmp	.+74     	; 0xd48 <xTaskIncrementTick+0x146>
 cfe:	8e 01       	movw	r16, r28
 d00:	0e 5f       	subi	r16, 0xFE	; 254
 d02:	1f 4f       	sbci	r17, 0xFF	; 255
 d04:	c8 01       	movw	r24, r16
 d06:	81 da       	rcall	.-2814   	; 0x20a <uxListRemove>
 d08:	88 8d       	ldd	r24, Y+24	; 0x18
 d0a:	99 8d       	ldd	r25, Y+25	; 0x19
 d0c:	89 2b       	or	r24, r25
 d0e:	19 f0       	breq	.+6      	; 0xd16 <xTaskIncrementTick+0x114>
 d10:	ce 01       	movw	r24, r28
 d12:	0e 96       	adiw	r24, 0x0e	; 14
 d14:	7a da       	rcall	.-2828   	; 0x20a <uxListRemove>
 d16:	8a 8d       	ldd	r24, Y+26	; 0x1a
 d18:	90 91 a6 19 	lds	r25, 0x19A6	; 0x8019a6 <uxTopReadyPriority>
 d1c:	98 17       	cp	r25, r24
 d1e:	10 f4       	brcc	.+4      	; 0xd24 <xTaskIncrementTick+0x122>
 d20:	80 93 a6 19 	sts	0x19A6, r24	; 0x8019a6 <uxTopReadyPriority>
 d24:	2b e0       	ldi	r18, 0x0B	; 11
 d26:	82 9f       	mul	r24, r18
 d28:	c0 01       	movw	r24, r0
 d2a:	11 24       	eor	r1, r1
 d2c:	b8 01       	movw	r22, r16
 d2e:	88 51       	subi	r24, 0x18	; 24
 d30:	96 4e       	sbci	r25, 0xE6	; 230
 d32:	0d da       	rcall	.-3046   	; 0x14e <vListInsertEnd>
 d34:	9a 8d       	ldd	r25, Y+26	; 0x1a
 d36:	e0 91 1f 1a 	lds	r30, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 d3a:	f0 91 20 1a 	lds	r31, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 d3e:	82 8d       	ldd	r24, Z+26	; 0x1a
 d40:	98 17       	cp	r25, r24
 d42:	08 f0       	brcs	.+2      	; 0xd46 <xTaskIncrementTick+0x144>
 d44:	aa cf       	rjmp	.-172    	; 0xc9a <xTaskIncrementTick+0x98>
 d46:	ad cf       	rjmp	.-166    	; 0xca2 <xTaskIncrementTick+0xa0>
 d48:	e0 91 1f 1a 	lds	r30, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 d4c:	f0 91 20 1a 	lds	r31, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 d50:	e2 8d       	ldd	r30, Z+26	; 0x1a
 d52:	8b e0       	ldi	r24, 0x0B	; 11
 d54:	e8 9f       	mul	r30, r24
 d56:	f0 01       	movw	r30, r0
 d58:	11 24       	eor	r1, r1
 d5a:	e8 51       	subi	r30, 0x18	; 24
 d5c:	f6 4e       	sbci	r31, 0xE6	; 230
 d5e:	80 81       	ld	r24, Z
 d60:	82 30       	cpi	r24, 0x02	; 2
 d62:	40 f4       	brcc	.+16     	; 0xd74 <xTaskIncrementTick+0x172>
 d64:	09 c0       	rjmp	.+18     	; 0xd78 <xTaskIncrementTick+0x176>
 d66:	80 91 a4 19 	lds	r24, 0x19A4	; 0x8019a4 <uxPendedTicks>
 d6a:	8f 5f       	subi	r24, 0xFF	; 255
 d6c:	80 93 a4 19 	sts	0x19A4, r24	; 0x8019a4 <uxPendedTicks>
 d70:	b1 2c       	mov	r11, r1
 d72:	02 c0       	rjmp	.+4      	; 0xd78 <xTaskIncrementTick+0x176>
 d74:	bb 24       	eor	r11, r11
 d76:	b3 94       	inc	r11
 d78:	80 91 a3 19 	lds	r24, 0x19A3	; 0x8019a3 <xYieldPending>
 d7c:	88 23       	and	r24, r24
 d7e:	11 f0       	breq	.+4      	; 0xd84 <xTaskIncrementTick+0x182>
 d80:	bb 24       	eor	r11, r11
 d82:	b3 94       	inc	r11
 d84:	8b 2d       	mov	r24, r11
 d86:	df 91       	pop	r29
 d88:	cf 91       	pop	r28
 d8a:	1f 91       	pop	r17
 d8c:	0f 91       	pop	r16
 d8e:	ff 90       	pop	r15
 d90:	ef 90       	pop	r14
 d92:	df 90       	pop	r13
 d94:	cf 90       	pop	r12
 d96:	bf 90       	pop	r11
 d98:	08 95       	ret

00000d9a <xTaskResumeAll>:
 d9a:	0f 93       	push	r16
 d9c:	1f 93       	push	r17
 d9e:	cf 93       	push	r28
 da0:	df 93       	push	r29
 da2:	0f b6       	in	r0, 0x3f	; 63
 da4:	f8 94       	cli
 da6:	0f 92       	push	r0
 da8:	80 91 9a 19 	lds	r24, 0x199A	; 0x80199a <uxSchedulerSuspended>
 dac:	81 50       	subi	r24, 0x01	; 1
 dae:	80 93 9a 19 	sts	0x199A, r24	; 0x80199a <uxSchedulerSuspended>
 db2:	80 91 9a 19 	lds	r24, 0x199A	; 0x80199a <uxSchedulerSuspended>
 db6:	81 11       	cpse	r24, r1
 db8:	4c c0       	rjmp	.+152    	; 0xe52 <xTaskResumeAll+0xb8>
 dba:	80 91 ab 19 	lds	r24, 0x19AB	; 0x8019ab <uxCurrentNumberOfTasks>
 dbe:	81 11       	cpse	r24, r1
 dc0:	2a c0       	rjmp	.+84     	; 0xe16 <xTaskResumeAll+0x7c>
 dc2:	4a c0       	rjmp	.+148    	; 0xe58 <xTaskResumeAll+0xbe>
 dc4:	e0 91 ca 19 	lds	r30, 0x19CA	; 0x8019ca <xPendingReadyList+0x7>
 dc8:	f0 91 cb 19 	lds	r31, 0x19CB	; 0x8019cb <xPendingReadyList+0x8>
 dcc:	c0 85       	ldd	r28, Z+8	; 0x08
 dce:	d1 85       	ldd	r29, Z+9	; 0x09
 dd0:	ce 01       	movw	r24, r28
 dd2:	0e 96       	adiw	r24, 0x0e	; 14
 dd4:	1a da       	rcall	.-3020   	; 0x20a <uxListRemove>
 dd6:	8e 01       	movw	r16, r28
 dd8:	0e 5f       	subi	r16, 0xFE	; 254
 dda:	1f 4f       	sbci	r17, 0xFF	; 255
 ddc:	c8 01       	movw	r24, r16
 dde:	15 da       	rcall	.-3030   	; 0x20a <uxListRemove>
 de0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 de2:	90 91 a6 19 	lds	r25, 0x19A6	; 0x8019a6 <uxTopReadyPriority>
 de6:	98 17       	cp	r25, r24
 de8:	10 f4       	brcc	.+4      	; 0xdee <xTaskResumeAll+0x54>
 dea:	80 93 a6 19 	sts	0x19A6, r24	; 0x8019a6 <uxTopReadyPriority>
 dee:	2b e0       	ldi	r18, 0x0B	; 11
 df0:	82 9f       	mul	r24, r18
 df2:	c0 01       	movw	r24, r0
 df4:	11 24       	eor	r1, r1
 df6:	b8 01       	movw	r22, r16
 df8:	88 51       	subi	r24, 0x18	; 24
 dfa:	96 4e       	sbci	r25, 0xE6	; 230
 dfc:	a8 d9       	rcall	.-3248   	; 0x14e <vListInsertEnd>
 dfe:	9a 8d       	ldd	r25, Y+26	; 0x1a
 e00:	e0 91 1f 1a 	lds	r30, 0x1A1F	; 0x801a1f <pxCurrentTCB>
 e04:	f0 91 20 1a 	lds	r31, 0x1A20	; 0x801a20 <pxCurrentTCB+0x1>
 e08:	82 8d       	ldd	r24, Z+26	; 0x1a
 e0a:	98 17       	cp	r25, r24
 e0c:	30 f0       	brcs	.+12     	; 0xe1a <xTaskResumeAll+0x80>
 e0e:	81 e0       	ldi	r24, 0x01	; 1
 e10:	80 93 a3 19 	sts	0x19A3, r24	; 0x8019a3 <xYieldPending>
 e14:	02 c0       	rjmp	.+4      	; 0xe1a <xTaskResumeAll+0x80>
 e16:	c0 e0       	ldi	r28, 0x00	; 0
 e18:	d0 e0       	ldi	r29, 0x00	; 0
 e1a:	80 91 c3 19 	lds	r24, 0x19C3	; 0x8019c3 <xPendingReadyList>
 e1e:	81 11       	cpse	r24, r1
 e20:	d1 cf       	rjmp	.-94     	; 0xdc4 <xTaskResumeAll+0x2a>
 e22:	cd 2b       	or	r28, r29
 e24:	09 f0       	breq	.+2      	; 0xe28 <xTaskResumeAll+0x8e>
 e26:	d4 dc       	rcall	.-1624   	; 0x7d0 <prvResetNextTaskUnblockTime>
 e28:	c0 91 a4 19 	lds	r28, 0x19A4	; 0x8019a4 <uxPendedTicks>
 e2c:	cc 23       	and	r28, r28
 e2e:	51 f0       	breq	.+20     	; 0xe44 <xTaskResumeAll+0xaa>
 e30:	e8 de       	rcall	.-560    	; 0xc02 <xTaskIncrementTick>
 e32:	88 23       	and	r24, r24
 e34:	19 f0       	breq	.+6      	; 0xe3c <xTaskResumeAll+0xa2>
 e36:	81 e0       	ldi	r24, 0x01	; 1
 e38:	80 93 a3 19 	sts	0x19A3, r24	; 0x8019a3 <xYieldPending>
 e3c:	c1 50       	subi	r28, 0x01	; 1
 e3e:	c1 f7       	brne	.-16     	; 0xe30 <xTaskResumeAll+0x96>
 e40:	10 92 a4 19 	sts	0x19A4, r1	; 0x8019a4 <uxPendedTicks>
 e44:	80 91 a3 19 	lds	r24, 0x19A3	; 0x8019a3 <xYieldPending>
 e48:	88 23       	and	r24, r24
 e4a:	29 f0       	breq	.+10     	; 0xe56 <xTaskResumeAll+0xbc>
 e4c:	fd db       	rcall	.-2054   	; 0x648 <vPortYield>
 e4e:	81 e0       	ldi	r24, 0x01	; 1
 e50:	03 c0       	rjmp	.+6      	; 0xe58 <xTaskResumeAll+0xbe>
 e52:	80 e0       	ldi	r24, 0x00	; 0
 e54:	01 c0       	rjmp	.+2      	; 0xe58 <xTaskResumeAll+0xbe>
 e56:	80 e0       	ldi	r24, 0x00	; 0
 e58:	0f 90       	pop	r0
 e5a:	0f be       	out	0x3f, r0	; 63
 e5c:	df 91       	pop	r29
 e5e:	cf 91       	pop	r28
 e60:	1f 91       	pop	r17
 e62:	0f 91       	pop	r16
 e64:	08 95       	ret

00000e66 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 e66:	cf 92       	push	r12
 e68:	df 92       	push	r13
 e6a:	ef 92       	push	r14
 e6c:	ff 92       	push	r15
 e6e:	6b 01       	movw	r12, r22
 e70:	7c 01       	movw	r14, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 e72:	67 2b       	or	r22, r23
 e74:	68 2b       	or	r22, r24
 e76:	69 2b       	or	r22, r25
 e78:	39 f0       	breq	.+14     	; 0xe88 <vTaskDelay+0x22>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 e7a:	bd de       	rcall	.-646    	; 0xbf6 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 e7c:	40 e0       	ldi	r20, 0x00	; 0
 e7e:	c7 01       	movw	r24, r14
 e80:	b6 01       	movw	r22, r12
			}
			xAlreadyYielded = xTaskResumeAll();
 e82:	c6 dd       	rcall	.-1140   	; 0xa10 <prvAddCurrentTaskToDelayedList>
 e84:	8a df       	rcall	.-236    	; 0xd9a <xTaskResumeAll>
 e86:	01 c0       	rjmp	.+2      	; 0xe8a <vTaskDelay+0x24>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 e88:	80 e0       	ldi	r24, 0x00	; 0
 e8a:	81 11       	cpse	r24, r1
		{
			portYIELD_WITHIN_API();
 e8c:	01 c0       	rjmp	.+2      	; 0xe90 <vTaskDelay+0x2a>
 e8e:	dc db       	rcall	.-2120   	; 0x648 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 e90:	ff 90       	pop	r15
 e92:	ef 90       	pop	r14
 e94:	df 90       	pop	r13
 e96:	cf 90       	pop	r12
 e98:	08 95       	ret

00000e9a <prvCheckTasksWaitingTermination>:
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 e9a:	cf 93       	push	r28
 e9c:	df 93       	push	r29
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 e9e:	20 c0       	rjmp	.+64     	; 0xee0 <prvCheckTasksWaitingTermination+0x46>
		{
			vTaskSuspendAll();
 ea0:	aa de       	rcall	.-684    	; 0xbf6 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 ea2:	c0 91 b8 19 	lds	r28, 0x19B8	; 0x8019b8 <xTasksWaitingTermination>
			}
			( void ) xTaskResumeAll();
 ea6:	79 df       	rcall	.-270    	; 0xd9a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 ea8:	cc 23       	and	r28, r28
 eaa:	d1 f0       	breq	.+52     	; 0xee0 <prvCheckTasksWaitingTermination+0x46>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 eac:	0f b6       	in	r0, 0x3f	; 63
 eae:	f8 94       	cli
 eb0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 eb2:	e0 91 bf 19 	lds	r30, 0x19BF	; 0x8019bf <xTasksWaitingTermination+0x7>
 eb6:	f0 91 c0 19 	lds	r31, 0x19C0	; 0x8019c0 <xTasksWaitingTermination+0x8>
 eba:	c0 85       	ldd	r28, Z+8	; 0x08
 ebc:	d1 85       	ldd	r29, Z+9	; 0x09
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 ebe:	ce 01       	movw	r24, r28
 ec0:	02 96       	adiw	r24, 0x02	; 2
 ec2:	a3 d9       	rcall	.-3258   	; 0x20a <uxListRemove>
					--uxCurrentNumberOfTasks;
 ec4:	80 91 ab 19 	lds	r24, 0x19AB	; 0x8019ab <uxCurrentNumberOfTasks>
 ec8:	81 50       	subi	r24, 0x01	; 1
 eca:	80 93 ab 19 	sts	0x19AB, r24	; 0x8019ab <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
 ece:	80 91 b7 19 	lds	r24, 0x19B7	; 0x8019b7 <uxDeletedTasksWaitingCleanUp>
 ed2:	81 50       	subi	r24, 0x01	; 1
 ed4:	80 93 b7 19 	sts	0x19B7, r24	; 0x8019b7 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
 ed8:	0f 90       	pop	r0

				prvDeleteTCB( pxTCB );
 eda:	0f be       	out	0x3f, r0	; 63
 edc:	ce 01       	movw	r24, r28
 ede:	a2 dc       	rcall	.-1724   	; 0x824 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 ee0:	80 91 b7 19 	lds	r24, 0x19B7	; 0x8019b7 <uxDeletedTasksWaitingCleanUp>
 ee4:	81 11       	cpse	r24, r1
 ee6:	dc cf       	rjmp	.-72     	; 0xea0 <prvCheckTasksWaitingTermination+0x6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 ee8:	df 91       	pop	r29
 eea:	cf 91       	pop	r28
 eec:	08 95       	ret

00000eee <prvIdleTask>:

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 eee:	d5 df       	rcall	.-86     	; 0xe9a <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 ef0:	80 91 e8 19 	lds	r24, 0x19E8	; 0x8019e8 <pxReadyTasksLists>
 ef4:	82 30       	cpi	r24, 0x02	; 2
			{
				taskYIELD();
 ef6:	d8 f3       	brcs	.-10     	; 0xeee <prvIdleTask>
 ef8:	a7 db       	rcall	.-2226   	; 0x648 <vPortYield>
 efa:	f9 cf       	rjmp	.-14     	; 0xeee <prvIdleTask>

00000efc <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 efc:	80 91 9a 19 	lds	r24, 0x199A	; 0x80199a <uxSchedulerSuspended>
 f00:	88 23       	and	r24, r24
 f02:	21 f0       	breq	.+8      	; 0xf0c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 f04:	81 e0       	ldi	r24, 0x01	; 1
 f06:	80 93 a3 19 	sts	0x19A3, r24	; 0x8019a3 <xYieldPending>
 f0a:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 f0c:	10 92 a3 19 	sts	0x19A3, r1	; 0x8019a3 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 f10:	80 91 a6 19 	lds	r24, 0x19A6	; 0x8019a6 <uxTopReadyPriority>
 f14:	01 c0       	rjmp	.+2      	; 0xf18 <vTaskSwitchContext+0x1c>
 f16:	81 50       	subi	r24, 0x01	; 1
 f18:	28 2f       	mov	r18, r24
 f1a:	30 e0       	ldi	r19, 0x00	; 0
 f1c:	9b e0       	ldi	r25, 0x0B	; 11
 f1e:	92 9f       	mul	r25, r18
 f20:	f0 01       	movw	r30, r0
 f22:	93 9f       	mul	r25, r19
 f24:	f0 0d       	add	r31, r0
 f26:	11 24       	eor	r1, r1
 f28:	e8 51       	subi	r30, 0x18	; 24
 f2a:	f6 4e       	sbci	r31, 0xE6	; 230
 f2c:	90 81       	ld	r25, Z
 f2e:	99 23       	and	r25, r25
 f30:	91 f3       	breq	.-28     	; 0xf16 <vTaskSwitchContext+0x1a>
 f32:	9b e0       	ldi	r25, 0x0B	; 11
 f34:	92 9f       	mul	r25, r18
 f36:	a0 01       	movw	r20, r0
 f38:	93 9f       	mul	r25, r19
 f3a:	50 0d       	add	r21, r0
 f3c:	11 24       	eor	r1, r1
 f3e:	df 01       	movw	r26, r30
 f40:	01 80       	ldd	r0, Z+1	; 0x01
 f42:	f2 81       	ldd	r31, Z+2	; 0x02
 f44:	e0 2d       	mov	r30, r0
 f46:	04 80       	ldd	r0, Z+4	; 0x04
 f48:	f5 81       	ldd	r31, Z+5	; 0x05
 f4a:	e0 2d       	mov	r30, r0
 f4c:	12 96       	adiw	r26, 0x02	; 2
 f4e:	fc 93       	st	X, r31
 f50:	ee 93       	st	-X, r30
 f52:	11 97       	sbiw	r26, 0x01	; 1
 f54:	45 51       	subi	r20, 0x15	; 21
 f56:	56 4e       	sbci	r21, 0xE6	; 230
 f58:	e4 17       	cp	r30, r20
 f5a:	f5 07       	cpc	r31, r21
 f5c:	29 f4       	brne	.+10     	; 0xf68 <vTaskSwitchContext+0x6c>
 f5e:	44 81       	ldd	r20, Z+4	; 0x04
 f60:	55 81       	ldd	r21, Z+5	; 0x05
 f62:	fd 01       	movw	r30, r26
 f64:	52 83       	std	Z+2, r21	; 0x02
 f66:	41 83       	std	Z+1, r20	; 0x01
 f68:	9b e0       	ldi	r25, 0x0B	; 11
 f6a:	92 9f       	mul	r25, r18
 f6c:	f0 01       	movw	r30, r0
 f6e:	93 9f       	mul	r25, r19
 f70:	f0 0d       	add	r31, r0
 f72:	11 24       	eor	r1, r1
 f74:	e8 51       	subi	r30, 0x18	; 24
 f76:	f6 4e       	sbci	r31, 0xE6	; 230
 f78:	01 80       	ldd	r0, Z+1	; 0x01
 f7a:	f2 81       	ldd	r31, Z+2	; 0x02
 f7c:	e0 2d       	mov	r30, r0
 f7e:	20 85       	ldd	r18, Z+8	; 0x08
 f80:	31 85       	ldd	r19, Z+9	; 0x09
 f82:	30 93 20 1a 	sts	0x1A20, r19	; 0x801a20 <pxCurrentTCB+0x1>
 f86:	20 93 1f 1a 	sts	0x1A1F, r18	; 0x801a1f <pxCurrentTCB>
 f8a:	80 93 a6 19 	sts	0x19A6, r24	; 0x8019a6 <uxTopReadyPriority>
 f8e:	08 95       	ret

00000f90 <main>:
int main(void)
{
	
	// Debugging task to see that the FreeRTOS works
	extern void task_led_blinky(void *pvParameters);
	xTaskCreate(task_led_blinky, "Task to blink led pin 7", 100, NULL, 2, NULL);
 f90:	e1 2c       	mov	r14, r1
 f92:	f1 2c       	mov	r15, r1
 f94:	02 e0       	ldi	r16, 0x02	; 2
 f96:	20 e0       	ldi	r18, 0x00	; 0
 f98:	30 e0       	ldi	r19, 0x00	; 0
 f9a:	44 e6       	ldi	r20, 0x64	; 100
 f9c:	50 e0       	ldi	r21, 0x00	; 0
 f9e:	65 e0       	ldi	r22, 0x05	; 5
 fa0:	72 e0       	ldi	r23, 0x02	; 2
 fa2:	86 ed       	ldi	r24, 0xD6	; 214
 fa4:	97 e0       	ldi	r25, 0x07	; 7
 fa6:	a7 dd       	rcall	.-1202   	; 0xaf6 <xTaskCreate>
	
	// Start Scheduler
	vTaskStartScheduler();
 fa8:	f5 dd       	rcall	.-1046   	; 0xb94 <vTaskStartScheduler>
 faa:	ff cf       	rjmp	.-2      	; 0xfaa <main+0x1a>

00000fac <task_led_blinky>:
 fac:	84 b1       	in	r24, 0x04	; 4
#include <FreeRTOS.h>

// This task lights up LED at digital pin 13 (built-in)
void task_led_blinky (void *pvParameters) {
	// Create tasks
	DDRB |= (1<<PB7); // built in LED
 fae:	80 68       	ori	r24, 0x80	; 128
 fb0:	84 b9       	out	0x04, r24	; 4
	PORTB |= (1<<PB7);
 fb2:	85 b1       	in	r24, 0x05	; 5
 fb4:	80 68       	ori	r24, 0x80	; 128
 fb6:	85 b9       	out	0x05, r24	; 5
	
	while (1) {
		PORTB ^= (1<<PB7);
 fb8:	85 b1       	in	r24, 0x05	; 5
 fba:	80 58       	subi	r24, 0x80	; 128
 fbc:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(pdMS_TO_TICKS(2000));
 fbe:	60 ed       	ldi	r22, 0xD0	; 208
 fc0:	77 e0       	ldi	r23, 0x07	; 7
 fc2:	80 e0       	ldi	r24, 0x00	; 0
 fc4:	90 e0       	ldi	r25, 0x00	; 0
 fc6:	4f df       	rcall	.-354    	; 0xe66 <vTaskDelay>
 fc8:	f7 cf       	rjmp	.-18     	; 0xfb8 <task_led_blinky+0xc>

00000fca <_exit>:
 fca:	f8 94       	cli

00000fcc <__stop_program>:
 fcc:	ff cf       	rjmp	.-2      	; 0xfcc <__stop_program>
