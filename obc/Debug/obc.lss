
obc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002d0  00800200  00004508  0000459c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004508  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000191f  008004d0  008004d0  0000486c  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000486c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000048c8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007d0  00000000  00000000  00004908  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000098ae  00000000  00000000  000050d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002708  00000000  00000000  0000e986  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005311  00000000  00000000  0001108e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000018e0  00000000  00000000  000163a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000242c  00000000  00000000  00017c80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000074ce  00000000  00000000  0001a0ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000758  00000000  00000000  0002157a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	bd c0       	rjmp	.+378    	; 0x17c <__ctors_end>
       2:	00 00       	nop
       4:	dc c0       	rjmp	.+440    	; 0x1be <__bad_interrupt>
       6:	00 00       	nop
       8:	da c0       	rjmp	.+436    	; 0x1be <__bad_interrupt>
       a:	00 00       	nop
       c:	d8 c0       	rjmp	.+432    	; 0x1be <__bad_interrupt>
       e:	00 00       	nop
      10:	d6 c0       	rjmp	.+428    	; 0x1be <__bad_interrupt>
      12:	00 00       	nop
      14:	d4 c0       	rjmp	.+424    	; 0x1be <__bad_interrupt>
      16:	00 00       	nop
      18:	d2 c0       	rjmp	.+420    	; 0x1be <__bad_interrupt>
      1a:	00 00       	nop
      1c:	d0 c0       	rjmp	.+416    	; 0x1be <__bad_interrupt>
      1e:	00 00       	nop
      20:	ce c0       	rjmp	.+412    	; 0x1be <__bad_interrupt>
      22:	00 00       	nop
      24:	cc c0       	rjmp	.+408    	; 0x1be <__bad_interrupt>
      26:	00 00       	nop
      28:	ca c0       	rjmp	.+404    	; 0x1be <__bad_interrupt>
      2a:	00 00       	nop
      2c:	c8 c0       	rjmp	.+400    	; 0x1be <__bad_interrupt>
      2e:	00 00       	nop
      30:	c6 c0       	rjmp	.+396    	; 0x1be <__bad_interrupt>
      32:	00 00       	nop
      34:	c4 c0       	rjmp	.+392    	; 0x1be <__bad_interrupt>
      36:	00 00       	nop
      38:	c2 c0       	rjmp	.+388    	; 0x1be <__bad_interrupt>
      3a:	00 00       	nop
      3c:	c0 c0       	rjmp	.+384    	; 0x1be <__bad_interrupt>
      3e:	00 00       	nop
      40:	be c0       	rjmp	.+380    	; 0x1be <__bad_interrupt>
      42:	00 00       	nop
      44:	11 c4       	rjmp	.+2082   	; 0x868 <__vector_17>
      46:	00 00       	nop
      48:	ba c0       	rjmp	.+372    	; 0x1be <__bad_interrupt>
      4a:	00 00       	nop
      4c:	b8 c0       	rjmp	.+368    	; 0x1be <__bad_interrupt>
      4e:	00 00       	nop
      50:	b6 c0       	rjmp	.+364    	; 0x1be <__bad_interrupt>
      52:	00 00       	nop
      54:	b4 c0       	rjmp	.+360    	; 0x1be <__bad_interrupt>
      56:	00 00       	nop
      58:	b2 c0       	rjmp	.+356    	; 0x1be <__bad_interrupt>
      5a:	00 00       	nop
      5c:	b0 c0       	rjmp	.+352    	; 0x1be <__bad_interrupt>
      5e:	00 00       	nop
      60:	ae c0       	rjmp	.+348    	; 0x1be <__bad_interrupt>
      62:	00 00       	nop
      64:	ac c0       	rjmp	.+344    	; 0x1be <__bad_interrupt>
      66:	00 00       	nop
      68:	aa c0       	rjmp	.+340    	; 0x1be <__bad_interrupt>
      6a:	00 00       	nop
      6c:	a8 c0       	rjmp	.+336    	; 0x1be <__bad_interrupt>
      6e:	00 00       	nop
      70:	a6 c0       	rjmp	.+332    	; 0x1be <__bad_interrupt>
      72:	00 00       	nop
      74:	a4 c0       	rjmp	.+328    	; 0x1be <__bad_interrupt>
      76:	00 00       	nop
      78:	a2 c0       	rjmp	.+324    	; 0x1be <__bad_interrupt>
      7a:	00 00       	nop
      7c:	a0 c0       	rjmp	.+320    	; 0x1be <__bad_interrupt>
      7e:	00 00       	nop
      80:	9e c0       	rjmp	.+316    	; 0x1be <__bad_interrupt>
      82:	00 00       	nop
      84:	9c c0       	rjmp	.+312    	; 0x1be <__bad_interrupt>
      86:	00 00       	nop
      88:	9a c0       	rjmp	.+308    	; 0x1be <__bad_interrupt>
      8a:	00 00       	nop
      8c:	98 c0       	rjmp	.+304    	; 0x1be <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 d8 1a 	jmp	0x35b0	; 0x35b0 <__vector_36>
      94:	94 c0       	rjmp	.+296    	; 0x1be <__bad_interrupt>
      96:	00 00       	nop
      98:	92 c0       	rjmp	.+292    	; 0x1be <__bad_interrupt>
      9a:	00 00       	nop
      9c:	90 c0       	rjmp	.+288    	; 0x1be <__bad_interrupt>
      9e:	00 00       	nop
      a0:	8e c0       	rjmp	.+284    	; 0x1be <__bad_interrupt>
      a2:	00 00       	nop
      a4:	8c c0       	rjmp	.+280    	; 0x1be <__bad_interrupt>
      a6:	00 00       	nop
      a8:	8a c0       	rjmp	.+276    	; 0x1be <__bad_interrupt>
      aa:	00 00       	nop
      ac:	88 c0       	rjmp	.+272    	; 0x1be <__bad_interrupt>
      ae:	00 00       	nop
      b0:	86 c0       	rjmp	.+268    	; 0x1be <__bad_interrupt>
      b2:	00 00       	nop
      b4:	84 c0       	rjmp	.+264    	; 0x1be <__bad_interrupt>
      b6:	00 00       	nop
      b8:	82 c0       	rjmp	.+260    	; 0x1be <__bad_interrupt>
      ba:	00 00       	nop
      bc:	80 c0       	rjmp	.+256    	; 0x1be <__bad_interrupt>
      be:	00 00       	nop
      c0:	7e c0       	rjmp	.+252    	; 0x1be <__bad_interrupt>
      c2:	00 00       	nop
      c4:	7c c0       	rjmp	.+248    	; 0x1be <__bad_interrupt>
      c6:	00 00       	nop
      c8:	7a c0       	rjmp	.+244    	; 0x1be <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 1d 1b 	jmp	0x363a	; 0x363a <__vector_51>
      d0:	76 c0       	rjmp	.+236    	; 0x1be <__bad_interrupt>
      d2:	00 00       	nop
      d4:	74 c0       	rjmp	.+232    	; 0x1be <__bad_interrupt>
      d6:	00 00       	nop
      d8:	72 c0       	rjmp	.+228    	; 0x1be <__bad_interrupt>
      da:	00 00       	nop
      dc:	70 c0       	rjmp	.+224    	; 0x1be <__bad_interrupt>
      de:	00 00       	nop
      e0:	6e c0       	rjmp	.+220    	; 0x1be <__bad_interrupt>
      e2:	00 00       	nop
      e4:	d6 19       	sub	r29, r6
      e6:	72 19       	sub	r23, r2
      e8:	84 19       	sub	r24, r4
      ea:	a1 19       	sub	r26, r1
      ec:	b4 19       	sub	r27, r4
      ee:	f4 19       	sub	r31, r4
      f0:	f4 19       	sub	r31, r4
      f2:	f4 19       	sub	r31, r4
      f4:	c7 19       	sub	r28, r7
      f6:	e4 19       	sub	r30, r4
      f8:	ed 19       	sub	r30, r13
      fa:	07 63       	ori	r16, 0x37	; 55
      fc:	42 36       	cpi	r20, 0x62	; 98
      fe:	b7 9b       	sbis	0x16, 7	; 22
     100:	d8 a7       	std	Y+40, r29	; 0x28
     102:	1a 39       	cpi	r17, 0x9A	; 154
     104:	68 56       	subi	r22, 0x68	; 104
     106:	18 ae       	std	Y+56, r1	; 0x38
     108:	ba ab       	std	Y+50, r27	; 0x32
     10a:	55 8c       	ldd	r5, Z+29	; 0x1d
     10c:	1d 3c       	cpi	r17, 0xCD	; 205
     10e:	b7 cc       	rjmp	.-1682   	; 0xfffffa7e <__eeprom_end+0xff7efa7e>
     110:	57 63       	ori	r21, 0x37	; 55
     112:	bd 6d       	ori	r27, 0xDD	; 221
     114:	ed fd       	.word	0xfded	; ????
     116:	75 3e       	cpi	r23, 0xE5	; 229
     118:	f6 17       	cp	r31, r22
     11a:	72 31       	cpi	r23, 0x12	; 18
     11c:	bf 00       	.word	0x00bf	; ????
     11e:	00 00       	nop
     120:	80 3f       	cpi	r24, 0xF0	; 240
     122:	08 00       	.word	0x0008	; ????
     124:	00 00       	nop
     126:	be 92       	st	-X, r11
     128:	24 49       	sbci	r18, 0x94	; 148
     12a:	12 3e       	cpi	r17, 0xE2	; 226
     12c:	ab aa       	std	Y+51, r10	; 0x33
     12e:	aa 2a       	or	r10, r26
     130:	be cd       	rjmp	.-1156   	; 0xfffffcae <__eeprom_end+0xff7efcae>
     132:	cc cc       	rjmp	.-1640   	; 0xfffffacc <__eeprom_end+0xff7efacc>
     134:	4c 3e       	cpi	r20, 0xEC	; 236
     136:	00 00       	nop
     138:	00 80       	ld	r0, Z
     13a:	be ab       	std	Y+54, r27	; 0x36
     13c:	aa aa       	std	Y+50, r10	; 0x32
     13e:	aa 3e       	cpi	r26, 0xEA	; 234
     140:	00 00       	nop
     142:	00 00       	nop
     144:	bf 00       	.word	0x00bf	; ????
     146:	00 00       	nop
     148:	80 3f       	cpi	r24, 0xF0	; 240
     14a:	00 00       	nop
     14c:	00 00       	nop
     14e:	00 08       	sbc	r0, r0
     150:	41 78       	andi	r20, 0x81	; 129
     152:	d3 bb       	out	0x13, r29	; 19
     154:	43 87       	std	Z+11, r20	; 0x0b
     156:	d1 13       	cpse	r29, r17
     158:	3d 19       	sub	r19, r13
     15a:	0e 3c       	cpi	r16, 0xCE	; 206
     15c:	c3 bd       	out	0x23, r28	; 35
     15e:	42 82       	std	Z+2, r4	; 0x02
     160:	ad 2b       	or	r26, r29
     162:	3e 68       	ori	r19, 0x8E	; 142
     164:	ec 82       	std	Y+4, r14	; 0x04
     166:	76 be       	out	0x36, r7	; 54
     168:	d9 8f       	std	Y+25, r29	; 0x19
     16a:	e1 a9       	ldd	r30, Z+49	; 0x31
     16c:	3e 4c       	sbci	r19, 0xCE	; 206
     16e:	80 ef       	ldi	r24, 0xF0	; 240
     170:	ff be       	out	0x3f, r15	; 63
     172:	01 c4       	rjmp	.+2050   	; 0x976 <prvCopyDataFromQueue+0x16>
     174:	ff 7f       	andi	r31, 0xFF	; 255
     176:	3f 00       	.word	0x003f	; ????
     178:	00 00       	nop
	...

0000017c <__ctors_end>:
     17c:	11 24       	eor	r1, r1
     17e:	1f be       	out	0x3f, r1	; 63
     180:	cf ef       	ldi	r28, 0xFF	; 255
     182:	d1 e2       	ldi	r29, 0x21	; 33
     184:	de bf       	out	0x3e, r29	; 62
     186:	cd bf       	out	0x3d, r28	; 61
     188:	00 e0       	ldi	r16, 0x00	; 0
     18a:	0c bf       	out	0x3c, r16	; 60

0000018c <__do_copy_data>:
     18c:	14 e0       	ldi	r17, 0x04	; 4
     18e:	a0 e0       	ldi	r26, 0x00	; 0
     190:	b2 e0       	ldi	r27, 0x02	; 2
     192:	e8 e0       	ldi	r30, 0x08	; 8
     194:	f5 e4       	ldi	r31, 0x45	; 69
     196:	00 e0       	ldi	r16, 0x00	; 0
     198:	0b bf       	out	0x3b, r16	; 59
     19a:	02 c0       	rjmp	.+4      	; 0x1a0 <__do_copy_data+0x14>
     19c:	07 90       	elpm	r0, Z+
     19e:	0d 92       	st	X+, r0
     1a0:	a0 3d       	cpi	r26, 0xD0	; 208
     1a2:	b1 07       	cpc	r27, r17
     1a4:	d9 f7       	brne	.-10     	; 0x19c <__do_copy_data+0x10>

000001a6 <__do_clear_bss>:
     1a6:	2d e1       	ldi	r18, 0x1D	; 29
     1a8:	a0 ed       	ldi	r26, 0xD0	; 208
     1aa:	b4 e0       	ldi	r27, 0x04	; 4
     1ac:	01 c0       	rjmp	.+2      	; 0x1b0 <.do_clear_bss_start>

000001ae <.do_clear_bss_loop>:
     1ae:	1d 92       	st	X+, r1

000001b0 <.do_clear_bss_start>:
     1b0:	af 3e       	cpi	r26, 0xEF	; 239
     1b2:	b2 07       	cpc	r27, r18
     1b4:	e1 f7       	brne	.-8      	; 0x1ae <.do_clear_bss_loop>
     1b6:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <main>
     1ba:	0c 94 82 22 	jmp	0x4504	; 0x4504 <_exit>

000001be <__bad_interrupt>:
     1be:	20 cf       	rjmp	.-448    	; 0x0 <__vectors>

000001c0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     1c0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1c2:	03 96       	adiw	r24, 0x03	; 3
     1c4:	92 83       	std	Z+2, r25	; 0x02
     1c6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     1c8:	4f ef       	ldi	r20, 0xFF	; 255
     1ca:	5f ef       	ldi	r21, 0xFF	; 255
     1cc:	ba 01       	movw	r22, r20
     1ce:	43 83       	std	Z+3, r20	; 0x03
     1d0:	54 83       	std	Z+4, r21	; 0x04
     1d2:	65 83       	std	Z+5, r22	; 0x05
     1d4:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1d6:	90 87       	std	Z+8, r25	; 0x08
     1d8:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1da:	92 87       	std	Z+10, r25	; 0x0a
     1dc:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1de:	10 82       	st	Z, r1
     1e0:	08 95       	ret

000001e2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     1e2:	fc 01       	movw	r30, r24
     1e4:	13 86       	std	Z+11, r1	; 0x0b
     1e6:	12 86       	std	Z+10, r1	; 0x0a
     1e8:	08 95       	ret

000001ea <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1ea:	cf 93       	push	r28
     1ec:	df 93       	push	r29
     1ee:	9c 01       	movw	r18, r24
     1f0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     1f2:	dc 01       	movw	r26, r24
     1f4:	11 96       	adiw	r26, 0x01	; 1
     1f6:	cd 91       	ld	r28, X+
     1f8:	dc 91       	ld	r29, X
     1fa:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     1fc:	d5 83       	std	Z+5, r29	; 0x05
     1fe:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     200:	8e 81       	ldd	r24, Y+6	; 0x06
     202:	9f 81       	ldd	r25, Y+7	; 0x07
     204:	97 83       	std	Z+7, r25	; 0x07
     206:	86 83       	std	Z+6, r24	; 0x06

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     208:	8e 81       	ldd	r24, Y+6	; 0x06
     20a:	9f 81       	ldd	r25, Y+7	; 0x07
     20c:	dc 01       	movw	r26, r24
     20e:	15 96       	adiw	r26, 0x05	; 5
     210:	7c 93       	st	X, r23
     212:	6e 93       	st	-X, r22
     214:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     216:	7f 83       	std	Y+7, r23	; 0x07
     218:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     21a:	33 87       	std	Z+11, r19	; 0x0b
     21c:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     21e:	f9 01       	movw	r30, r18
     220:	80 81       	ld	r24, Z
     222:	8f 5f       	subi	r24, 0xFF	; 255
     224:	80 83       	st	Z, r24
}
     226:	df 91       	pop	r29
     228:	cf 91       	pop	r28
     22a:	08 95       	ret

0000022c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     22c:	0f 93       	push	r16
     22e:	1f 93       	push	r17
     230:	cf 93       	push	r28
     232:	df 93       	push	r29
     234:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     236:	08 81       	ld	r16, Y
     238:	19 81       	ldd	r17, Y+1	; 0x01
     23a:	2a 81       	ldd	r18, Y+2	; 0x02
     23c:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     23e:	0f 3f       	cpi	r16, 0xFF	; 255
     240:	4f ef       	ldi	r20, 0xFF	; 255
     242:	14 07       	cpc	r17, r20
     244:	24 07       	cpc	r18, r20
     246:	34 07       	cpc	r19, r20
     248:	21 f4       	brne	.+8      	; 0x252 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     24a:	fc 01       	movw	r30, r24
     24c:	a1 85       	ldd	r26, Z+9	; 0x09
     24e:	b2 85       	ldd	r27, Z+10	; 0x0a
     250:	11 c0       	rjmp	.+34     	; 0x274 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     252:	dc 01       	movw	r26, r24
     254:	13 96       	adiw	r26, 0x03	; 3
     256:	01 c0       	rjmp	.+2      	; 0x25a <vListInsert+0x2e>
     258:	df 01       	movw	r26, r30
     25a:	14 96       	adiw	r26, 0x04	; 4
     25c:	ed 91       	ld	r30, X+
     25e:	fc 91       	ld	r31, X
     260:	15 97       	sbiw	r26, 0x05	; 5
     262:	40 81       	ld	r20, Z
     264:	51 81       	ldd	r21, Z+1	; 0x01
     266:	62 81       	ldd	r22, Z+2	; 0x02
     268:	73 81       	ldd	r23, Z+3	; 0x03
     26a:	04 17       	cp	r16, r20
     26c:	15 07       	cpc	r17, r21
     26e:	26 07       	cpc	r18, r22
     270:	37 07       	cpc	r19, r23
     272:	90 f7       	brcc	.-28     	; 0x258 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     274:	14 96       	adiw	r26, 0x04	; 4
     276:	ed 91       	ld	r30, X+
     278:	fc 91       	ld	r31, X
     27a:	15 97       	sbiw	r26, 0x05	; 5
     27c:	fd 83       	std	Y+5, r31	; 0x05
     27e:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     280:	d7 83       	std	Z+7, r29	; 0x07
     282:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     284:	bf 83       	std	Y+7, r27	; 0x07
     286:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     288:	15 96       	adiw	r26, 0x05	; 5
     28a:	dc 93       	st	X, r29
     28c:	ce 93       	st	-X, r28
     28e:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     290:	9b 87       	std	Y+11, r25	; 0x0b
     292:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     294:	fc 01       	movw	r30, r24
     296:	20 81       	ld	r18, Z
     298:	2f 5f       	subi	r18, 0xFF	; 255
     29a:	20 83       	st	Z, r18
}
     29c:	df 91       	pop	r29
     29e:	cf 91       	pop	r28
     2a0:	1f 91       	pop	r17
     2a2:	0f 91       	pop	r16
     2a4:	08 95       	ret

000002a6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     2a6:	cf 93       	push	r28
     2a8:	df 93       	push	r29
     2aa:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     2ac:	a2 85       	ldd	r26, Z+10	; 0x0a
     2ae:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2b0:	c4 81       	ldd	r28, Z+4	; 0x04
     2b2:	d5 81       	ldd	r29, Z+5	; 0x05
     2b4:	86 81       	ldd	r24, Z+6	; 0x06
     2b6:	97 81       	ldd	r25, Z+7	; 0x07
     2b8:	9f 83       	std	Y+7, r25	; 0x07
     2ba:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     2bc:	c6 81       	ldd	r28, Z+6	; 0x06
     2be:	d7 81       	ldd	r29, Z+7	; 0x07
     2c0:	84 81       	ldd	r24, Z+4	; 0x04
     2c2:	95 81       	ldd	r25, Z+5	; 0x05
     2c4:	9d 83       	std	Y+5, r25	; 0x05
     2c6:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     2c8:	11 96       	adiw	r26, 0x01	; 1
     2ca:	8d 91       	ld	r24, X+
     2cc:	9c 91       	ld	r25, X
     2ce:	12 97       	sbiw	r26, 0x02	; 2
     2d0:	e8 17       	cp	r30, r24
     2d2:	f9 07       	cpc	r31, r25
     2d4:	31 f4       	brne	.+12     	; 0x2e2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     2d6:	86 81       	ldd	r24, Z+6	; 0x06
     2d8:	97 81       	ldd	r25, Z+7	; 0x07
     2da:	12 96       	adiw	r26, 0x02	; 2
     2dc:	9c 93       	st	X, r25
     2de:	8e 93       	st	-X, r24
     2e0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     2e2:	13 86       	std	Z+11, r1	; 0x0b
     2e4:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
     2e6:	8c 91       	ld	r24, X
     2e8:	81 50       	subi	r24, 0x01	; 1
     2ea:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     2ec:	df 91       	pop	r29
     2ee:	cf 91       	pop	r28
     2f0:	08 95       	ret

000002f2 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
     2f2:	cf 93       	push	r28
     2f4:	df 93       	push	r29
uint8_t *pucAlignedHeap;
uint32_t ulAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	ulAddress = ( uint32_t ) ucHeap;
     2f6:	ec ed       	ldi	r30, 0xDC	; 220
     2f8:	f4 e0       	ldi	r31, 0x04	; 4

	pucAlignedHeap = ( uint8_t * ) ulAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     2fa:	a8 ed       	ldi	r26, 0xD8	; 216
     2fc:	b4 e0       	ldi	r27, 0x04	; 4
     2fe:	11 96       	adiw	r26, 0x01	; 1
     300:	fc 93       	st	X, r31
     302:	ee 93       	st	-X, r30
	xStart.xBlockSize = ( size_t ) 0;
     304:	13 96       	adiw	r26, 0x03	; 3
     306:	1c 92       	st	X, r1
     308:	1e 92       	st	-X, r1
     30a:	12 97       	sbiw	r26, 0x02	; 2

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
     30c:	cf 01       	movw	r24, r30
     30e:	0f 2e       	mov	r0, r31
     310:	00 0c       	add	r0, r0
     312:	aa 0b       	sbc	r26, r26
     314:	bb 0b       	sbc	r27, r27
	ulAddress -= xHeapStructSize;
     316:	84 59       	subi	r24, 0x94	; 148
     318:	98 4e       	sbci	r25, 0xE8	; 232
     31a:	af 4f       	sbci	r26, 0xFF	; 255
     31c:	bf 4f       	sbci	r27, 0xFF	; 255
	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
	pxEnd = ( void * ) ulAddress;
     31e:	ec 01       	movw	r28, r24
     320:	90 93 d7 04 	sts	0x04D7, r25	; 0x8004d7 <pxEnd+0x1>
     324:	80 93 d6 04 	sts	0x04D6, r24	; 0x8004d6 <pxEnd>
	pxEnd->xBlockSize = 0;
     328:	1b 82       	std	Y+3, r1	; 0x03
     32a:	1a 82       	std	Y+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     32c:	19 82       	std	Y+1, r1	; 0x01
     32e:	18 82       	st	Y, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
     330:	9c 01       	movw	r18, r24
     332:	2c 5d       	subi	r18, 0xDC	; 220
     334:	34 40       	sbci	r19, 0x04	; 4
     336:	33 83       	std	Z+3, r19	; 0x03
     338:	22 83       	std	Z+2, r18	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     33a:	91 83       	std	Z+1, r25	; 0x01
     33c:	80 83       	st	Z, r24

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     33e:	30 93 d3 04 	sts	0x04D3, r19	; 0x8004d3 <xMinimumEverFreeBytesRemaining+0x1>
     342:	20 93 d2 04 	sts	0x04D2, r18	; 0x8004d2 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     346:	30 93 d5 04 	sts	0x04D5, r19	; 0x8004d5 <xFreeBytesRemaining+0x1>
     34a:	20 93 d4 04 	sts	0x04D4, r18	; 0x8004d4 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     34e:	80 e0       	ldi	r24, 0x00	; 0
     350:	90 e8       	ldi	r25, 0x80	; 128
     352:	90 93 d1 04 	sts	0x04D1, r25	; 0x8004d1 <__data_end+0x1>
     356:	80 93 d0 04 	sts	0x04D0, r24	; 0x8004d0 <__data_end>
}
     35a:	df 91       	pop	r29
     35c:	cf 91       	pop	r28
     35e:	08 95       	ret

00000360 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     360:	cf 93       	push	r28
     362:	df 93       	push	r29
     364:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     366:	a8 ed       	ldi	r26, 0xD8	; 216
     368:	b4 e0       	ldi	r27, 0x04	; 4
     36a:	01 c0       	rjmp	.+2      	; 0x36e <prvInsertBlockIntoFreeList+0xe>
     36c:	df 01       	movw	r26, r30
     36e:	ed 91       	ld	r30, X+
     370:	fc 91       	ld	r31, X
     372:	11 97       	sbiw	r26, 0x01	; 1
     374:	ec 17       	cp	r30, r28
     376:	fd 07       	cpc	r31, r29
     378:	c8 f3       	brcs	.-14     	; 0x36c <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     37a:	12 96       	adiw	r26, 0x02	; 2
     37c:	8d 91       	ld	r24, X+
     37e:	9c 91       	ld	r25, X
     380:	13 97       	sbiw	r26, 0x03	; 3
     382:	9d 01       	movw	r18, r26
     384:	28 0f       	add	r18, r24
     386:	39 1f       	adc	r19, r25
     388:	c2 17       	cp	r28, r18
     38a:	d3 07       	cpc	r29, r19
     38c:	49 f4       	brne	.+18     	; 0x3a0 <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     38e:	2a 81       	ldd	r18, Y+2	; 0x02
     390:	3b 81       	ldd	r19, Y+3	; 0x03
     392:	82 0f       	add	r24, r18
     394:	93 1f       	adc	r25, r19
     396:	13 96       	adiw	r26, 0x03	; 3
     398:	9c 93       	st	X, r25
     39a:	8e 93       	st	-X, r24
     39c:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     39e:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     3a0:	8a 81       	ldd	r24, Y+2	; 0x02
     3a2:	9b 81       	ldd	r25, Y+3	; 0x03
     3a4:	9e 01       	movw	r18, r28
     3a6:	28 0f       	add	r18, r24
     3a8:	39 1f       	adc	r19, r25
     3aa:	e2 17       	cp	r30, r18
     3ac:	f3 07       	cpc	r31, r19
     3ae:	c1 f4       	brne	.+48     	; 0x3e0 <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     3b0:	20 91 d6 04 	lds	r18, 0x04D6	; 0x8004d6 <pxEnd>
     3b4:	30 91 d7 04 	lds	r19, 0x04D7	; 0x8004d7 <pxEnd+0x1>
     3b8:	e2 17       	cp	r30, r18
     3ba:	f3 07       	cpc	r31, r19
     3bc:	71 f0       	breq	.+28     	; 0x3da <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     3be:	22 81       	ldd	r18, Z+2	; 0x02
     3c0:	33 81       	ldd	r19, Z+3	; 0x03
     3c2:	82 0f       	add	r24, r18
     3c4:	93 1f       	adc	r25, r19
     3c6:	9b 83       	std	Y+3, r25	; 0x03
     3c8:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     3ca:	ed 91       	ld	r30, X+
     3cc:	fc 91       	ld	r31, X
     3ce:	11 97       	sbiw	r26, 0x01	; 1
     3d0:	80 81       	ld	r24, Z
     3d2:	91 81       	ldd	r25, Z+1	; 0x01
     3d4:	99 83       	std	Y+1, r25	; 0x01
     3d6:	88 83       	st	Y, r24
     3d8:	05 c0       	rjmp	.+10     	; 0x3e4 <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     3da:	39 83       	std	Y+1, r19	; 0x01
     3dc:	28 83       	st	Y, r18
     3de:	02 c0       	rjmp	.+4      	; 0x3e4 <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     3e0:	f9 83       	std	Y+1, r31	; 0x01
     3e2:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     3e4:	ca 17       	cp	r28, r26
     3e6:	db 07       	cpc	r29, r27
     3e8:	11 f0       	breq	.+4      	; 0x3ee <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     3ea:	cd 93       	st	X+, r28
     3ec:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     3ee:	df 91       	pop	r29
     3f0:	cf 91       	pop	r28
     3f2:	08 95       	ret

000003f4 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3f4:	ef 92       	push	r14
     3f6:	ff 92       	push	r15
     3f8:	0f 93       	push	r16
     3fa:	1f 93       	push	r17
     3fc:	cf 93       	push	r28
     3fe:	df 93       	push	r29
     400:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     402:	6c d7       	rcall	.+3800   	; 0x12dc <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     404:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <pxEnd>
     408:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <pxEnd+0x1>
     40c:	89 2b       	or	r24, r25
		{
			prvHeapInit();
     40e:	09 f4       	brne	.+2      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
     410:	70 df       	rcall	.-288    	; 0x2f2 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     412:	80 91 d0 04 	lds	r24, 0x04D0	; 0x8004d0 <__data_end>
     416:	90 91 d1 04 	lds	r25, 0x04D1	; 0x8004d1 <__data_end+0x1>
     41a:	80 23       	and	r24, r16
     41c:	91 23       	and	r25, r17
     41e:	89 2b       	or	r24, r25
     420:	09 f0       	breq	.+2      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
     422:	66 c0       	rjmp	.+204    	; 0x4f0 <__LOCK_REGION_LENGTH__+0xf0>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     424:	01 15       	cp	r16, r1
     426:	11 05       	cpc	r17, r1
     428:	11 f0       	breq	.+4      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
			{
				xWantedSize += xHeapStructSize;
     42a:	0c 5f       	subi	r16, 0xFC	; 252
     42c:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     42e:	01 15       	cp	r16, r1
     430:	11 05       	cpc	r17, r1
     432:	09 f4       	brne	.+2      	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
     434:	60 c0       	rjmp	.+192    	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
     436:	80 91 d4 04 	lds	r24, 0x04D4	; 0x8004d4 <xFreeBytesRemaining>
     43a:	90 91 d5 04 	lds	r25, 0x04D5	; 0x8004d5 <xFreeBytesRemaining+0x1>
     43e:	80 17       	cp	r24, r16
     440:	91 07       	cpc	r25, r17
     442:	08 f4       	brcc	.+2      	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     444:	5b c0       	rjmp	.+182    	; 0x4fc <__LOCK_REGION_LENGTH__+0xfc>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     446:	c0 91 d8 04 	lds	r28, 0x04D8	; 0x8004d8 <xStart>
     44a:	d0 91 d9 04 	lds	r29, 0x04D9	; 0x8004d9 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     44e:	e8 ed       	ldi	r30, 0xD8	; 216
     450:	f4 e0       	ldi	r31, 0x04	; 4
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     452:	02 c0       	rjmp	.+4      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				{
					pxPreviousBlock = pxBlock;
     454:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     456:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     458:	8a 81       	ldd	r24, Y+2	; 0x02
     45a:	9b 81       	ldd	r25, Y+3	; 0x03
     45c:	80 17       	cp	r24, r16
     45e:	91 07       	cpc	r25, r17
     460:	20 f4       	brcc	.+8      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
     462:	88 81       	ld	r24, Y
     464:	99 81       	ldd	r25, Y+1	; 0x01
     466:	00 97       	sbiw	r24, 0x00	; 0
     468:	a9 f7       	brne	.-22     	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     46a:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <pxEnd>
     46e:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <pxEnd+0x1>
     472:	c8 17       	cp	r28, r24
     474:	d9 07       	cpc	r29, r25
     476:	09 f4       	brne	.+2      	; 0x47a <__LOCK_REGION_LENGTH__+0x7a>
     478:	44 c0       	rjmp	.+136    	; 0x502 <__LOCK_REGION_LENGTH__+0x102>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     47a:	e0 80       	ld	r14, Z
     47c:	f1 80       	ldd	r15, Z+1	; 0x01
     47e:	84 e0       	ldi	r24, 0x04	; 4
     480:	e8 0e       	add	r14, r24
     482:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     484:	88 81       	ld	r24, Y
     486:	99 81       	ldd	r25, Y+1	; 0x01
     488:	91 83       	std	Z+1, r25	; 0x01
     48a:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     48c:	2a 81       	ldd	r18, Y+2	; 0x02
     48e:	3b 81       	ldd	r19, Y+3	; 0x03
     490:	20 1b       	sub	r18, r16
     492:	31 0b       	sbc	r19, r17
     494:	29 30       	cpi	r18, 0x09	; 9
     496:	31 05       	cpc	r19, r1
     498:	48 f0       	brcs	.+18     	; 0x4ac <__LOCK_REGION_LENGTH__+0xac>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     49a:	ce 01       	movw	r24, r28
     49c:	80 0f       	add	r24, r16
     49e:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     4a0:	fc 01       	movw	r30, r24
     4a2:	33 83       	std	Z+3, r19	; 0x03
     4a4:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     4a6:	1b 83       	std	Y+3, r17	; 0x03

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     4a8:	0a 83       	std	Y+2, r16	; 0x02
     4aa:	5a df       	rcall	.-332    	; 0x360 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     4ac:	2a 81       	ldd	r18, Y+2	; 0x02
     4ae:	3b 81       	ldd	r19, Y+3	; 0x03
     4b0:	80 91 d4 04 	lds	r24, 0x04D4	; 0x8004d4 <xFreeBytesRemaining>
     4b4:	90 91 d5 04 	lds	r25, 0x04D5	; 0x8004d5 <xFreeBytesRemaining+0x1>
     4b8:	82 1b       	sub	r24, r18
     4ba:	93 0b       	sbc	r25, r19
     4bc:	90 93 d5 04 	sts	0x04D5, r25	; 0x8004d5 <xFreeBytesRemaining+0x1>
     4c0:	80 93 d4 04 	sts	0x04D4, r24	; 0x8004d4 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     4c4:	40 91 d2 04 	lds	r20, 0x04D2	; 0x8004d2 <xMinimumEverFreeBytesRemaining>
     4c8:	50 91 d3 04 	lds	r21, 0x04D3	; 0x8004d3 <xMinimumEverFreeBytesRemaining+0x1>
     4cc:	84 17       	cp	r24, r20
     4ce:	95 07       	cpc	r25, r21
     4d0:	20 f4       	brcc	.+8      	; 0x4da <__LOCK_REGION_LENGTH__+0xda>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     4d2:	90 93 d3 04 	sts	0x04D3, r25	; 0x8004d3 <xMinimumEverFreeBytesRemaining+0x1>
     4d6:	80 93 d2 04 	sts	0x04D2, r24	; 0x8004d2 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     4da:	80 91 d0 04 	lds	r24, 0x04D0	; 0x8004d0 <__data_end>
     4de:	90 91 d1 04 	lds	r25, 0x04D1	; 0x8004d1 <__data_end+0x1>
     4e2:	28 2b       	or	r18, r24
     4e4:	39 2b       	or	r19, r25
     4e6:	3b 83       	std	Y+3, r19	; 0x03
     4e8:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     4ea:	19 82       	std	Y+1, r1	; 0x01
     4ec:	18 82       	st	Y, r1
     4ee:	0b c0       	rjmp	.+22     	; 0x506 <__LOCK_REGION_LENGTH__+0x106>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     4f0:	e1 2c       	mov	r14, r1
     4f2:	f1 2c       	mov	r15, r1
     4f4:	08 c0       	rjmp	.+16     	; 0x506 <__LOCK_REGION_LENGTH__+0x106>
     4f6:	e1 2c       	mov	r14, r1
     4f8:	f1 2c       	mov	r15, r1
     4fa:	05 c0       	rjmp	.+10     	; 0x506 <__LOCK_REGION_LENGTH__+0x106>
     4fc:	e1 2c       	mov	r14, r1
     4fe:	f1 2c       	mov	r15, r1
     500:	02 c0       	rjmp	.+4      	; 0x506 <__LOCK_REGION_LENGTH__+0x106>
     502:	e1 2c       	mov	r14, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     504:	f1 2c       	mov	r15, r1
     506:	cd d7       	rcall	.+3994   	; 0x14a2 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     508:	c7 01       	movw	r24, r14
     50a:	df 91       	pop	r29
     50c:	cf 91       	pop	r28
     50e:	1f 91       	pop	r17
     510:	0f 91       	pop	r16
     512:	ff 90       	pop	r15
     514:	ef 90       	pop	r14
     516:	08 95       	ret

00000518 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     518:	0f 93       	push	r16
     51a:	1f 93       	push	r17
     51c:	cf 93       	push	r28
     51e:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     520:	00 97       	sbiw	r24, 0x00	; 0
     522:	39 f1       	breq	.+78     	; 0x572 <vPortFree+0x5a>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     524:	ec 01       	movw	r28, r24
     526:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     528:	4a 81       	ldd	r20, Y+2	; 0x02
     52a:	5b 81       	ldd	r21, Y+3	; 0x03
     52c:	20 91 d0 04 	lds	r18, 0x04D0	; 0x8004d0 <__data_end>
     530:	30 91 d1 04 	lds	r19, 0x04D1	; 0x8004d1 <__data_end+0x1>
     534:	ba 01       	movw	r22, r20
     536:	62 23       	and	r22, r18
     538:	73 23       	and	r23, r19
     53a:	67 2b       	or	r22, r23
     53c:	d1 f0       	breq	.+52     	; 0x572 <vPortFree+0x5a>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     53e:	68 81       	ld	r22, Y
     540:	79 81       	ldd	r23, Y+1	; 0x01
     542:	67 2b       	or	r22, r23
     544:	b1 f4       	brne	.+44     	; 0x572 <vPortFree+0x5a>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     546:	20 95       	com	r18
     548:	30 95       	com	r19
     54a:	24 23       	and	r18, r20
     54c:	35 23       	and	r19, r21
     54e:	3b 83       	std	Y+3, r19	; 0x03
     550:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     552:	c4 d6       	rcall	.+3464   	; 0x12dc <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     554:	8a 81       	ldd	r24, Y+2	; 0x02
     556:	9b 81       	ldd	r25, Y+3	; 0x03
     558:	20 91 d4 04 	lds	r18, 0x04D4	; 0x8004d4 <xFreeBytesRemaining>
     55c:	30 91 d5 04 	lds	r19, 0x04D5	; 0x8004d5 <xFreeBytesRemaining+0x1>
     560:	82 0f       	add	r24, r18
     562:	93 1f       	adc	r25, r19
     564:	90 93 d5 04 	sts	0x04D5, r25	; 0x8004d5 <xFreeBytesRemaining+0x1>
     568:	80 93 d4 04 	sts	0x04D4, r24	; 0x8004d4 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     56c:	ce 01       	movw	r24, r28
				}
				( void ) xTaskResumeAll();
     56e:	f8 de       	rcall	.-528    	; 0x360 <prvInsertBlockIntoFreeList>
     570:	98 d7       	rcall	.+3888   	; 0x14a2 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     572:	df 91       	pop	r29
     574:	cf 91       	pop	r28
     576:	1f 91       	pop	r17
     578:	0f 91       	pop	r16
     57a:	08 95       	ret

0000057c <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     57c:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7c0089>
     580:	89 ef       	ldi	r24, 0xF9	; 249
     582:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7c0088>
     586:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7c0080>
     58a:	8b e0       	ldi	r24, 0x0B	; 11
     58c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7c0081>
     590:	ef e6       	ldi	r30, 0x6F	; 111
     592:	f0 e0       	ldi	r31, 0x00	; 0
     594:	80 81       	ld	r24, Z
     596:	82 60       	ori	r24, 0x02	; 2
     598:	80 83       	st	Z, r24
     59a:	08 95       	ret

0000059c <pxPortInitialiseStack>:
     59c:	31 e1       	ldi	r19, 0x11	; 17
     59e:	fc 01       	movw	r30, r24
     5a0:	30 83       	st	Z, r19
     5a2:	31 97       	sbiw	r30, 0x01	; 1
     5a4:	22 e2       	ldi	r18, 0x22	; 34
     5a6:	20 83       	st	Z, r18
     5a8:	31 97       	sbiw	r30, 0x01	; 1
     5aa:	a3 e3       	ldi	r26, 0x33	; 51
     5ac:	a0 83       	st	Z, r26
     5ae:	31 97       	sbiw	r30, 0x01	; 1
     5b0:	60 83       	st	Z, r22
     5b2:	31 97       	sbiw	r30, 0x01	; 1
     5b4:	70 83       	st	Z, r23
     5b6:	31 97       	sbiw	r30, 0x01	; 1
     5b8:	10 82       	st	Z, r1
     5ba:	31 97       	sbiw	r30, 0x01	; 1
     5bc:	10 82       	st	Z, r1
     5be:	31 97       	sbiw	r30, 0x01	; 1
     5c0:	60 e8       	ldi	r22, 0x80	; 128
     5c2:	60 83       	st	Z, r22
     5c4:	31 97       	sbiw	r30, 0x01	; 1
     5c6:	10 82       	st	Z, r1
     5c8:	31 97       	sbiw	r30, 0x01	; 1
     5ca:	10 82       	st	Z, r1
     5cc:	31 97       	sbiw	r30, 0x01	; 1
     5ce:	10 82       	st	Z, r1
     5d0:	31 97       	sbiw	r30, 0x01	; 1
     5d2:	62 e0       	ldi	r22, 0x02	; 2
     5d4:	60 83       	st	Z, r22
     5d6:	31 97       	sbiw	r30, 0x01	; 1
     5d8:	63 e0       	ldi	r22, 0x03	; 3
     5da:	60 83       	st	Z, r22
     5dc:	31 97       	sbiw	r30, 0x01	; 1
     5de:	64 e0       	ldi	r22, 0x04	; 4
     5e0:	60 83       	st	Z, r22
     5e2:	31 97       	sbiw	r30, 0x01	; 1
     5e4:	65 e0       	ldi	r22, 0x05	; 5
     5e6:	60 83       	st	Z, r22
     5e8:	31 97       	sbiw	r30, 0x01	; 1
     5ea:	66 e0       	ldi	r22, 0x06	; 6
     5ec:	60 83       	st	Z, r22
     5ee:	31 97       	sbiw	r30, 0x01	; 1
     5f0:	67 e0       	ldi	r22, 0x07	; 7
     5f2:	60 83       	st	Z, r22
     5f4:	31 97       	sbiw	r30, 0x01	; 1
     5f6:	68 e0       	ldi	r22, 0x08	; 8
     5f8:	60 83       	st	Z, r22
     5fa:	31 97       	sbiw	r30, 0x01	; 1
     5fc:	69 e0       	ldi	r22, 0x09	; 9
     5fe:	60 83       	st	Z, r22
     600:	31 97       	sbiw	r30, 0x01	; 1
     602:	60 e1       	ldi	r22, 0x10	; 16
     604:	60 83       	st	Z, r22
     606:	31 97       	sbiw	r30, 0x01	; 1
     608:	30 83       	st	Z, r19
     60a:	31 97       	sbiw	r30, 0x01	; 1
     60c:	32 e1       	ldi	r19, 0x12	; 18
     60e:	30 83       	st	Z, r19
     610:	31 97       	sbiw	r30, 0x01	; 1
     612:	33 e1       	ldi	r19, 0x13	; 19
     614:	30 83       	st	Z, r19
     616:	31 97       	sbiw	r30, 0x01	; 1
     618:	34 e1       	ldi	r19, 0x14	; 20
     61a:	30 83       	st	Z, r19
     61c:	31 97       	sbiw	r30, 0x01	; 1
     61e:	35 e1       	ldi	r19, 0x15	; 21
     620:	30 83       	st	Z, r19
     622:	31 97       	sbiw	r30, 0x01	; 1
     624:	36 e1       	ldi	r19, 0x16	; 22
     626:	30 83       	st	Z, r19
     628:	31 97       	sbiw	r30, 0x01	; 1
     62a:	37 e1       	ldi	r19, 0x17	; 23
     62c:	30 83       	st	Z, r19
     62e:	31 97       	sbiw	r30, 0x01	; 1
     630:	38 e1       	ldi	r19, 0x18	; 24
     632:	30 83       	st	Z, r19
     634:	31 97       	sbiw	r30, 0x01	; 1
     636:	39 e1       	ldi	r19, 0x19	; 25
     638:	30 83       	st	Z, r19
     63a:	31 97       	sbiw	r30, 0x01	; 1
     63c:	30 e2       	ldi	r19, 0x20	; 32
     63e:	30 83       	st	Z, r19
     640:	31 97       	sbiw	r30, 0x01	; 1
     642:	31 e2       	ldi	r19, 0x21	; 33
     644:	30 83       	st	Z, r19
     646:	31 97       	sbiw	r30, 0x01	; 1
     648:	20 83       	st	Z, r18
     64a:	31 97       	sbiw	r30, 0x01	; 1
     64c:	23 e2       	ldi	r18, 0x23	; 35
     64e:	20 83       	st	Z, r18
     650:	31 97       	sbiw	r30, 0x01	; 1
     652:	40 83       	st	Z, r20
     654:	31 97       	sbiw	r30, 0x01	; 1
     656:	50 83       	st	Z, r21
     658:	31 97       	sbiw	r30, 0x01	; 1
     65a:	26 e2       	ldi	r18, 0x26	; 38
     65c:	20 83       	st	Z, r18
     65e:	31 97       	sbiw	r30, 0x01	; 1
     660:	27 e2       	ldi	r18, 0x27	; 39
     662:	20 83       	st	Z, r18
     664:	31 97       	sbiw	r30, 0x01	; 1
     666:	28 e2       	ldi	r18, 0x28	; 40
     668:	20 83       	st	Z, r18
     66a:	31 97       	sbiw	r30, 0x01	; 1
     66c:	29 e2       	ldi	r18, 0x29	; 41
     66e:	20 83       	st	Z, r18
     670:	31 97       	sbiw	r30, 0x01	; 1
     672:	20 e3       	ldi	r18, 0x30	; 48
     674:	20 83       	st	Z, r18
     676:	31 97       	sbiw	r30, 0x01	; 1
     678:	21 e3       	ldi	r18, 0x31	; 49
     67a:	20 83       	st	Z, r18
     67c:	89 97       	sbiw	r24, 0x29	; 41
     67e:	08 95       	ret

00000680 <xPortStartScheduler>:
     680:	7d df       	rcall	.-262    	; 0x57c <prvSetupTimerInterrupt>
     682:	a0 91 d1 1c 	lds	r26, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
     686:	b0 91 d2 1c 	lds	r27, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
     68a:	cd 91       	ld	r28, X+
     68c:	cd bf       	out	0x3d, r28	; 61
     68e:	dd 91       	ld	r29, X+
     690:	de bf       	out	0x3e, r29	; 62
     692:	ff 91       	pop	r31
     694:	ef 91       	pop	r30
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	bf 91       	pop	r27
     69c:	af 91       	pop	r26
     69e:	9f 91       	pop	r25
     6a0:	8f 91       	pop	r24
     6a2:	7f 91       	pop	r23
     6a4:	6f 91       	pop	r22
     6a6:	5f 91       	pop	r21
     6a8:	4f 91       	pop	r20
     6aa:	3f 91       	pop	r19
     6ac:	2f 91       	pop	r18
     6ae:	1f 91       	pop	r17
     6b0:	0f 91       	pop	r16
     6b2:	ff 90       	pop	r15
     6b4:	ef 90       	pop	r14
     6b6:	df 90       	pop	r13
     6b8:	cf 90       	pop	r12
     6ba:	bf 90       	pop	r11
     6bc:	af 90       	pop	r10
     6be:	9f 90       	pop	r9
     6c0:	8f 90       	pop	r8
     6c2:	7f 90       	pop	r7
     6c4:	6f 90       	pop	r6
     6c6:	5f 90       	pop	r5
     6c8:	4f 90       	pop	r4
     6ca:	3f 90       	pop	r3
     6cc:	2f 90       	pop	r2
     6ce:	1f 90       	pop	r1
     6d0:	0f 90       	pop	r0
     6d2:	0c be       	out	0x3c, r0	; 60
     6d4:	0f 90       	pop	r0
     6d6:	0b be       	out	0x3b, r0	; 59
     6d8:	0f 90       	pop	r0
     6da:	0f be       	out	0x3f, r0	; 63
     6dc:	0f 90       	pop	r0
     6de:	08 95       	ret
     6e0:	81 e0       	ldi	r24, 0x01	; 1
     6e2:	08 95       	ret

000006e4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     6e4:	0f 92       	push	r0
     6e6:	0f b6       	in	r0, 0x3f	; 63
     6e8:	f8 94       	cli
     6ea:	0f 92       	push	r0
     6ec:	0b b6       	in	r0, 0x3b	; 59
     6ee:	0f 92       	push	r0
     6f0:	0c b6       	in	r0, 0x3c	; 60
     6f2:	0f 92       	push	r0
     6f4:	1f 92       	push	r1
     6f6:	11 24       	eor	r1, r1
     6f8:	2f 92       	push	r2
     6fa:	3f 92       	push	r3
     6fc:	4f 92       	push	r4
     6fe:	5f 92       	push	r5
     700:	6f 92       	push	r6
     702:	7f 92       	push	r7
     704:	8f 92       	push	r8
     706:	9f 92       	push	r9
     708:	af 92       	push	r10
     70a:	bf 92       	push	r11
     70c:	cf 92       	push	r12
     70e:	df 92       	push	r13
     710:	ef 92       	push	r14
     712:	ff 92       	push	r15
     714:	0f 93       	push	r16
     716:	1f 93       	push	r17
     718:	2f 93       	push	r18
     71a:	3f 93       	push	r19
     71c:	4f 93       	push	r20
     71e:	5f 93       	push	r21
     720:	6f 93       	push	r22
     722:	7f 93       	push	r23
     724:	8f 93       	push	r24
     726:	9f 93       	push	r25
     728:	af 93       	push	r26
     72a:	bf 93       	push	r27
     72c:	cf 93       	push	r28
     72e:	df 93       	push	r29
     730:	ef 93       	push	r30
     732:	ff 93       	push	r31
     734:	a0 91 d1 1c 	lds	r26, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
     738:	b0 91 d2 1c 	lds	r27, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
     73c:	0d b6       	in	r0, 0x3d	; 61
     73e:	0d 92       	st	X+, r0
     740:	0e b6       	in	r0, 0x3e	; 62
     742:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     744:	63 d7       	rcall	.+3782   	; 0x160c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     746:	a0 91 d1 1c 	lds	r26, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
     74a:	b0 91 d2 1c 	lds	r27, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
     74e:	cd 91       	ld	r28, X+
     750:	cd bf       	out	0x3d, r28	; 61
     752:	dd 91       	ld	r29, X+
     754:	de bf       	out	0x3e, r29	; 62
     756:	ff 91       	pop	r31
     758:	ef 91       	pop	r30
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	bf 91       	pop	r27
     760:	af 91       	pop	r26
     762:	9f 91       	pop	r25
     764:	8f 91       	pop	r24
     766:	7f 91       	pop	r23
     768:	6f 91       	pop	r22
     76a:	5f 91       	pop	r21
     76c:	4f 91       	pop	r20
     76e:	3f 91       	pop	r19
     770:	2f 91       	pop	r18
     772:	1f 91       	pop	r17
     774:	0f 91       	pop	r16
     776:	ff 90       	pop	r15
     778:	ef 90       	pop	r14
     77a:	df 90       	pop	r13
     77c:	cf 90       	pop	r12
     77e:	bf 90       	pop	r11
     780:	af 90       	pop	r10
     782:	9f 90       	pop	r9
     784:	8f 90       	pop	r8
     786:	7f 90       	pop	r7
     788:	6f 90       	pop	r6
     78a:	5f 90       	pop	r5
     78c:	4f 90       	pop	r4
     78e:	3f 90       	pop	r3
     790:	2f 90       	pop	r2
     792:	1f 90       	pop	r1
     794:	0f 90       	pop	r0
     796:	0c be       	out	0x3c, r0	; 60
     798:	0f 90       	pop	r0
     79a:	0b be       	out	0x3b, r0	; 59
     79c:	0f 90       	pop	r0
     79e:	0f be       	out	0x3f, r0	; 63
     7a0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     7a2:	08 95       	ret

000007a4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     7a4:	0f 92       	push	r0
     7a6:	0f b6       	in	r0, 0x3f	; 63
     7a8:	f8 94       	cli
     7aa:	0f 92       	push	r0
     7ac:	0b b6       	in	r0, 0x3b	; 59
     7ae:	0f 92       	push	r0
     7b0:	0c b6       	in	r0, 0x3c	; 60
     7b2:	0f 92       	push	r0
     7b4:	1f 92       	push	r1
     7b6:	11 24       	eor	r1, r1
     7b8:	2f 92       	push	r2
     7ba:	3f 92       	push	r3
     7bc:	4f 92       	push	r4
     7be:	5f 92       	push	r5
     7c0:	6f 92       	push	r6
     7c2:	7f 92       	push	r7
     7c4:	8f 92       	push	r8
     7c6:	9f 92       	push	r9
     7c8:	af 92       	push	r10
     7ca:	bf 92       	push	r11
     7cc:	cf 92       	push	r12
     7ce:	df 92       	push	r13
     7d0:	ef 92       	push	r14
     7d2:	ff 92       	push	r15
     7d4:	0f 93       	push	r16
     7d6:	1f 93       	push	r17
     7d8:	2f 93       	push	r18
     7da:	3f 93       	push	r19
     7dc:	4f 93       	push	r20
     7de:	5f 93       	push	r21
     7e0:	6f 93       	push	r22
     7e2:	7f 93       	push	r23
     7e4:	8f 93       	push	r24
     7e6:	9f 93       	push	r25
     7e8:	af 93       	push	r26
     7ea:	bf 93       	push	r27
     7ec:	cf 93       	push	r28
     7ee:	df 93       	push	r29
     7f0:	ef 93       	push	r30
     7f2:	ff 93       	push	r31
     7f4:	a0 91 d1 1c 	lds	r26, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
     7f8:	b0 91 d2 1c 	lds	r27, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
     7fc:	0d b6       	in	r0, 0x3d	; 61
     7fe:	0d 92       	st	X+, r0
     800:	0e b6       	in	r0, 0x3e	; 62
     802:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     804:	7f d5       	rcall	.+2814   	; 0x1304 <xTaskIncrementTick>
     806:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     808:	01 d7       	rcall	.+3586   	; 0x160c <vTaskSwitchContext>
     80a:	a0 91 d1 1c 	lds	r26, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
     80e:	b0 91 d2 1c 	lds	r27, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
     812:	cd 91       	ld	r28, X+
     814:	cd bf       	out	0x3d, r28	; 61
     816:	dd 91       	ld	r29, X+
     818:	de bf       	out	0x3e, r29	; 62
     81a:	ff 91       	pop	r31
     81c:	ef 91       	pop	r30
     81e:	df 91       	pop	r29
     820:	cf 91       	pop	r28
     822:	bf 91       	pop	r27
     824:	af 91       	pop	r26
     826:	9f 91       	pop	r25
     828:	8f 91       	pop	r24
     82a:	7f 91       	pop	r23
     82c:	6f 91       	pop	r22
     82e:	5f 91       	pop	r21
     830:	4f 91       	pop	r20
     832:	3f 91       	pop	r19
     834:	2f 91       	pop	r18
     836:	1f 91       	pop	r17
     838:	0f 91       	pop	r16
     83a:	ff 90       	pop	r15
     83c:	ef 90       	pop	r14
     83e:	df 90       	pop	r13
     840:	cf 90       	pop	r12
     842:	bf 90       	pop	r11
     844:	af 90       	pop	r10
     846:	9f 90       	pop	r9
     848:	8f 90       	pop	r8
     84a:	7f 90       	pop	r7
     84c:	6f 90       	pop	r6
     84e:	5f 90       	pop	r5
     850:	4f 90       	pop	r4
     852:	3f 90       	pop	r3
     854:	2f 90       	pop	r2
     856:	1f 90       	pop	r1
     858:	0f 90       	pop	r0
     85a:	0c be       	out	0x3c, r0	; 60
     85c:	0f 90       	pop	r0
     85e:	0b be       	out	0x3b, r0	; 59
     860:	0f 90       	pop	r0
     862:	0f be       	out	0x3f, r0	; 63
     864:	0f 90       	pop	r0
     866:	08 95       	ret

00000868 <__vector_17>:

	asm volatile ( "ret" );
     868:	9d df       	rcall	.-198    	; 0x7a4 <vPortYieldFromTick>
	 */
	ISR(TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR(TIMER1_COMPA_vect)
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
     86a:	18 95       	reti

0000086c <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     86c:	0f b6       	in	r0, 0x3f	; 63
     86e:	f8 94       	cli
     870:	0f 92       	push	r0
     872:	fc 01       	movw	r30, r24
     874:	86 8d       	ldd	r24, Z+30	; 0x1e
     876:	81 11       	cpse	r24, r1
     878:	02 c0       	rjmp	.+4      	; 0x87e <prvIsQueueEmpty+0x12>
     87a:	81 e0       	ldi	r24, 0x01	; 1
     87c:	01 c0       	rjmp	.+2      	; 0x880 <prvIsQueueEmpty+0x14>
     87e:	80 e0       	ldi	r24, 0x00	; 0
     880:	0f 90       	pop	r0
     882:	0f be       	out	0x3f, r0	; 63
     884:	08 95       	ret

00000886 <prvIsQueueFull>:
     886:	0f b6       	in	r0, 0x3f	; 63
     888:	f8 94       	cli
     88a:	0f 92       	push	r0
     88c:	fc 01       	movw	r30, r24
     88e:	26 8d       	ldd	r18, Z+30	; 0x1e
     890:	87 8d       	ldd	r24, Z+31	; 0x1f
     892:	28 13       	cpse	r18, r24
     894:	02 c0       	rjmp	.+4      	; 0x89a <prvIsQueueFull+0x14>
     896:	81 e0       	ldi	r24, 0x01	; 1
     898:	01 c0       	rjmp	.+2      	; 0x89c <prvIsQueueFull+0x16>
     89a:	80 e0       	ldi	r24, 0x00	; 0
     89c:	0f 90       	pop	r0
     89e:	0f be       	out	0x3f, r0	; 63
     8a0:	08 95       	ret

000008a2 <prvCopyDataToQueue>:
     8a2:	0f 93       	push	r16
     8a4:	1f 93       	push	r17
     8a6:	cf 93       	push	r28
     8a8:	df 93       	push	r29
     8aa:	ec 01       	movw	r28, r24
     8ac:	04 2f       	mov	r16, r20
     8ae:	1e 8d       	ldd	r17, Y+30	; 0x1e
     8b0:	48 a1       	ldd	r20, Y+32	; 0x20
     8b2:	41 11       	cpse	r20, r1
     8b4:	0c c0       	rjmp	.+24     	; 0x8ce <prvCopyDataToQueue+0x2c>
     8b6:	88 81       	ld	r24, Y
     8b8:	99 81       	ldd	r25, Y+1	; 0x01
     8ba:	89 2b       	or	r24, r25
     8bc:	09 f0       	breq	.+2      	; 0x8c0 <prvCopyDataToQueue+0x1e>
     8be:	42 c0       	rjmp	.+132    	; 0x944 <prvCopyDataToQueue+0xa2>
     8c0:	8a 81       	ldd	r24, Y+2	; 0x02
     8c2:	9b 81       	ldd	r25, Y+3	; 0x03
     8c4:	0e 94 82 0c 	call	0x1904	; 0x1904 <xTaskPriorityDisinherit>
     8c8:	1b 82       	std	Y+3, r1	; 0x03
     8ca:	1a 82       	std	Y+2, r1	; 0x02
     8cc:	42 c0       	rjmp	.+132    	; 0x952 <prvCopyDataToQueue+0xb0>
     8ce:	01 11       	cpse	r16, r1
     8d0:	17 c0       	rjmp	.+46     	; 0x900 <prvCopyDataToQueue+0x5e>
     8d2:	50 e0       	ldi	r21, 0x00	; 0
     8d4:	8c 81       	ldd	r24, Y+4	; 0x04
     8d6:	9d 81       	ldd	r25, Y+5	; 0x05
     8d8:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <memcpy>
     8dc:	28 a1       	ldd	r18, Y+32	; 0x20
     8de:	8c 81       	ldd	r24, Y+4	; 0x04
     8e0:	9d 81       	ldd	r25, Y+5	; 0x05
     8e2:	82 0f       	add	r24, r18
     8e4:	91 1d       	adc	r25, r1
     8e6:	9d 83       	std	Y+5, r25	; 0x05
     8e8:	8c 83       	std	Y+4, r24	; 0x04
     8ea:	2a 81       	ldd	r18, Y+2	; 0x02
     8ec:	3b 81       	ldd	r19, Y+3	; 0x03
     8ee:	82 17       	cp	r24, r18
     8f0:	93 07       	cpc	r25, r19
     8f2:	50 f1       	brcs	.+84     	; 0x948 <prvCopyDataToQueue+0xa6>
     8f4:	88 81       	ld	r24, Y
     8f6:	99 81       	ldd	r25, Y+1	; 0x01
     8f8:	9d 83       	std	Y+5, r25	; 0x05
     8fa:	8c 83       	std	Y+4, r24	; 0x04
     8fc:	80 e0       	ldi	r24, 0x00	; 0
     8fe:	29 c0       	rjmp	.+82     	; 0x952 <prvCopyDataToQueue+0xb0>
     900:	50 e0       	ldi	r21, 0x00	; 0
     902:	8e 81       	ldd	r24, Y+6	; 0x06
     904:	9f 81       	ldd	r25, Y+7	; 0x07
     906:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <memcpy>
     90a:	88 a1       	ldd	r24, Y+32	; 0x20
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	91 95       	neg	r25
     910:	81 95       	neg	r24
     912:	91 09       	sbc	r25, r1
     914:	2e 81       	ldd	r18, Y+6	; 0x06
     916:	3f 81       	ldd	r19, Y+7	; 0x07
     918:	28 0f       	add	r18, r24
     91a:	39 1f       	adc	r19, r25
     91c:	3f 83       	std	Y+7, r19	; 0x07
     91e:	2e 83       	std	Y+6, r18	; 0x06
     920:	48 81       	ld	r20, Y
     922:	59 81       	ldd	r21, Y+1	; 0x01
     924:	24 17       	cp	r18, r20
     926:	35 07       	cpc	r19, r21
     928:	30 f4       	brcc	.+12     	; 0x936 <prvCopyDataToQueue+0x94>
     92a:	2a 81       	ldd	r18, Y+2	; 0x02
     92c:	3b 81       	ldd	r19, Y+3	; 0x03
     92e:	82 0f       	add	r24, r18
     930:	93 1f       	adc	r25, r19
     932:	9f 83       	std	Y+7, r25	; 0x07
     934:	8e 83       	std	Y+6, r24	; 0x06
     936:	02 30       	cpi	r16, 0x02	; 2
     938:	49 f4       	brne	.+18     	; 0x94c <prvCopyDataToQueue+0xaa>
     93a:	11 23       	and	r17, r17
     93c:	49 f0       	breq	.+18     	; 0x950 <prvCopyDataToQueue+0xae>
     93e:	11 50       	subi	r17, 0x01	; 1
     940:	80 e0       	ldi	r24, 0x00	; 0
     942:	07 c0       	rjmp	.+14     	; 0x952 <prvCopyDataToQueue+0xb0>
     944:	80 e0       	ldi	r24, 0x00	; 0
     946:	05 c0       	rjmp	.+10     	; 0x952 <prvCopyDataToQueue+0xb0>
     948:	80 e0       	ldi	r24, 0x00	; 0
     94a:	03 c0       	rjmp	.+6      	; 0x952 <prvCopyDataToQueue+0xb0>
     94c:	80 e0       	ldi	r24, 0x00	; 0
     94e:	01 c0       	rjmp	.+2      	; 0x952 <prvCopyDataToQueue+0xb0>
     950:	80 e0       	ldi	r24, 0x00	; 0
     952:	1f 5f       	subi	r17, 0xFF	; 255
     954:	1e 8f       	std	Y+30, r17	; 0x1e
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	1f 91       	pop	r17
     95c:	0f 91       	pop	r16
     95e:	08 95       	ret

00000960 <prvCopyDataFromQueue>:
     960:	fc 01       	movw	r30, r24
     962:	40 a1       	ldd	r20, Z+32	; 0x20
     964:	44 23       	and	r20, r20
     966:	a9 f0       	breq	.+42     	; 0x992 <prvCopyDataFromQueue+0x32>
     968:	50 e0       	ldi	r21, 0x00	; 0
     96a:	26 81       	ldd	r18, Z+6	; 0x06
     96c:	37 81       	ldd	r19, Z+7	; 0x07
     96e:	24 0f       	add	r18, r20
     970:	35 1f       	adc	r19, r21
     972:	37 83       	std	Z+7, r19	; 0x07
     974:	26 83       	std	Z+6, r18	; 0x06
     976:	82 81       	ldd	r24, Z+2	; 0x02
     978:	93 81       	ldd	r25, Z+3	; 0x03
     97a:	28 17       	cp	r18, r24
     97c:	39 07       	cpc	r19, r25
     97e:	20 f0       	brcs	.+8      	; 0x988 <prvCopyDataFromQueue+0x28>
     980:	80 81       	ld	r24, Z
     982:	91 81       	ldd	r25, Z+1	; 0x01
     984:	97 83       	std	Z+7, r25	; 0x07
     986:	86 83       	std	Z+6, r24	; 0x06
     988:	cb 01       	movw	r24, r22
     98a:	66 81       	ldd	r22, Z+6	; 0x06
     98c:	77 81       	ldd	r23, Z+7	; 0x07
     98e:	0c 94 89 1f 	jmp	0x3f12	; 0x3f12 <memcpy>
     992:	08 95       	ret

00000994 <prvUnlockQueue>:
     994:	1f 93       	push	r17
     996:	cf 93       	push	r28
     998:	df 93       	push	r29
     99a:	ec 01       	movw	r28, r24
     99c:	0f b6       	in	r0, 0x3f	; 63
     99e:	f8 94       	cli
     9a0:	0f 92       	push	r0
     9a2:	1a a1       	ldd	r17, Y+34	; 0x22
     9a4:	09 c0       	rjmp	.+18     	; 0x9b8 <prvUnlockQueue+0x24>
     9a6:	8b 89       	ldd	r24, Y+19	; 0x13
     9a8:	88 23       	and	r24, r24
     9aa:	41 f0       	breq	.+16     	; 0x9bc <prvUnlockQueue+0x28>
     9ac:	ce 01       	movw	r24, r28
     9ae:	43 96       	adiw	r24, 0x13	; 19
     9b0:	8e d6       	rcall	.+3356   	; 0x16ce <xTaskRemoveFromEventList>
     9b2:	81 11       	cpse	r24, r1
     9b4:	45 d7       	rcall	.+3722   	; 0x1840 <vTaskMissedYield>
     9b6:	11 50       	subi	r17, 0x01	; 1
     9b8:	11 16       	cp	r1, r17
     9ba:	ac f3       	brlt	.-22     	; 0x9a6 <prvUnlockQueue+0x12>
     9bc:	8f ef       	ldi	r24, 0xFF	; 255
     9be:	8a a3       	std	Y+34, r24	; 0x22
     9c0:	0f 90       	pop	r0
     9c2:	0f be       	out	0x3f, r0	; 63
     9c4:	0f b6       	in	r0, 0x3f	; 63
     9c6:	f8 94       	cli
     9c8:	0f 92       	push	r0
     9ca:	19 a1       	ldd	r17, Y+33	; 0x21
     9cc:	09 c0       	rjmp	.+18     	; 0x9e0 <prvUnlockQueue+0x4c>
     9ce:	88 85       	ldd	r24, Y+8	; 0x08
     9d0:	88 23       	and	r24, r24
     9d2:	41 f0       	breq	.+16     	; 0x9e4 <prvUnlockQueue+0x50>
     9d4:	ce 01       	movw	r24, r28
     9d6:	08 96       	adiw	r24, 0x08	; 8
     9d8:	7a d6       	rcall	.+3316   	; 0x16ce <xTaskRemoveFromEventList>
     9da:	81 11       	cpse	r24, r1
     9dc:	31 d7       	rcall	.+3682   	; 0x1840 <vTaskMissedYield>
     9de:	11 50       	subi	r17, 0x01	; 1
     9e0:	11 16       	cp	r1, r17
     9e2:	ac f3       	brlt	.-22     	; 0x9ce <prvUnlockQueue+0x3a>
     9e4:	8f ef       	ldi	r24, 0xFF	; 255
     9e6:	89 a3       	std	Y+33, r24	; 0x21
     9e8:	0f 90       	pop	r0
     9ea:	0f be       	out	0x3f, r0	; 63
     9ec:	df 91       	pop	r29
     9ee:	cf 91       	pop	r28
     9f0:	1f 91       	pop	r17
     9f2:	08 95       	ret

000009f4 <xQueueGenericReset>:
     9f4:	cf 93       	push	r28
     9f6:	df 93       	push	r29
     9f8:	ec 01       	movw	r28, r24
     9fa:	0f b6       	in	r0, 0x3f	; 63
     9fc:	f8 94       	cli
     9fe:	0f 92       	push	r0
     a00:	e8 81       	ld	r30, Y
     a02:	f9 81       	ldd	r31, Y+1	; 0x01
     a04:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	28 a1       	ldd	r18, Y+32	; 0x20
     a0a:	30 e0       	ldi	r19, 0x00	; 0
     a0c:	82 9f       	mul	r24, r18
     a0e:	a0 01       	movw	r20, r0
     a10:	83 9f       	mul	r24, r19
     a12:	50 0d       	add	r21, r0
     a14:	92 9f       	mul	r25, r18
     a16:	50 0d       	add	r21, r0
     a18:	11 24       	eor	r1, r1
     a1a:	4e 0f       	add	r20, r30
     a1c:	5f 1f       	adc	r21, r31
     a1e:	5b 83       	std	Y+3, r21	; 0x03
     a20:	4a 83       	std	Y+2, r20	; 0x02
     a22:	1e 8e       	std	Y+30, r1	; 0x1e
     a24:	fd 83       	std	Y+5, r31	; 0x05
     a26:	ec 83       	std	Y+4, r30	; 0x04
     a28:	01 97       	sbiw	r24, 0x01	; 1
     a2a:	28 9f       	mul	r18, r24
     a2c:	a0 01       	movw	r20, r0
     a2e:	29 9f       	mul	r18, r25
     a30:	50 0d       	add	r21, r0
     a32:	38 9f       	mul	r19, r24
     a34:	50 0d       	add	r21, r0
     a36:	11 24       	eor	r1, r1
     a38:	cf 01       	movw	r24, r30
     a3a:	84 0f       	add	r24, r20
     a3c:	95 1f       	adc	r25, r21
     a3e:	9f 83       	std	Y+7, r25	; 0x07
     a40:	8e 83       	std	Y+6, r24	; 0x06
     a42:	8f ef       	ldi	r24, 0xFF	; 255
     a44:	89 a3       	std	Y+33, r24	; 0x21
     a46:	8a a3       	std	Y+34, r24	; 0x22
     a48:	61 11       	cpse	r22, r1
     a4a:	0a c0       	rjmp	.+20     	; 0xa60 <xQueueGenericReset+0x6c>
     a4c:	88 85       	ldd	r24, Y+8	; 0x08
     a4e:	88 23       	and	r24, r24
     a50:	69 f0       	breq	.+26     	; 0xa6c <xQueueGenericReset+0x78>
     a52:	ce 01       	movw	r24, r28
     a54:	08 96       	adiw	r24, 0x08	; 8
     a56:	3b d6       	rcall	.+3190   	; 0x16ce <xTaskRemoveFromEventList>
     a58:	88 23       	and	r24, r24
     a5a:	41 f0       	breq	.+16     	; 0xa6c <xQueueGenericReset+0x78>
     a5c:	43 de       	rcall	.-890    	; 0x6e4 <vPortYield>
     a5e:	06 c0       	rjmp	.+12     	; 0xa6c <xQueueGenericReset+0x78>
     a60:	ce 01       	movw	r24, r28
     a62:	08 96       	adiw	r24, 0x08	; 8
     a64:	ad db       	rcall	.-2214   	; 0x1c0 <vListInitialise>
     a66:	ce 01       	movw	r24, r28
     a68:	43 96       	adiw	r24, 0x13	; 19
     a6a:	aa db       	rcall	.-2220   	; 0x1c0 <vListInitialise>
     a6c:	0f 90       	pop	r0
     a6e:	0f be       	out	0x3f, r0	; 63
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	df 91       	pop	r29
     a74:	cf 91       	pop	r28
     a76:	08 95       	ret

00000a78 <prvInitialiseNewQueue>:
     a78:	0f 93       	push	r16
     a7a:	1f 93       	push	r17
     a7c:	f8 01       	movw	r30, r16
     a7e:	61 11       	cpse	r22, r1
     a80:	03 c0       	rjmp	.+6      	; 0xa88 <prvInitialiseNewQueue+0x10>
     a82:	11 83       	std	Z+1, r17	; 0x01
     a84:	00 83       	st	Z, r16
     a86:	02 c0       	rjmp	.+4      	; 0xa8c <prvInitialiseNewQueue+0x14>
     a88:	51 83       	std	Z+1, r21	; 0x01
     a8a:	40 83       	st	Z, r20
     a8c:	87 8f       	std	Z+31, r24	; 0x1f
     a8e:	60 a3       	std	Z+32, r22	; 0x20
     a90:	61 e0       	ldi	r22, 0x01	; 1
     a92:	cf 01       	movw	r24, r30
     a94:	af df       	rcall	.-162    	; 0x9f4 <xQueueGenericReset>
     a96:	1f 91       	pop	r17
     a98:	0f 91       	pop	r16
     a9a:	08 95       	ret

00000a9c <xQueueGenericCreate>:
     a9c:	df 92       	push	r13
     a9e:	ef 92       	push	r14
     aa0:	ff 92       	push	r15
     aa2:	0f 93       	push	r16
     aa4:	1f 93       	push	r17
     aa6:	cf 93       	push	r28
     aa8:	df 93       	push	r29
     aaa:	e8 2e       	mov	r14, r24
     aac:	f6 2e       	mov	r15, r22
     aae:	d4 2e       	mov	r13, r20
     ab0:	66 23       	and	r22, r22
     ab2:	21 f0       	breq	.+8      	; 0xabc <xQueueGenericCreate+0x20>
     ab4:	86 9f       	mul	r24, r22
     ab6:	c0 01       	movw	r24, r0
     ab8:	11 24       	eor	r1, r1
     aba:	02 c0       	rjmp	.+4      	; 0xac0 <xQueueGenericCreate+0x24>
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	83 96       	adiw	r24, 0x23	; 35
     ac2:	98 dc       	rcall	.-1744   	; 0x3f4 <pvPortMalloc>
     ac4:	ec 01       	movw	r28, r24
     ac6:	00 97       	sbiw	r24, 0x00	; 0
     ac8:	41 f0       	breq	.+16     	; 0xada <xQueueGenericCreate+0x3e>
     aca:	8c 01       	movw	r16, r24
     acc:	2d 2d       	mov	r18, r13
     ace:	ac 01       	movw	r20, r24
     ad0:	4d 5d       	subi	r20, 0xDD	; 221
     ad2:	5f 4f       	sbci	r21, 0xFF	; 255
     ad4:	6f 2d       	mov	r22, r15
     ad6:	8e 2d       	mov	r24, r14
     ad8:	cf df       	rcall	.-98     	; 0xa78 <prvInitialiseNewQueue>
     ada:	ce 01       	movw	r24, r28
     adc:	df 91       	pop	r29
     ade:	cf 91       	pop	r28
     ae0:	1f 91       	pop	r17
     ae2:	0f 91       	pop	r16
     ae4:	ff 90       	pop	r15
     ae6:	ef 90       	pop	r14
     ae8:	df 90       	pop	r13
     aea:	08 95       	ret

00000aec <xQueueGenericSend>:
     aec:	cf 92       	push	r12
     aee:	df 92       	push	r13
     af0:	ef 92       	push	r14
     af2:	ff 92       	push	r15
     af4:	0f 93       	push	r16
     af6:	1f 93       	push	r17
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
     afc:	cd b7       	in	r28, 0x3d	; 61
     afe:	de b7       	in	r29, 0x3e	; 62
     b00:	29 97       	sbiw	r28, 0x09	; 9
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	de bf       	out	0x3e, r29	; 62
     b08:	0f be       	out	0x3f, r0	; 63
     b0a:	cd bf       	out	0x3d, r28	; 61
     b0c:	7c 01       	movw	r14, r24
     b0e:	6b 01       	movw	r12, r22
     b10:	2e 83       	std	Y+6, r18	; 0x06
     b12:	3f 83       	std	Y+7, r19	; 0x07
     b14:	48 87       	std	Y+8, r20	; 0x08
     b16:	59 87       	std	Y+9, r21	; 0x09
     b18:	10 e0       	ldi	r17, 0x00	; 0
     b1a:	0f b6       	in	r0, 0x3f	; 63
     b1c:	f8 94       	cli
     b1e:	0f 92       	push	r0
     b20:	f7 01       	movw	r30, r14
     b22:	96 8d       	ldd	r25, Z+30	; 0x1e
     b24:	87 8d       	ldd	r24, Z+31	; 0x1f
     b26:	98 17       	cp	r25, r24
     b28:	10 f0       	brcs	.+4      	; 0xb2e <xQueueGenericSend+0x42>
     b2a:	02 30       	cpi	r16, 0x02	; 2
     b2c:	a9 f4       	brne	.+42     	; 0xb58 <xQueueGenericSend+0x6c>
     b2e:	40 2f       	mov	r20, r16
     b30:	b6 01       	movw	r22, r12
     b32:	c7 01       	movw	r24, r14
     b34:	b6 de       	rcall	.-660    	; 0x8a2 <prvCopyDataToQueue>
     b36:	f7 01       	movw	r30, r14
     b38:	93 89       	ldd	r25, Z+19	; 0x13
     b3a:	99 23       	and	r25, r25
     b3c:	39 f0       	breq	.+14     	; 0xb4c <xQueueGenericSend+0x60>
     b3e:	c7 01       	movw	r24, r14
     b40:	43 96       	adiw	r24, 0x13	; 19
     b42:	c5 d5       	rcall	.+2954   	; 0x16ce <xTaskRemoveFromEventList>
     b44:	88 23       	and	r24, r24
     b46:	21 f0       	breq	.+8      	; 0xb50 <xQueueGenericSend+0x64>
     b48:	cd dd       	rcall	.-1126   	; 0x6e4 <vPortYield>
     b4a:	02 c0       	rjmp	.+4      	; 0xb50 <xQueueGenericSend+0x64>
     b4c:	81 11       	cpse	r24, r1
     b4e:	ca dd       	rcall	.-1132   	; 0x6e4 <vPortYield>
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	81 e0       	ldi	r24, 0x01	; 1
     b56:	46 c0       	rjmp	.+140    	; 0xbe4 <xQueueGenericSend+0xf8>
     b58:	8e 81       	ldd	r24, Y+6	; 0x06
     b5a:	9f 81       	ldd	r25, Y+7	; 0x07
     b5c:	a8 85       	ldd	r26, Y+8	; 0x08
     b5e:	b9 85       	ldd	r27, Y+9	; 0x09
     b60:	89 2b       	or	r24, r25
     b62:	8a 2b       	or	r24, r26
     b64:	8b 2b       	or	r24, r27
     b66:	21 f4       	brne	.+8      	; 0xb70 <xQueueGenericSend+0x84>
     b68:	0f 90       	pop	r0
     b6a:	0f be       	out	0x3f, r0	; 63
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	3a c0       	rjmp	.+116    	; 0xbe4 <xQueueGenericSend+0xf8>
     b70:	11 11       	cpse	r17, r1
     b72:	04 c0       	rjmp	.+8      	; 0xb7c <xQueueGenericSend+0x90>
     b74:	ce 01       	movw	r24, r28
     b76:	01 96       	adiw	r24, 0x01	; 1
     b78:	ec d5       	rcall	.+3032   	; 0x1752 <vTaskSetTimeOutState>
     b7a:	11 e0       	ldi	r17, 0x01	; 1
     b7c:	0f 90       	pop	r0
     b7e:	0f be       	out	0x3f, r0	; 63
     b80:	ad d3       	rcall	.+1882   	; 0x12dc <vTaskSuspendAll>
     b82:	0f b6       	in	r0, 0x3f	; 63
     b84:	f8 94       	cli
     b86:	0f 92       	push	r0
     b88:	f7 01       	movw	r30, r14
     b8a:	81 a1       	ldd	r24, Z+33	; 0x21
     b8c:	8f 3f       	cpi	r24, 0xFF	; 255
     b8e:	09 f4       	brne	.+2      	; 0xb92 <xQueueGenericSend+0xa6>
     b90:	11 a2       	std	Z+33, r1	; 0x21
     b92:	f7 01       	movw	r30, r14
     b94:	82 a1       	ldd	r24, Z+34	; 0x22
     b96:	8f 3f       	cpi	r24, 0xFF	; 255
     b98:	09 f4       	brne	.+2      	; 0xb9c <xQueueGenericSend+0xb0>
     b9a:	12 a2       	std	Z+34, r1	; 0x22
     b9c:	0f 90       	pop	r0
     b9e:	0f be       	out	0x3f, r0	; 63
     ba0:	be 01       	movw	r22, r28
     ba2:	6a 5f       	subi	r22, 0xFA	; 250
     ba4:	7f 4f       	sbci	r23, 0xFF	; 255
     ba6:	ce 01       	movw	r24, r28
     ba8:	01 96       	adiw	r24, 0x01	; 1
     baa:	e4 d5       	rcall	.+3016   	; 0x1774 <xTaskCheckForTimeOut>
     bac:	81 11       	cpse	r24, r1
     bae:	16 c0       	rjmp	.+44     	; 0xbdc <xQueueGenericSend+0xf0>
     bb0:	c7 01       	movw	r24, r14
     bb2:	69 de       	rcall	.-814    	; 0x886 <prvIsQueueFull>
     bb4:	88 23       	and	r24, r24
     bb6:	71 f0       	breq	.+28     	; 0xbd4 <xQueueGenericSend+0xe8>
     bb8:	4e 81       	ldd	r20, Y+6	; 0x06
     bba:	5f 81       	ldd	r21, Y+7	; 0x07
     bbc:	68 85       	ldd	r22, Y+8	; 0x08
     bbe:	79 85       	ldd	r23, Y+9	; 0x09
     bc0:	c7 01       	movw	r24, r14
     bc2:	08 96       	adiw	r24, 0x08	; 8
     bc4:	6d d5       	rcall	.+2778   	; 0x16a0 <vTaskPlaceOnEventList>
     bc6:	c7 01       	movw	r24, r14
     bc8:	e5 de       	rcall	.-566    	; 0x994 <prvUnlockQueue>
     bca:	6b d4       	rcall	.+2262   	; 0x14a2 <xTaskResumeAll>
     bcc:	81 11       	cpse	r24, r1
     bce:	a5 cf       	rjmp	.-182    	; 0xb1a <xQueueGenericSend+0x2e>
     bd0:	89 dd       	rcall	.-1262   	; 0x6e4 <vPortYield>
     bd2:	a3 cf       	rjmp	.-186    	; 0xb1a <xQueueGenericSend+0x2e>
     bd4:	c7 01       	movw	r24, r14
     bd6:	de de       	rcall	.-580    	; 0x994 <prvUnlockQueue>
     bd8:	64 d4       	rcall	.+2248   	; 0x14a2 <xTaskResumeAll>
     bda:	9f cf       	rjmp	.-194    	; 0xb1a <xQueueGenericSend+0x2e>
     bdc:	c7 01       	movw	r24, r14
     bde:	da de       	rcall	.-588    	; 0x994 <prvUnlockQueue>
     be0:	60 d4       	rcall	.+2240   	; 0x14a2 <xTaskResumeAll>
     be2:	80 e0       	ldi	r24, 0x00	; 0
     be4:	29 96       	adiw	r28, 0x09	; 9
     be6:	0f b6       	in	r0, 0x3f	; 63
     be8:	f8 94       	cli
     bea:	de bf       	out	0x3e, r29	; 62
     bec:	0f be       	out	0x3f, r0	; 63
     bee:	cd bf       	out	0x3d, r28	; 61
     bf0:	df 91       	pop	r29
     bf2:	cf 91       	pop	r28
     bf4:	1f 91       	pop	r17
     bf6:	0f 91       	pop	r16
     bf8:	ff 90       	pop	r15
     bfa:	ef 90       	pop	r14
     bfc:	df 90       	pop	r13
     bfe:	cf 90       	pop	r12
     c00:	08 95       	ret

00000c02 <prvInitialiseMutex>:
     c02:	0f 93       	push	r16
     c04:	00 97       	sbiw	r24, 0x00	; 0
     c06:	69 f0       	breq	.+26     	; 0xc22 <prvInitialiseMutex+0x20>
     c08:	fc 01       	movw	r30, r24
     c0a:	13 82       	std	Z+3, r1	; 0x03
     c0c:	12 82       	std	Z+2, r1	; 0x02
     c0e:	11 82       	std	Z+1, r1	; 0x01
     c10:	10 82       	st	Z, r1
     c12:	16 82       	std	Z+6, r1	; 0x06
     c14:	00 e0       	ldi	r16, 0x00	; 0
     c16:	20 e0       	ldi	r18, 0x00	; 0
     c18:	30 e0       	ldi	r19, 0x00	; 0
     c1a:	a9 01       	movw	r20, r18
     c1c:	60 e0       	ldi	r22, 0x00	; 0
     c1e:	70 e0       	ldi	r23, 0x00	; 0
     c20:	65 df       	rcall	.-310    	; 0xaec <xQueueGenericSend>
     c22:	0f 91       	pop	r16
     c24:	08 95       	ret

00000c26 <xQueueCreateMutex>:
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	48 2f       	mov	r20, r24
     c2c:	60 e0       	ldi	r22, 0x00	; 0
     c2e:	81 e0       	ldi	r24, 0x01	; 1
     c30:	35 df       	rcall	.-406    	; 0xa9c <xQueueGenericCreate>
     c32:	ec 01       	movw	r28, r24
     c34:	e6 df       	rcall	.-52     	; 0xc02 <prvInitialiseMutex>
     c36:	ce 01       	movw	r24, r28
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	08 95       	ret

00000c3e <xQueueGenericSendFromISR>:
     c3e:	ef 92       	push	r14
     c40:	ff 92       	push	r15
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
     c4a:	8a 01       	movw	r16, r20
     c4c:	fc 01       	movw	r30, r24
     c4e:	56 8d       	ldd	r21, Z+30	; 0x1e
     c50:	37 8d       	ldd	r19, Z+31	; 0x1f
     c52:	53 17       	cp	r21, r19
     c54:	10 f0       	brcs	.+4      	; 0xc5a <xQueueGenericSendFromISR+0x1c>
     c56:	22 30       	cpi	r18, 0x02	; 2
     c58:	e1 f4       	brne	.+56     	; 0xc92 <xQueueGenericSendFromISR+0x54>
     c5a:	42 2f       	mov	r20, r18
     c5c:	78 01       	movw	r14, r16
     c5e:	ec 01       	movw	r28, r24
     c60:	1a a1       	ldd	r17, Y+34	; 0x22
     c62:	1f de       	rcall	.-962    	; 0x8a2 <prvCopyDataToQueue>
     c64:	1f 3f       	cpi	r17, 0xFF	; 255
     c66:	79 f4       	brne	.+30     	; 0xc86 <xQueueGenericSendFromISR+0x48>
     c68:	8b 89       	ldd	r24, Y+19	; 0x13
     c6a:	88 23       	and	r24, r24
     c6c:	a1 f0       	breq	.+40     	; 0xc96 <xQueueGenericSendFromISR+0x58>
     c6e:	ce 01       	movw	r24, r28
     c70:	43 96       	adiw	r24, 0x13	; 19
     c72:	2d d5       	rcall	.+2650   	; 0x16ce <xTaskRemoveFromEventList>
     c74:	88 23       	and	r24, r24
     c76:	89 f0       	breq	.+34     	; 0xc9a <xQueueGenericSendFromISR+0x5c>
     c78:	e1 14       	cp	r14, r1
     c7a:	f1 04       	cpc	r15, r1
     c7c:	81 f0       	breq	.+32     	; 0xc9e <xQueueGenericSendFromISR+0x60>
     c7e:	81 e0       	ldi	r24, 0x01	; 1
     c80:	f7 01       	movw	r30, r14
     c82:	80 83       	st	Z, r24
     c84:	0d c0       	rjmp	.+26     	; 0xca0 <xQueueGenericSendFromISR+0x62>
     c86:	ff 24       	eor	r15, r15
     c88:	f3 94       	inc	r15
     c8a:	f1 0e       	add	r15, r17
     c8c:	fa a2       	std	Y+34, r15	; 0x22
     c8e:	81 e0       	ldi	r24, 0x01	; 1
     c90:	07 c0       	rjmp	.+14     	; 0xca0 <xQueueGenericSendFromISR+0x62>
     c92:	80 e0       	ldi	r24, 0x00	; 0
     c94:	05 c0       	rjmp	.+10     	; 0xca0 <xQueueGenericSendFromISR+0x62>
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	03 c0       	rjmp	.+6      	; 0xca0 <xQueueGenericSendFromISR+0x62>
     c9a:	81 e0       	ldi	r24, 0x01	; 1
     c9c:	01 c0       	rjmp	.+2      	; 0xca0 <xQueueGenericSendFromISR+0x62>
     c9e:	81 e0       	ldi	r24, 0x01	; 1
     ca0:	df 91       	pop	r29
     ca2:	cf 91       	pop	r28
     ca4:	1f 91       	pop	r17
     ca6:	0f 91       	pop	r16
     ca8:	ff 90       	pop	r15
     caa:	ef 90       	pop	r14
     cac:	08 95       	ret

00000cae <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     cae:	8f 92       	push	r8
     cb0:	9f 92       	push	r9
     cb2:	bf 92       	push	r11
     cb4:	cf 92       	push	r12
     cb6:	df 92       	push	r13
     cb8:	ef 92       	push	r14
     cba:	ff 92       	push	r15
     cbc:	0f 93       	push	r16
     cbe:	1f 93       	push	r17
     cc0:	cf 93       	push	r28
     cc2:	df 93       	push	r29
     cc4:	cd b7       	in	r28, 0x3d	; 61
     cc6:	de b7       	in	r29, 0x3e	; 62
     cc8:	29 97       	sbiw	r28, 0x09	; 9
     cca:	0f b6       	in	r0, 0x3f	; 63
     ccc:	f8 94       	cli
     cce:	de bf       	out	0x3e, r29	; 62
     cd0:	0f be       	out	0x3f, r0	; 63
     cd2:	cd bf       	out	0x3d, r28	; 61
     cd4:	7c 01       	movw	r14, r24
     cd6:	6b 01       	movw	r12, r22
     cd8:	2e 83       	std	Y+6, r18	; 0x06
     cda:	3f 83       	std	Y+7, r19	; 0x07
     cdc:	48 87       	std	Y+8, r20	; 0x08
     cde:	59 87       	std	Y+9, r21	; 0x09
     ce0:	b0 2e       	mov	r11, r16
BaseType_t xEntryTimeSet = pdFALSE;
     ce2:	00 e0       	ldi	r16, 0x00	; 0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ce4:	0f b6       	in	r0, 0x3f	; 63
     ce6:	f8 94       	cli
     ce8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     cea:	f7 01       	movw	r30, r14
     cec:	16 8d       	ldd	r17, Z+30	; 0x1e

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     cee:	11 23       	and	r17, r17
     cf0:	61 f1       	breq	.+88     	; 0xd4a <xQueueGenericReceive+0x9c>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     cf2:	86 80       	ldd	r8, Z+6	; 0x06
     cf4:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     cf6:	b6 01       	movw	r22, r12
     cf8:	c7 01       	movw	r24, r14
     cfa:	32 de       	rcall	.-924    	; 0x960 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     cfc:	b1 10       	cpse	r11, r1
     cfe:	16 c0       	rjmp	.+44     	; 0xd2c <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     d00:	11 50       	subi	r17, 0x01	; 1
     d02:	f7 01       	movw	r30, r14
     d04:	16 8f       	std	Z+30, r17	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d06:	80 81       	ld	r24, Z
     d08:	91 81       	ldd	r25, Z+1	; 0x01
     d0a:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     d0c:	21 f4       	brne	.+8      	; 0xd16 <xQueueGenericReceive+0x68>
     d0e:	3a d6       	rcall	.+3188   	; 0x1984 <pvTaskIncrementMutexHeldCount>
     d10:	f7 01       	movw	r30, r14
     d12:	93 83       	std	Z+3, r25	; 0x03
     d14:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d16:	f7 01       	movw	r30, r14
     d18:	80 85       	ldd	r24, Z+8	; 0x08
     d1a:	88 23       	and	r24, r24
     d1c:	91 f0       	breq	.+36     	; 0xd42 <xQueueGenericReceive+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d1e:	c7 01       	movw	r24, r14
     d20:	08 96       	adiw	r24, 0x08	; 8
     d22:	d5 d4       	rcall	.+2474   	; 0x16ce <xTaskRemoveFromEventList>
     d24:	88 23       	and	r24, r24
						{
							queueYIELD_IF_USING_PREEMPTION();
     d26:	69 f0       	breq	.+26     	; 0xd42 <xQueueGenericReceive+0x94>
     d28:	dd dc       	rcall	.-1606   	; 0x6e4 <vPortYield>
     d2a:	0b c0       	rjmp	.+22     	; 0xd42 <xQueueGenericReceive+0x94>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     d2c:	f7 01       	movw	r30, r14
     d2e:	97 82       	std	Z+7, r9	; 0x07
     d30:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d32:	83 89       	ldd	r24, Z+19	; 0x13
     d34:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d36:	29 f0       	breq	.+10     	; 0xd42 <xQueueGenericReceive+0x94>
     d38:	c7 01       	movw	r24, r14
     d3a:	43 96       	adiw	r24, 0x13	; 19
     d3c:	c8 d4       	rcall	.+2448   	; 0x16ce <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     d3e:	81 11       	cpse	r24, r1
     d40:	d1 dc       	rcall	.-1630   	; 0x6e4 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     d42:	0f 90       	pop	r0
     d44:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     d46:	81 e0       	ldi	r24, 0x01	; 1
     d48:	58 c0       	rjmp	.+176    	; 0xdfa <xQueueGenericReceive+0x14c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     d4a:	8e 81       	ldd	r24, Y+6	; 0x06
     d4c:	9f 81       	ldd	r25, Y+7	; 0x07
     d4e:	a8 85       	ldd	r26, Y+8	; 0x08
     d50:	b9 85       	ldd	r27, Y+9	; 0x09
     d52:	89 2b       	or	r24, r25
     d54:	8a 2b       	or	r24, r26
     d56:	8b 2b       	or	r24, r27
     d58:	21 f4       	brne	.+8      	; 0xd62 <xQueueGenericReceive+0xb4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     d5a:	0f 90       	pop	r0
     d5c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     d5e:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     d60:	4c c0       	rjmp	.+152    	; 0xdfa <xQueueGenericReceive+0x14c>
     d62:	01 11       	cpse	r16, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d64:	04 c0       	rjmp	.+8      	; 0xd6e <xQueueGenericReceive+0xc0>
     d66:	ce 01       	movw	r24, r28
     d68:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     d6a:	f3 d4       	rcall	.+2534   	; 0x1752 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     d6c:	01 e0       	ldi	r16, 0x01	; 1
     d6e:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     d70:	0f be       	out	0x3f, r0	; 63
     d72:	b4 d2       	rcall	.+1384   	; 0x12dc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	f8 94       	cli
     d78:	0f 92       	push	r0
     d7a:	f7 01       	movw	r30, r14
     d7c:	81 a1       	ldd	r24, Z+33	; 0x21
     d7e:	8f 3f       	cpi	r24, 0xFF	; 255
     d80:	09 f4       	brne	.+2      	; 0xd84 <xQueueGenericReceive+0xd6>
     d82:	11 a2       	std	Z+33, r1	; 0x21
     d84:	f7 01       	movw	r30, r14
     d86:	82 a1       	ldd	r24, Z+34	; 0x22
     d88:	8f 3f       	cpi	r24, 0xFF	; 255
     d8a:	09 f4       	brne	.+2      	; 0xd8e <xQueueGenericReceive+0xe0>
     d8c:	12 a2       	std	Z+34, r1	; 0x22
     d8e:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d90:	0f be       	out	0x3f, r0	; 63
     d92:	be 01       	movw	r22, r28
     d94:	6a 5f       	subi	r22, 0xFA	; 250
     d96:	7f 4f       	sbci	r23, 0xFF	; 255
     d98:	ce 01       	movw	r24, r28
     d9a:	01 96       	adiw	r24, 0x01	; 1
     d9c:	eb d4       	rcall	.+2518   	; 0x1774 <xTaskCheckForTimeOut>
     d9e:	81 11       	cpse	r24, r1
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     da0:	23 c0       	rjmp	.+70     	; 0xde8 <xQueueGenericReceive+0x13a>
     da2:	c7 01       	movw	r24, r14
     da4:	63 dd       	rcall	.-1338   	; 0x86c <prvIsQueueEmpty>
     da6:	88 23       	and	r24, r24
     da8:	d9 f0       	breq	.+54     	; 0xde0 <xQueueGenericReceive+0x132>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     daa:	f7 01       	movw	r30, r14
     dac:	80 81       	ld	r24, Z
     dae:	91 81       	ldd	r25, Z+1	; 0x01
     db0:	89 2b       	or	r24, r25
					{
						taskENTER_CRITICAL();
     db2:	41 f4       	brne	.+16     	; 0xdc4 <xQueueGenericReceive+0x116>
     db4:	0f b6       	in	r0, 0x3f	; 63
     db6:	f8 94       	cli
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     db8:	0f 92       	push	r0
     dba:	82 81       	ldd	r24, Z+2	; 0x02
     dbc:	93 81       	ldd	r25, Z+3	; 0x03
						}
						taskEXIT_CRITICAL();
     dbe:	44 d5       	rcall	.+2696   	; 0x1848 <vTaskPriorityInherit>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     dc0:	0f 90       	pop	r0
     dc2:	0f be       	out	0x3f, r0	; 63
     dc4:	4e 81       	ldd	r20, Y+6	; 0x06
     dc6:	5f 81       	ldd	r21, Y+7	; 0x07
     dc8:	68 85       	ldd	r22, Y+8	; 0x08
				prvUnlockQueue( pxQueue );
     dca:	79 85       	ldd	r23, Y+9	; 0x09
				if( xTaskResumeAll() == pdFALSE )
     dcc:	c7 01       	movw	r24, r14
     dce:	43 96       	adiw	r24, 0x13	; 19
     dd0:	67 d4       	rcall	.+2254   	; 0x16a0 <vTaskPlaceOnEventList>
				{
					portYIELD_WITHIN_API();
     dd2:	c7 01       	movw	r24, r14
     dd4:	df dd       	rcall	.-1090   	; 0x994 <prvUnlockQueue>
     dd6:	65 d3       	rcall	.+1738   	; 0x14a2 <xTaskResumeAll>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     dd8:	81 11       	cpse	r24, r1
     dda:	84 cf       	rjmp	.-248    	; 0xce4 <xQueueGenericReceive+0x36>
     ddc:	83 dc       	rcall	.-1786   	; 0x6e4 <vPortYield>
				( void ) xTaskResumeAll();
     dde:	82 cf       	rjmp	.-252    	; 0xce4 <xQueueGenericReceive+0x36>
     de0:	c7 01       	movw	r24, r14
     de2:	d8 dd       	rcall	.-1104   	; 0x994 <prvUnlockQueue>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     de4:	5e d3       	rcall	.+1724   	; 0x14a2 <xTaskResumeAll>
     de6:	7e cf       	rjmp	.-260    	; 0xce4 <xQueueGenericReceive+0x36>
     de8:	c7 01       	movw	r24, r14
			( void ) xTaskResumeAll();
     dea:	d4 dd       	rcall	.-1112   	; 0x994 <prvUnlockQueue>
     dec:	5a d3       	rcall	.+1716   	; 0x14a2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     dee:	c7 01       	movw	r24, r14
     df0:	3d dd       	rcall	.-1414   	; 0x86c <prvIsQueueEmpty>
     df2:	88 23       	and	r24, r24
     df4:	09 f4       	brne	.+2      	; 0xdf8 <xQueueGenericReceive+0x14a>
     df6:	76 cf       	rjmp	.-276    	; 0xce4 <xQueueGenericReceive+0x36>
     df8:	80 e0       	ldi	r24, 0x00	; 0
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     dfa:	29 96       	adiw	r28, 0x09	; 9
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     dfc:	0f b6       	in	r0, 0x3f	; 63
     dfe:	f8 94       	cli
     e00:	de bf       	out	0x3e, r29	; 62
     e02:	0f be       	out	0x3f, r0	; 63
     e04:	cd bf       	out	0x3d, r28	; 61
     e06:	df 91       	pop	r29
     e08:	cf 91       	pop	r28
     e0a:	1f 91       	pop	r17
     e0c:	0f 91       	pop	r16
     e0e:	ff 90       	pop	r15
     e10:	ef 90       	pop	r14
     e12:	df 90       	pop	r13
     e14:	cf 90       	pop	r12
     e16:	bf 90       	pop	r11
     e18:	9f 90       	pop	r9
     e1a:	8f 90       	pop	r8
     e1c:	08 95       	ret

00000e1e <prvResetNextTaskUnblockTime>:
     e1e:	e0 91 82 1c 	lds	r30, 0x1C82	; 0x801c82 <pxDelayedTaskList>
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     e22:	f0 91 83 1c 	lds	r31, 0x1C83	; 0x801c83 <pxDelayedTaskList+0x1>
     e26:	80 81       	ld	r24, Z
     e28:	81 11       	cpse	r24, r1
     e2a:	0c c0       	rjmp	.+24     	; 0xe44 <prvResetNextTaskUnblockTime+0x26>
     e2c:	8f ef       	ldi	r24, 0xFF	; 255
     e2e:	9f ef       	ldi	r25, 0xFF	; 255
     e30:	dc 01       	movw	r26, r24
     e32:	80 93 4f 1c 	sts	0x1C4F, r24	; 0x801c4f <xNextTaskUnblockTime>
     e36:	90 93 50 1c 	sts	0x1C50, r25	; 0x801c50 <xNextTaskUnblockTime+0x1>
     e3a:	a0 93 51 1c 	sts	0x1C51, r26	; 0x801c51 <xNextTaskUnblockTime+0x2>
     e3e:	b0 93 52 1c 	sts	0x1C52, r27	; 0x801c52 <xNextTaskUnblockTime+0x3>
     e42:	08 95       	ret
     e44:	e0 91 82 1c 	lds	r30, 0x1C82	; 0x801c82 <pxDelayedTaskList>
     e48:	f0 91 83 1c 	lds	r31, 0x1C83	; 0x801c83 <pxDelayedTaskList+0x1>
     e4c:	07 80       	ldd	r0, Z+7	; 0x07
     e4e:	f0 85       	ldd	r31, Z+8	; 0x08
     e50:	e0 2d       	mov	r30, r0
     e52:	00 84       	ldd	r0, Z+8	; 0x08
     e54:	f1 85       	ldd	r31, Z+9	; 0x09
     e56:	e0 2d       	mov	r30, r0
     e58:	82 81       	ldd	r24, Z+2	; 0x02
     e5a:	93 81       	ldd	r25, Z+3	; 0x03
     e5c:	a4 81       	ldd	r26, Z+4	; 0x04
     e5e:	b5 81       	ldd	r27, Z+5	; 0x05
     e60:	80 93 4f 1c 	sts	0x1C4F, r24	; 0x801c4f <xNextTaskUnblockTime>
     e64:	90 93 50 1c 	sts	0x1C50, r25	; 0x801c50 <xNextTaskUnblockTime+0x1>
     e68:	a0 93 51 1c 	sts	0x1C51, r26	; 0x801c51 <xNextTaskUnblockTime+0x2>
     e6c:	b0 93 52 1c 	sts	0x1C52, r27	; 0x801c52 <xNextTaskUnblockTime+0x3>
     e70:	08 95       	ret

00000e72 <prvDeleteTCB>:
     e72:	cf 93       	push	r28
     e74:	df 93       	push	r29
     e76:	ec 01       	movw	r28, r24
     e78:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e7a:	9c 8d       	ldd	r25, Y+28	; 0x1c
     e7c:	4d db       	rcall	.-2406   	; 0x518 <vPortFree>
     e7e:	ce 01       	movw	r24, r28
     e80:	4b db       	rcall	.-2410   	; 0x518 <vPortFree>
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	08 95       	ret

00000e88 <prvInitialiseNewTask>:
     e88:	6f 92       	push	r6
     e8a:	7f 92       	push	r7
     e8c:	8f 92       	push	r8
     e8e:	9f 92       	push	r9
     e90:	af 92       	push	r10
     e92:	bf 92       	push	r11
     e94:	cf 92       	push	r12
     e96:	df 92       	push	r13
     e98:	ef 92       	push	r14
     e9a:	0f 93       	push	r16
     e9c:	1f 93       	push	r17
     e9e:	cf 93       	push	r28
     ea0:	df 93       	push	r29
     ea2:	cd b7       	in	r28, 0x3d	; 61
     ea4:	de b7       	in	r29, 0x3e	; 62
     ea6:	4c 01       	movw	r8, r24
     ea8:	f5 01       	movw	r30, r10
     eaa:	83 8d       	ldd	r24, Z+27	; 0x1b
     eac:	94 8d       	ldd	r25, Z+28	; 0x1c
     eae:	21 50       	subi	r18, 0x01	; 1
     eb0:	31 09       	sbc	r19, r1
     eb2:	3c 01       	movw	r6, r24
     eb4:	62 0e       	add	r6, r18
     eb6:	73 1e       	adc	r7, r19
     eb8:	20 e0       	ldi	r18, 0x00	; 0
     eba:	0f c0       	rjmp	.+30     	; 0xeda <prvInitialiseNewTask+0x52>
     ebc:	82 2f       	mov	r24, r18
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	fb 01       	movw	r30, r22
     ec2:	e8 0f       	add	r30, r24
     ec4:	f9 1f       	adc	r31, r25
     ec6:	30 81       	ld	r19, Z
     ec8:	d5 01       	movw	r26, r10
     eca:	a8 0f       	add	r26, r24
     ecc:	b9 1f       	adc	r27, r25
     ece:	5d 96       	adiw	r26, 0x1d	; 29
     ed0:	3c 93       	st	X, r19
     ed2:	80 81       	ld	r24, Z
     ed4:	88 23       	and	r24, r24
     ed6:	19 f0       	breq	.+6      	; 0xede <prvInitialiseNewTask+0x56>
     ed8:	2f 5f       	subi	r18, 0xFF	; 255
     eda:	24 31       	cpi	r18, 0x14	; 20
     edc:	78 f3       	brcs	.-34     	; 0xebc <prvInitialiseNewTask+0x34>
     ede:	f5 01       	movw	r30, r10
     ee0:	10 aa       	std	Z+48, r1	; 0x30
     ee2:	f4 e0       	ldi	r31, 0x04	; 4
     ee4:	fe 15       	cp	r31, r14
     ee6:	18 f4       	brcc	.+6      	; 0xeee <prvInitialiseNewTask+0x66>
     ee8:	68 94       	set
     eea:	ee 24       	eor	r14, r14
     eec:	e2 f8       	bld	r14, 2
     eee:	f5 01       	movw	r30, r10
     ef0:	e2 8e       	std	Z+26, r14	; 0x1a
     ef2:	e1 aa       	std	Z+49, r14	; 0x31
     ef4:	12 aa       	std	Z+50, r1	; 0x32
     ef6:	c5 01       	movw	r24, r10
     ef8:	02 96       	adiw	r24, 0x02	; 2
     efa:	73 d9       	rcall	.-3354   	; 0x1e2 <vListInitialiseItem>
     efc:	c5 01       	movw	r24, r10
     efe:	0e 96       	adiw	r24, 0x0e	; 14
     f00:	70 d9       	rcall	.-3360   	; 0x1e2 <vListInitialiseItem>
     f02:	f5 01       	movw	r30, r10
     f04:	b3 86       	std	Z+11, r11	; 0x0b
     f06:	a2 86       	std	Z+10, r10	; 0x0a
     f08:	85 e0       	ldi	r24, 0x05	; 5
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	a0 e0       	ldi	r26, 0x00	; 0
     f0e:	b0 e0       	ldi	r27, 0x00	; 0
     f10:	8e 19       	sub	r24, r14
     f12:	91 09       	sbc	r25, r1
     f14:	a1 09       	sbc	r26, r1
     f16:	b1 09       	sbc	r27, r1
     f18:	86 87       	std	Z+14, r24	; 0x0e
     f1a:	97 87       	std	Z+15, r25	; 0x0f
     f1c:	a0 8b       	std	Z+16, r26	; 0x10
     f1e:	b1 8b       	std	Z+17, r27	; 0x11
     f20:	b7 8a       	std	Z+23, r11	; 0x17
     f22:	a6 8a       	std	Z+22, r10	; 0x16
     f24:	13 aa       	std	Z+51, r1	; 0x33
     f26:	14 aa       	std	Z+52, r1	; 0x34
     f28:	15 aa       	std	Z+53, r1	; 0x35
     f2a:	16 aa       	std	Z+54, r1	; 0x36
     f2c:	17 aa       	std	Z+55, r1	; 0x37
     f2e:	a8 01       	movw	r20, r16
     f30:	b4 01       	movw	r22, r8
     f32:	c3 01       	movw	r24, r6
     f34:	33 db       	rcall	.-2458   	; 0x59c <pxPortInitialiseStack>
     f36:	f5 01       	movw	r30, r10
     f38:	91 83       	std	Z+1, r25	; 0x01
     f3a:	80 83       	st	Z, r24
     f3c:	c1 14       	cp	r12, r1
     f3e:	d1 04       	cpc	r13, r1
     f40:	19 f0       	breq	.+6      	; 0xf48 <prvInitialiseNewTask+0xc0>
     f42:	f6 01       	movw	r30, r12
     f44:	b1 82       	std	Z+1, r11	; 0x01
     f46:	a0 82       	st	Z, r10
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	1f 91       	pop	r17
     f4e:	0f 91       	pop	r16
     f50:	ef 90       	pop	r14
     f52:	df 90       	pop	r13
     f54:	cf 90       	pop	r12
     f56:	bf 90       	pop	r11
     f58:	af 90       	pop	r10
     f5a:	9f 90       	pop	r9
     f5c:	8f 90       	pop	r8
     f5e:	7f 90       	pop	r7
     f60:	6f 90       	pop	r6
     f62:	08 95       	ret

00000f64 <prvInitialiseTaskLists>:
     f64:	cf 93       	push	r28
     f66:	c0 e0       	ldi	r28, 0x00	; 0
     f68:	08 c0       	rjmp	.+16     	; 0xf7a <prvInitialiseTaskLists+0x16>
     f6a:	2b e0       	ldi	r18, 0x0B	; 11
     f6c:	c2 9f       	mul	r28, r18
     f6e:	c0 01       	movw	r24, r0
     f70:	11 24       	eor	r1, r1
     f72:	86 56       	subi	r24, 0x66	; 102
     f74:	93 4e       	sbci	r25, 0xE3	; 227
     f76:	24 d9       	rcall	.-3512   	; 0x1c0 <vListInitialise>
     f78:	cf 5f       	subi	r28, 0xFF	; 255
     f7a:	c5 30       	cpi	r28, 0x05	; 5
     f7c:	b0 f3       	brcs	.-20     	; 0xf6a <prvInitialiseTaskLists+0x6>
     f7e:	8f e8       	ldi	r24, 0x8F	; 143
     f80:	9c e1       	ldi	r25, 0x1C	; 28
     f82:	1e d9       	rcall	.-3524   	; 0x1c0 <vListInitialise>
     f84:	84 e8       	ldi	r24, 0x84	; 132
     f86:	9c e1       	ldi	r25, 0x1C	; 28
     f88:	1b d9       	rcall	.-3530   	; 0x1c0 <vListInitialise>
     f8a:	85 e7       	ldi	r24, 0x75	; 117
     f8c:	9c e1       	ldi	r25, 0x1C	; 28
     f8e:	18 d9       	rcall	.-3536   	; 0x1c0 <vListInitialise>
     f90:	8a e6       	ldi	r24, 0x6A	; 106
     f92:	9c e1       	ldi	r25, 0x1C	; 28
     f94:	15 d9       	rcall	.-3542   	; 0x1c0 <vListInitialise>
     f96:	8e e5       	ldi	r24, 0x5E	; 94
     f98:	9c e1       	ldi	r25, 0x1C	; 28
     f9a:	12 d9       	rcall	.-3548   	; 0x1c0 <vListInitialise>
     f9c:	8f e8       	ldi	r24, 0x8F	; 143
     f9e:	9c e1       	ldi	r25, 0x1C	; 28
     fa0:	90 93 83 1c 	sts	0x1C83, r25	; 0x801c83 <pxDelayedTaskList+0x1>
     fa4:	80 93 82 1c 	sts	0x1C82, r24	; 0x801c82 <pxDelayedTaskList>
     fa8:	84 e8       	ldi	r24, 0x84	; 132
     faa:	9c e1       	ldi	r25, 0x1C	; 28
     fac:	90 93 81 1c 	sts	0x1C81, r25	; 0x801c81 <pxOverflowDelayedTaskList+0x1>
     fb0:	80 93 80 1c 	sts	0x1C80, r24	; 0x801c80 <pxOverflowDelayedTaskList>
     fb4:	cf 91       	pop	r28
     fb6:	08 95       	ret

00000fb8 <prvAddNewTaskToReadyList>:
     fb8:	cf 93       	push	r28
     fba:	df 93       	push	r29
     fbc:	ec 01       	movw	r28, r24
     fbe:	0f b6       	in	r0, 0x3f	; 63
     fc0:	f8 94       	cli
     fc2:	0f 92       	push	r0
     fc4:	80 91 5d 1c 	lds	r24, 0x1C5D	; 0x801c5d <uxCurrentNumberOfTasks>
     fc8:	8f 5f       	subi	r24, 0xFF	; 255
     fca:	80 93 5d 1c 	sts	0x1C5D, r24	; 0x801c5d <uxCurrentNumberOfTasks>
     fce:	80 91 d1 1c 	lds	r24, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
     fd2:	90 91 d2 1c 	lds	r25, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
     fd6:	89 2b       	or	r24, r25
     fd8:	51 f4       	brne	.+20     	; 0xfee <prvAddNewTaskToReadyList+0x36>
     fda:	d0 93 d2 1c 	sts	0x1CD2, r29	; 0x801cd2 <pxCurrentTCB+0x1>
     fde:	c0 93 d1 1c 	sts	0x1CD1, r28	; 0x801cd1 <pxCurrentTCB>
     fe2:	80 91 5d 1c 	lds	r24, 0x1C5D	; 0x801c5d <uxCurrentNumberOfTasks>
     fe6:	81 30       	cpi	r24, 0x01	; 1
     fe8:	91 f4       	brne	.+36     	; 0x100e <__EEPROM_REGION_LENGTH__+0xe>
     fea:	bc df       	rcall	.-136    	; 0xf64 <prvInitialiseTaskLists>
     fec:	10 c0       	rjmp	.+32     	; 0x100e <__EEPROM_REGION_LENGTH__+0xe>
     fee:	80 91 57 1c 	lds	r24, 0x1C57	; 0x801c57 <xSchedulerRunning>
     ff2:	81 11       	cpse	r24, r1
     ff4:	0c c0       	rjmp	.+24     	; 0x100e <__EEPROM_REGION_LENGTH__+0xe>
     ff6:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
     ffa:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
     ffe:	92 8d       	ldd	r25, Z+26	; 0x1a
    1000:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1002:	89 17       	cp	r24, r25
    1004:	20 f0       	brcs	.+8      	; 0x100e <__EEPROM_REGION_LENGTH__+0xe>
    1006:	d0 93 d2 1c 	sts	0x1CD2, r29	; 0x801cd2 <pxCurrentTCB+0x1>
    100a:	c0 93 d1 1c 	sts	0x1CD1, r28	; 0x801cd1 <pxCurrentTCB>
    100e:	80 91 53 1c 	lds	r24, 0x1C53	; 0x801c53 <uxTaskNumber>
    1012:	8f 5f       	subi	r24, 0xFF	; 255
    1014:	80 93 53 1c 	sts	0x1C53, r24	; 0x801c53 <uxTaskNumber>
    1018:	8a 8d       	ldd	r24, Y+26	; 0x1a
    101a:	90 91 58 1c 	lds	r25, 0x1C58	; 0x801c58 <uxTopReadyPriority>
    101e:	98 17       	cp	r25, r24
    1020:	10 f4       	brcc	.+4      	; 0x1026 <__EEPROM_REGION_LENGTH__+0x26>
    1022:	80 93 58 1c 	sts	0x1C58, r24	; 0x801c58 <uxTopReadyPriority>
    1026:	2b e0       	ldi	r18, 0x0B	; 11
    1028:	82 9f       	mul	r24, r18
    102a:	c0 01       	movw	r24, r0
    102c:	11 24       	eor	r1, r1
    102e:	be 01       	movw	r22, r28
    1030:	6e 5f       	subi	r22, 0xFE	; 254
    1032:	7f 4f       	sbci	r23, 0xFF	; 255
    1034:	86 56       	subi	r24, 0x66	; 102
    1036:	93 4e       	sbci	r25, 0xE3	; 227
    1038:	d8 d8       	rcall	.-3664   	; 0x1ea <vListInsertEnd>
    103a:	0f 90       	pop	r0
    103c:	0f be       	out	0x3f, r0	; 63
    103e:	80 91 57 1c 	lds	r24, 0x1C57	; 0x801c57 <xSchedulerRunning>
    1042:	88 23       	and	r24, r24
    1044:	49 f0       	breq	.+18     	; 0x1058 <__EEPROM_REGION_LENGTH__+0x58>
    1046:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    104a:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    104e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1050:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1052:	98 17       	cp	r25, r24
    1054:	08 f4       	brcc	.+2      	; 0x1058 <__EEPROM_REGION_LENGTH__+0x58>
    1056:	46 db       	rcall	.-2420   	; 0x6e4 <vPortYield>
    1058:	df 91       	pop	r29
    105a:	cf 91       	pop	r28
    105c:	08 95       	ret

0000105e <prvAddCurrentTaskToDelayedList>:
    105e:	8f 92       	push	r8
    1060:	9f 92       	push	r9
    1062:	af 92       	push	r10
    1064:	bf 92       	push	r11
    1066:	cf 92       	push	r12
    1068:	df 92       	push	r13
    106a:	ef 92       	push	r14
    106c:	ff 92       	push	r15
    106e:	cf 93       	push	r28
    1070:	6b 01       	movw	r12, r22
    1072:	7c 01       	movw	r14, r24
    1074:	c4 2f       	mov	r28, r20
    1076:	80 90 59 1c 	lds	r8, 0x1C59	; 0x801c59 <xTickCount>
    107a:	90 90 5a 1c 	lds	r9, 0x1C5A	; 0x801c5a <xTickCount+0x1>
    107e:	a0 90 5b 1c 	lds	r10, 0x1C5B	; 0x801c5b <xTickCount+0x2>
    1082:	b0 90 5c 1c 	lds	r11, 0x1C5C	; 0x801c5c <xTickCount+0x3>
    1086:	80 91 d1 1c 	lds	r24, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    108a:	90 91 d2 1c 	lds	r25, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    108e:	02 96       	adiw	r24, 0x02	; 2
    1090:	0a d9       	rcall	.-3564   	; 0x2a6 <uxListRemove>
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	c8 16       	cp	r12, r24
    1096:	d8 06       	cpc	r13, r24
    1098:	e8 06       	cpc	r14, r24
    109a:	f8 06       	cpc	r15, r24
    109c:	61 f4       	brne	.+24     	; 0x10b6 <prvAddCurrentTaskToDelayedList+0x58>
    109e:	cc 23       	and	r28, r28
    10a0:	51 f0       	breq	.+20     	; 0x10b6 <prvAddCurrentTaskToDelayedList+0x58>
    10a2:	60 91 d1 1c 	lds	r22, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    10a6:	70 91 d2 1c 	lds	r23, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    10aa:	6e 5f       	subi	r22, 0xFE	; 254
    10ac:	7f 4f       	sbci	r23, 0xFF	; 255
    10ae:	8e e5       	ldi	r24, 0x5E	; 94
    10b0:	9c e1       	ldi	r25, 0x1C	; 28
    10b2:	9b d8       	rcall	.-3786   	; 0x1ea <vListInsertEnd>
    10b4:	3d c0       	rjmp	.+122    	; 0x1130 <prvAddCurrentTaskToDelayedList+0xd2>
    10b6:	c8 0c       	add	r12, r8
    10b8:	d9 1c       	adc	r13, r9
    10ba:	ea 1c       	adc	r14, r10
    10bc:	fb 1c       	adc	r15, r11
    10be:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    10c2:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    10c6:	c2 82       	std	Z+2, r12	; 0x02
    10c8:	d3 82       	std	Z+3, r13	; 0x03
    10ca:	e4 82       	std	Z+4, r14	; 0x04
    10cc:	f5 82       	std	Z+5, r15	; 0x05
    10ce:	c8 14       	cp	r12, r8
    10d0:	d9 04       	cpc	r13, r9
    10d2:	ea 04       	cpc	r14, r10
    10d4:	fb 04       	cpc	r15, r11
    10d6:	60 f4       	brcc	.+24     	; 0x10f0 <prvAddCurrentTaskToDelayedList+0x92>
    10d8:	60 91 d1 1c 	lds	r22, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    10dc:	70 91 d2 1c 	lds	r23, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    10e0:	80 91 80 1c 	lds	r24, 0x1C80	; 0x801c80 <pxOverflowDelayedTaskList>
    10e4:	90 91 81 1c 	lds	r25, 0x1C81	; 0x801c81 <pxOverflowDelayedTaskList+0x1>
    10e8:	6e 5f       	subi	r22, 0xFE	; 254
    10ea:	7f 4f       	sbci	r23, 0xFF	; 255
    10ec:	9f d8       	rcall	.-3778   	; 0x22c <vListInsert>
    10ee:	20 c0       	rjmp	.+64     	; 0x1130 <prvAddCurrentTaskToDelayedList+0xd2>
    10f0:	60 91 d1 1c 	lds	r22, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    10f4:	70 91 d2 1c 	lds	r23, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    10f8:	80 91 82 1c 	lds	r24, 0x1C82	; 0x801c82 <pxDelayedTaskList>
    10fc:	90 91 83 1c 	lds	r25, 0x1C83	; 0x801c83 <pxDelayedTaskList+0x1>
    1100:	6e 5f       	subi	r22, 0xFE	; 254
    1102:	7f 4f       	sbci	r23, 0xFF	; 255
    1104:	93 d8       	rcall	.-3802   	; 0x22c <vListInsert>
    1106:	80 91 4f 1c 	lds	r24, 0x1C4F	; 0x801c4f <xNextTaskUnblockTime>
    110a:	90 91 50 1c 	lds	r25, 0x1C50	; 0x801c50 <xNextTaskUnblockTime+0x1>
    110e:	a0 91 51 1c 	lds	r26, 0x1C51	; 0x801c51 <xNextTaskUnblockTime+0x2>
    1112:	b0 91 52 1c 	lds	r27, 0x1C52	; 0x801c52 <xNextTaskUnblockTime+0x3>
    1116:	c8 16       	cp	r12, r24
    1118:	d9 06       	cpc	r13, r25
    111a:	ea 06       	cpc	r14, r26
    111c:	fb 06       	cpc	r15, r27
    111e:	40 f4       	brcc	.+16     	; 0x1130 <prvAddCurrentTaskToDelayedList+0xd2>
    1120:	c0 92 4f 1c 	sts	0x1C4F, r12	; 0x801c4f <xNextTaskUnblockTime>
    1124:	d0 92 50 1c 	sts	0x1C50, r13	; 0x801c50 <xNextTaskUnblockTime+0x1>
    1128:	e0 92 51 1c 	sts	0x1C51, r14	; 0x801c51 <xNextTaskUnblockTime+0x2>
    112c:	f0 92 52 1c 	sts	0x1C52, r15	; 0x801c52 <xNextTaskUnblockTime+0x3>
    1130:	cf 91       	pop	r28
    1132:	ff 90       	pop	r15
    1134:	ef 90       	pop	r14
    1136:	df 90       	pop	r13
    1138:	cf 90       	pop	r12
    113a:	bf 90       	pop	r11
    113c:	af 90       	pop	r10
    113e:	9f 90       	pop	r9
    1140:	8f 90       	pop	r8
    1142:	08 95       	ret

00001144 <xTaskCreate>:
    1144:	2f 92       	push	r2
    1146:	3f 92       	push	r3
    1148:	4f 92       	push	r4
    114a:	5f 92       	push	r5
    114c:	6f 92       	push	r6
    114e:	7f 92       	push	r7
    1150:	8f 92       	push	r8
    1152:	9f 92       	push	r9
    1154:	af 92       	push	r10
    1156:	bf 92       	push	r11
    1158:	cf 92       	push	r12
    115a:	df 92       	push	r13
    115c:	ef 92       	push	r14
    115e:	ff 92       	push	r15
    1160:	0f 93       	push	r16
    1162:	1f 93       	push	r17
    1164:	cf 93       	push	r28
    1166:	df 93       	push	r29
    1168:	3c 01       	movw	r6, r24
    116a:	1b 01       	movw	r2, r22
    116c:	5a 01       	movw	r10, r20
    116e:	29 01       	movw	r4, r18
    1170:	ca 01       	movw	r24, r20
    1172:	40 d9       	rcall	.-3456   	; 0x3f4 <pvPortMalloc>
    1174:	6c 01       	movw	r12, r24
    1176:	89 2b       	or	r24, r25
    1178:	61 f0       	breq	.+24     	; 0x1192 <xTaskCreate+0x4e>
    117a:	88 e3       	ldi	r24, 0x38	; 56
    117c:	90 e0       	ldi	r25, 0x00	; 0
    117e:	3a d9       	rcall	.-3468   	; 0x3f4 <pvPortMalloc>
    1180:	ec 01       	movw	r28, r24
    1182:	89 2b       	or	r24, r25
    1184:	19 f0       	breq	.+6      	; 0x118c <xTaskCreate+0x48>
    1186:	dc 8e       	std	Y+28, r13	; 0x1c
    1188:	cb 8e       	std	Y+27, r12	; 0x1b
    118a:	05 c0       	rjmp	.+10     	; 0x1196 <xTaskCreate+0x52>
    118c:	c6 01       	movw	r24, r12
    118e:	c4 d9       	rcall	.-3192   	; 0x518 <vPortFree>
    1190:	02 c0       	rjmp	.+4      	; 0x1196 <xTaskCreate+0x52>
    1192:	c0 e0       	ldi	r28, 0x00	; 0
    1194:	d0 e0       	ldi	r29, 0x00	; 0
    1196:	20 97       	sbiw	r28, 0x00	; 0
    1198:	81 f0       	breq	.+32     	; 0x11ba <xTaskCreate+0x76>
    119a:	95 01       	movw	r18, r10
    119c:	40 e0       	ldi	r20, 0x00	; 0
    119e:	50 e0       	ldi	r21, 0x00	; 0
    11a0:	81 2c       	mov	r8, r1
    11a2:	91 2c       	mov	r9, r1
    11a4:	5e 01       	movw	r10, r28
    11a6:	67 01       	movw	r12, r14
    11a8:	e0 2e       	mov	r14, r16
    11aa:	82 01       	movw	r16, r4
    11ac:	b1 01       	movw	r22, r2
    11ae:	c3 01       	movw	r24, r6
    11b0:	6b de       	rcall	.-810    	; 0xe88 <prvInitialiseNewTask>
    11b2:	ce 01       	movw	r24, r28
    11b4:	01 df       	rcall	.-510    	; 0xfb8 <prvAddNewTaskToReadyList>
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	01 c0       	rjmp	.+2      	; 0x11bc <xTaskCreate+0x78>
    11ba:	8f ef       	ldi	r24, 0xFF	; 255
    11bc:	df 91       	pop	r29
    11be:	cf 91       	pop	r28
    11c0:	1f 91       	pop	r17
    11c2:	0f 91       	pop	r16
    11c4:	ff 90       	pop	r15
    11c6:	ef 90       	pop	r14
    11c8:	df 90       	pop	r13
    11ca:	cf 90       	pop	r12
    11cc:	bf 90       	pop	r11
    11ce:	af 90       	pop	r10
    11d0:	9f 90       	pop	r9
    11d2:	8f 90       	pop	r8
    11d4:	7f 90       	pop	r7
    11d6:	6f 90       	pop	r6
    11d8:	5f 90       	pop	r5
    11da:	4f 90       	pop	r4
    11dc:	3f 90       	pop	r3
    11de:	2f 90       	pop	r2
    11e0:	08 95       	ret

000011e2 <vTaskDelete>:
    11e2:	0f 93       	push	r16
    11e4:	1f 93       	push	r17
    11e6:	cf 93       	push	r28
    11e8:	df 93       	push	r29
    11ea:	ec 01       	movw	r28, r24
    11ec:	0f b6       	in	r0, 0x3f	; 63
    11ee:	f8 94       	cli
    11f0:	0f 92       	push	r0
    11f2:	89 2b       	or	r24, r25
    11f4:	21 f4       	brne	.+8      	; 0x11fe <vTaskDelete+0x1c>
    11f6:	c0 91 d1 1c 	lds	r28, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    11fa:	d0 91 d2 1c 	lds	r29, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    11fe:	8e 01       	movw	r16, r28
    1200:	0e 5f       	subi	r16, 0xFE	; 254
    1202:	1f 4f       	sbci	r17, 0xFF	; 255
    1204:	c8 01       	movw	r24, r16
    1206:	4f d8       	rcall	.-3938   	; 0x2a6 <uxListRemove>
    1208:	88 8d       	ldd	r24, Y+24	; 0x18
    120a:	99 8d       	ldd	r25, Y+25	; 0x19
    120c:	89 2b       	or	r24, r25
    120e:	19 f0       	breq	.+6      	; 0x1216 <vTaskDelete+0x34>
    1210:	ce 01       	movw	r24, r28
    1212:	0e 96       	adiw	r24, 0x0e	; 14
    1214:	48 d8       	rcall	.-3952   	; 0x2a6 <uxListRemove>
    1216:	80 91 53 1c 	lds	r24, 0x1C53	; 0x801c53 <uxTaskNumber>
    121a:	8f 5f       	subi	r24, 0xFF	; 255
    121c:	80 93 53 1c 	sts	0x1C53, r24	; 0x801c53 <uxTaskNumber>
    1220:	80 91 d1 1c 	lds	r24, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    1224:	90 91 d2 1c 	lds	r25, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1228:	c8 17       	cp	r28, r24
    122a:	d9 07       	cpc	r29, r25
    122c:	59 f4       	brne	.+22     	; 0x1244 <vTaskDelete+0x62>
    122e:	b8 01       	movw	r22, r16
    1230:	8a e6       	ldi	r24, 0x6A	; 106
    1232:	9c e1       	ldi	r25, 0x1C	; 28
    1234:	0e 94 f5 00 	call	0x1ea	; 0x1ea <vListInsertEnd>
    1238:	80 91 69 1c 	lds	r24, 0x1C69	; 0x801c69 <uxDeletedTasksWaitingCleanUp>
    123c:	8f 5f       	subi	r24, 0xFF	; 255
    123e:	80 93 69 1c 	sts	0x1C69, r24	; 0x801c69 <uxDeletedTasksWaitingCleanUp>
    1242:	08 c0       	rjmp	.+16     	; 0x1254 <vTaskDelete+0x72>
    1244:	80 91 5d 1c 	lds	r24, 0x1C5D	; 0x801c5d <uxCurrentNumberOfTasks>
    1248:	81 50       	subi	r24, 0x01	; 1
    124a:	80 93 5d 1c 	sts	0x1C5D, r24	; 0x801c5d <uxCurrentNumberOfTasks>
    124e:	ce 01       	movw	r24, r28
    1250:	10 de       	rcall	.-992    	; 0xe72 <prvDeleteTCB>
    1252:	e5 dd       	rcall	.-1078   	; 0xe1e <prvResetNextTaskUnblockTime>
    1254:	0f 90       	pop	r0
    1256:	0f be       	out	0x3f, r0	; 63
    1258:	80 91 57 1c 	lds	r24, 0x1C57	; 0x801c57 <xSchedulerRunning>
    125c:	88 23       	and	r24, r24
    125e:	41 f0       	breq	.+16     	; 0x1270 <vTaskDelete+0x8e>
    1260:	80 91 d1 1c 	lds	r24, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    1264:	90 91 d2 1c 	lds	r25, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1268:	c8 17       	cp	r28, r24
    126a:	d9 07       	cpc	r29, r25
    126c:	09 f4       	brne	.+2      	; 0x1270 <vTaskDelete+0x8e>
    126e:	3a da       	rcall	.-2956   	; 0x6e4 <vPortYield>
    1270:	df 91       	pop	r29
    1272:	cf 91       	pop	r28
    1274:	1f 91       	pop	r17
    1276:	0f 91       	pop	r16
    1278:	08 95       	ret

0000127a <vTaskStartScheduler>:
    127a:	ef 92       	push	r14
    127c:	ff 92       	push	r15
    127e:	0f 93       	push	r16
    1280:	0f 2e       	mov	r0, r31
    1282:	fd e4       	ldi	r31, 0x4D	; 77
    1284:	ef 2e       	mov	r14, r31
    1286:	fc e1       	ldi	r31, 0x1C	; 28
    1288:	ff 2e       	mov	r15, r31
    128a:	f0 2d       	mov	r31, r0
    128c:	00 e0       	ldi	r16, 0x00	; 0
    128e:	20 e0       	ldi	r18, 0x00	; 0
    1290:	30 e0       	ldi	r19, 0x00	; 0
    1292:	40 e0       	ldi	r20, 0x00	; 0
    1294:	54 e0       	ldi	r21, 0x04	; 4
    1296:	6c e0       	ldi	r22, 0x0C	; 12
    1298:	72 e0       	ldi	r23, 0x02	; 2
    129a:	8f ef       	ldi	r24, 0xFF	; 255
    129c:	9a e0       	ldi	r25, 0x0A	; 10
    129e:	52 df       	rcall	.-348    	; 0x1144 <xTaskCreate>
    12a0:	81 30       	cpi	r24, 0x01	; 1
    12a2:	c1 f4       	brne	.+48     	; 0x12d4 <vTaskStartScheduler+0x5a>
    12a4:	f8 94       	cli
    12a6:	8f ef       	ldi	r24, 0xFF	; 255
    12a8:	9f ef       	ldi	r25, 0xFF	; 255
    12aa:	dc 01       	movw	r26, r24
    12ac:	80 93 4f 1c 	sts	0x1C4F, r24	; 0x801c4f <xNextTaskUnblockTime>
    12b0:	90 93 50 1c 	sts	0x1C50, r25	; 0x801c50 <xNextTaskUnblockTime+0x1>
    12b4:	a0 93 51 1c 	sts	0x1C51, r26	; 0x801c51 <xNextTaskUnblockTime+0x2>
    12b8:	b0 93 52 1c 	sts	0x1C52, r27	; 0x801c52 <xNextTaskUnblockTime+0x3>
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	80 93 57 1c 	sts	0x1C57, r24	; 0x801c57 <xSchedulerRunning>
    12c2:	10 92 59 1c 	sts	0x1C59, r1	; 0x801c59 <xTickCount>
    12c6:	10 92 5a 1c 	sts	0x1C5A, r1	; 0x801c5a <xTickCount+0x1>
    12ca:	10 92 5b 1c 	sts	0x1C5B, r1	; 0x801c5b <xTickCount+0x2>
    12ce:	10 92 5c 1c 	sts	0x1C5C, r1	; 0x801c5c <xTickCount+0x3>
    12d2:	d6 d9       	rcall	.-3156   	; 0x680 <xPortStartScheduler>
    12d4:	0f 91       	pop	r16
    12d6:	ff 90       	pop	r15
    12d8:	ef 90       	pop	r14
    12da:	08 95       	ret

000012dc <vTaskSuspendAll>:
    12dc:	80 91 4c 1c 	lds	r24, 0x1C4C	; 0x801c4c <uxSchedulerSuspended>
    12e0:	8f 5f       	subi	r24, 0xFF	; 255
    12e2:	80 93 4c 1c 	sts	0x1C4C, r24	; 0x801c4c <uxSchedulerSuspended>
    12e6:	08 95       	ret

000012e8 <xTaskGetTickCount>:
    12e8:	0f b6       	in	r0, 0x3f	; 63
    12ea:	f8 94       	cli
    12ec:	0f 92       	push	r0
    12ee:	60 91 59 1c 	lds	r22, 0x1C59	; 0x801c59 <xTickCount>
    12f2:	70 91 5a 1c 	lds	r23, 0x1C5A	; 0x801c5a <xTickCount+0x1>
    12f6:	80 91 5b 1c 	lds	r24, 0x1C5B	; 0x801c5b <xTickCount+0x2>
    12fa:	90 91 5c 1c 	lds	r25, 0x1C5C	; 0x801c5c <xTickCount+0x3>
    12fe:	0f 90       	pop	r0
    1300:	0f be       	out	0x3f, r0	; 63
    1302:	08 95       	ret

00001304 <xTaskIncrementTick>:
    1304:	bf 92       	push	r11
    1306:	cf 92       	push	r12
    1308:	df 92       	push	r13
    130a:	ef 92       	push	r14
    130c:	ff 92       	push	r15
    130e:	0f 93       	push	r16
    1310:	1f 93       	push	r17
    1312:	cf 93       	push	r28
    1314:	df 93       	push	r29
    1316:	80 91 4c 1c 	lds	r24, 0x1C4C	; 0x801c4c <uxSchedulerSuspended>
    131a:	81 11       	cpse	r24, r1
    131c:	a8 c0       	rjmp	.+336    	; 0x146e <xTaskIncrementTick+0x16a>
    131e:	c0 90 59 1c 	lds	r12, 0x1C59	; 0x801c59 <xTickCount>
    1322:	d0 90 5a 1c 	lds	r13, 0x1C5A	; 0x801c5a <xTickCount+0x1>
    1326:	e0 90 5b 1c 	lds	r14, 0x1C5B	; 0x801c5b <xTickCount+0x2>
    132a:	f0 90 5c 1c 	lds	r15, 0x1C5C	; 0x801c5c <xTickCount+0x3>
    132e:	2f ef       	ldi	r18, 0xFF	; 255
    1330:	c2 1a       	sub	r12, r18
    1332:	d2 0a       	sbc	r13, r18
    1334:	e2 0a       	sbc	r14, r18
    1336:	f2 0a       	sbc	r15, r18
    1338:	c0 92 59 1c 	sts	0x1C59, r12	; 0x801c59 <xTickCount>
    133c:	d0 92 5a 1c 	sts	0x1C5A, r13	; 0x801c5a <xTickCount+0x1>
    1340:	e0 92 5b 1c 	sts	0x1C5B, r14	; 0x801c5b <xTickCount+0x2>
    1344:	f0 92 5c 1c 	sts	0x1C5C, r15	; 0x801c5c <xTickCount+0x3>
    1348:	c1 14       	cp	r12, r1
    134a:	d1 04       	cpc	r13, r1
    134c:	e1 04       	cpc	r14, r1
    134e:	f1 04       	cpc	r15, r1
    1350:	b1 f4       	brne	.+44     	; 0x137e <xTaskIncrementTick+0x7a>
    1352:	80 91 82 1c 	lds	r24, 0x1C82	; 0x801c82 <pxDelayedTaskList>
    1356:	90 91 83 1c 	lds	r25, 0x1C83	; 0x801c83 <pxDelayedTaskList+0x1>
    135a:	20 91 80 1c 	lds	r18, 0x1C80	; 0x801c80 <pxOverflowDelayedTaskList>
    135e:	30 91 81 1c 	lds	r19, 0x1C81	; 0x801c81 <pxOverflowDelayedTaskList+0x1>
    1362:	30 93 83 1c 	sts	0x1C83, r19	; 0x801c83 <pxDelayedTaskList+0x1>
    1366:	20 93 82 1c 	sts	0x1C82, r18	; 0x801c82 <pxDelayedTaskList>
    136a:	90 93 81 1c 	sts	0x1C81, r25	; 0x801c81 <pxOverflowDelayedTaskList+0x1>
    136e:	80 93 80 1c 	sts	0x1C80, r24	; 0x801c80 <pxOverflowDelayedTaskList>
    1372:	80 91 54 1c 	lds	r24, 0x1C54	; 0x801c54 <xNumOfOverflows>
    1376:	8f 5f       	subi	r24, 0xFF	; 255
    1378:	80 93 54 1c 	sts	0x1C54, r24	; 0x801c54 <xNumOfOverflows>
    137c:	50 dd       	rcall	.-1376   	; 0xe1e <prvResetNextTaskUnblockTime>
    137e:	80 91 4f 1c 	lds	r24, 0x1C4F	; 0x801c4f <xNextTaskUnblockTime>
    1382:	90 91 50 1c 	lds	r25, 0x1C50	; 0x801c50 <xNextTaskUnblockTime+0x1>
    1386:	a0 91 51 1c 	lds	r26, 0x1C51	; 0x801c51 <xNextTaskUnblockTime+0x2>
    138a:	b0 91 52 1c 	lds	r27, 0x1C52	; 0x801c52 <xNextTaskUnblockTime+0x3>
    138e:	c8 16       	cp	r12, r24
    1390:	d9 06       	cpc	r13, r25
    1392:	ea 06       	cpc	r14, r26
    1394:	fb 06       	cpc	r15, r27
    1396:	28 f4       	brcc	.+10     	; 0x13a2 <xTaskIncrementTick+0x9e>
    1398:	b1 2c       	mov	r11, r1
    139a:	5a c0       	rjmp	.+180    	; 0x1450 <xTaskIncrementTick+0x14c>
    139c:	bb 24       	eor	r11, r11
    139e:	b3 94       	inc	r11
    13a0:	01 c0       	rjmp	.+2      	; 0x13a4 <xTaskIncrementTick+0xa0>
    13a2:	b1 2c       	mov	r11, r1
    13a4:	e0 91 82 1c 	lds	r30, 0x1C82	; 0x801c82 <pxDelayedTaskList>
    13a8:	f0 91 83 1c 	lds	r31, 0x1C83	; 0x801c83 <pxDelayedTaskList+0x1>
    13ac:	80 81       	ld	r24, Z
    13ae:	81 11       	cpse	r24, r1
    13b0:	0c c0       	rjmp	.+24     	; 0x13ca <xTaskIncrementTick+0xc6>
    13b2:	8f ef       	ldi	r24, 0xFF	; 255
    13b4:	9f ef       	ldi	r25, 0xFF	; 255
    13b6:	dc 01       	movw	r26, r24
    13b8:	80 93 4f 1c 	sts	0x1C4F, r24	; 0x801c4f <xNextTaskUnblockTime>
    13bc:	90 93 50 1c 	sts	0x1C50, r25	; 0x801c50 <xNextTaskUnblockTime+0x1>
    13c0:	a0 93 51 1c 	sts	0x1C51, r26	; 0x801c51 <xNextTaskUnblockTime+0x2>
    13c4:	b0 93 52 1c 	sts	0x1C52, r27	; 0x801c52 <xNextTaskUnblockTime+0x3>
    13c8:	43 c0       	rjmp	.+134    	; 0x1450 <xTaskIncrementTick+0x14c>
    13ca:	e0 91 82 1c 	lds	r30, 0x1C82	; 0x801c82 <pxDelayedTaskList>
    13ce:	f0 91 83 1c 	lds	r31, 0x1C83	; 0x801c83 <pxDelayedTaskList+0x1>
    13d2:	07 80       	ldd	r0, Z+7	; 0x07
    13d4:	f0 85       	ldd	r31, Z+8	; 0x08
    13d6:	e0 2d       	mov	r30, r0
    13d8:	c0 85       	ldd	r28, Z+8	; 0x08
    13da:	d1 85       	ldd	r29, Z+9	; 0x09
    13dc:	8a 81       	ldd	r24, Y+2	; 0x02
    13de:	9b 81       	ldd	r25, Y+3	; 0x03
    13e0:	ac 81       	ldd	r26, Y+4	; 0x04
    13e2:	bd 81       	ldd	r27, Y+5	; 0x05
    13e4:	c8 16       	cp	r12, r24
    13e6:	d9 06       	cpc	r13, r25
    13e8:	ea 06       	cpc	r14, r26
    13ea:	fb 06       	cpc	r15, r27
    13ec:	48 f4       	brcc	.+18     	; 0x1400 <xTaskIncrementTick+0xfc>
    13ee:	80 93 4f 1c 	sts	0x1C4F, r24	; 0x801c4f <xNextTaskUnblockTime>
    13f2:	90 93 50 1c 	sts	0x1C50, r25	; 0x801c50 <xNextTaskUnblockTime+0x1>
    13f6:	a0 93 51 1c 	sts	0x1C51, r26	; 0x801c51 <xNextTaskUnblockTime+0x2>
    13fa:	b0 93 52 1c 	sts	0x1C52, r27	; 0x801c52 <xNextTaskUnblockTime+0x3>
    13fe:	28 c0       	rjmp	.+80     	; 0x1450 <xTaskIncrementTick+0x14c>
    1400:	8e 01       	movw	r16, r28
    1402:	0e 5f       	subi	r16, 0xFE	; 254
    1404:	1f 4f       	sbci	r17, 0xFF	; 255
    1406:	c8 01       	movw	r24, r16
    1408:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    140c:	88 8d       	ldd	r24, Y+24	; 0x18
    140e:	99 8d       	ldd	r25, Y+25	; 0x19
    1410:	89 2b       	or	r24, r25
    1412:	21 f0       	breq	.+8      	; 0x141c <xTaskIncrementTick+0x118>
    1414:	ce 01       	movw	r24, r28
    1416:	0e 96       	adiw	r24, 0x0e	; 14
    1418:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    141c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    141e:	90 91 58 1c 	lds	r25, 0x1C58	; 0x801c58 <uxTopReadyPriority>
    1422:	98 17       	cp	r25, r24
    1424:	10 f4       	brcc	.+4      	; 0x142a <xTaskIncrementTick+0x126>
    1426:	80 93 58 1c 	sts	0x1C58, r24	; 0x801c58 <uxTopReadyPriority>
    142a:	2b e0       	ldi	r18, 0x0B	; 11
    142c:	82 9f       	mul	r24, r18
    142e:	c0 01       	movw	r24, r0
    1430:	11 24       	eor	r1, r1
    1432:	b8 01       	movw	r22, r16
    1434:	86 56       	subi	r24, 0x66	; 102
    1436:	93 4e       	sbci	r25, 0xE3	; 227
    1438:	0e 94 f5 00 	call	0x1ea	; 0x1ea <vListInsertEnd>
    143c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    143e:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    1442:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1446:	82 8d       	ldd	r24, Z+26	; 0x1a
    1448:	98 17       	cp	r25, r24
    144a:	08 f0       	brcs	.+2      	; 0x144e <xTaskIncrementTick+0x14a>
    144c:	a7 cf       	rjmp	.-178    	; 0x139c <xTaskIncrementTick+0x98>
    144e:	aa cf       	rjmp	.-172    	; 0x13a4 <xTaskIncrementTick+0xa0>
    1450:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    1454:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1458:	e2 8d       	ldd	r30, Z+26	; 0x1a
    145a:	8b e0       	ldi	r24, 0x0B	; 11
    145c:	e8 9f       	mul	r30, r24
    145e:	f0 01       	movw	r30, r0
    1460:	11 24       	eor	r1, r1
    1462:	e6 56       	subi	r30, 0x66	; 102
    1464:	f3 4e       	sbci	r31, 0xE3	; 227
    1466:	80 81       	ld	r24, Z
    1468:	82 30       	cpi	r24, 0x02	; 2
    146a:	40 f4       	brcc	.+16     	; 0x147c <xTaskIncrementTick+0x178>
    146c:	09 c0       	rjmp	.+18     	; 0x1480 <xTaskIncrementTick+0x17c>
    146e:	80 91 56 1c 	lds	r24, 0x1C56	; 0x801c56 <uxPendedTicks>
    1472:	8f 5f       	subi	r24, 0xFF	; 255
    1474:	80 93 56 1c 	sts	0x1C56, r24	; 0x801c56 <uxPendedTicks>
    1478:	b1 2c       	mov	r11, r1
    147a:	02 c0       	rjmp	.+4      	; 0x1480 <xTaskIncrementTick+0x17c>
    147c:	bb 24       	eor	r11, r11
    147e:	b3 94       	inc	r11
    1480:	80 91 55 1c 	lds	r24, 0x1C55	; 0x801c55 <xYieldPending>
    1484:	88 23       	and	r24, r24
    1486:	11 f0       	breq	.+4      	; 0x148c <xTaskIncrementTick+0x188>
    1488:	bb 24       	eor	r11, r11
    148a:	b3 94       	inc	r11
    148c:	8b 2d       	mov	r24, r11
    148e:	df 91       	pop	r29
    1490:	cf 91       	pop	r28
    1492:	1f 91       	pop	r17
    1494:	0f 91       	pop	r16
    1496:	ff 90       	pop	r15
    1498:	ef 90       	pop	r14
    149a:	df 90       	pop	r13
    149c:	cf 90       	pop	r12
    149e:	bf 90       	pop	r11
    14a0:	08 95       	ret

000014a2 <xTaskResumeAll>:
    14a2:	0f 93       	push	r16
    14a4:	1f 93       	push	r17
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	0f b6       	in	r0, 0x3f	; 63
    14ac:	f8 94       	cli
    14ae:	0f 92       	push	r0
    14b0:	80 91 4c 1c 	lds	r24, 0x1C4C	; 0x801c4c <uxSchedulerSuspended>
    14b4:	81 50       	subi	r24, 0x01	; 1
    14b6:	80 93 4c 1c 	sts	0x1C4C, r24	; 0x801c4c <uxSchedulerSuspended>
    14ba:	80 91 4c 1c 	lds	r24, 0x1C4C	; 0x801c4c <uxSchedulerSuspended>
    14be:	81 11       	cpse	r24, r1
    14c0:	4f c0       	rjmp	.+158    	; 0x1560 <xTaskResumeAll+0xbe>
    14c2:	80 91 5d 1c 	lds	r24, 0x1C5D	; 0x801c5d <uxCurrentNumberOfTasks>
    14c6:	81 11       	cpse	r24, r1
    14c8:	2d c0       	rjmp	.+90     	; 0x1524 <xTaskResumeAll+0x82>
    14ca:	4d c0       	rjmp	.+154    	; 0x1566 <xTaskResumeAll+0xc4>
    14cc:	e0 91 7c 1c 	lds	r30, 0x1C7C	; 0x801c7c <xPendingReadyList+0x7>
    14d0:	f0 91 7d 1c 	lds	r31, 0x1C7D	; 0x801c7d <xPendingReadyList+0x8>
    14d4:	c0 85       	ldd	r28, Z+8	; 0x08
    14d6:	d1 85       	ldd	r29, Z+9	; 0x09
    14d8:	ce 01       	movw	r24, r28
    14da:	0e 96       	adiw	r24, 0x0e	; 14
    14dc:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    14e0:	8e 01       	movw	r16, r28
    14e2:	0e 5f       	subi	r16, 0xFE	; 254
    14e4:	1f 4f       	sbci	r17, 0xFF	; 255
    14e6:	c8 01       	movw	r24, r16
    14e8:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    14ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14ee:	90 91 58 1c 	lds	r25, 0x1C58	; 0x801c58 <uxTopReadyPriority>
    14f2:	98 17       	cp	r25, r24
    14f4:	10 f4       	brcc	.+4      	; 0x14fa <xTaskResumeAll+0x58>
    14f6:	80 93 58 1c 	sts	0x1C58, r24	; 0x801c58 <uxTopReadyPriority>
    14fa:	2b e0       	ldi	r18, 0x0B	; 11
    14fc:	82 9f       	mul	r24, r18
    14fe:	c0 01       	movw	r24, r0
    1500:	11 24       	eor	r1, r1
    1502:	b8 01       	movw	r22, r16
    1504:	86 56       	subi	r24, 0x66	; 102
    1506:	93 4e       	sbci	r25, 0xE3	; 227
    1508:	0e 94 f5 00 	call	0x1ea	; 0x1ea <vListInsertEnd>
    150c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    150e:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    1512:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1516:	82 8d       	ldd	r24, Z+26	; 0x1a
    1518:	98 17       	cp	r25, r24
    151a:	30 f0       	brcs	.+12     	; 0x1528 <xTaskResumeAll+0x86>
    151c:	81 e0       	ldi	r24, 0x01	; 1
    151e:	80 93 55 1c 	sts	0x1C55, r24	; 0x801c55 <xYieldPending>
    1522:	02 c0       	rjmp	.+4      	; 0x1528 <xTaskResumeAll+0x86>
    1524:	c0 e0       	ldi	r28, 0x00	; 0
    1526:	d0 e0       	ldi	r29, 0x00	; 0
    1528:	80 91 75 1c 	lds	r24, 0x1C75	; 0x801c75 <xPendingReadyList>
    152c:	81 11       	cpse	r24, r1
    152e:	ce cf       	rjmp	.-100    	; 0x14cc <xTaskResumeAll+0x2a>
    1530:	cd 2b       	or	r28, r29
    1532:	09 f0       	breq	.+2      	; 0x1536 <xTaskResumeAll+0x94>
    1534:	74 dc       	rcall	.-1816   	; 0xe1e <prvResetNextTaskUnblockTime>
    1536:	c0 91 56 1c 	lds	r28, 0x1C56	; 0x801c56 <uxPendedTicks>
    153a:	cc 23       	and	r28, r28
    153c:	51 f0       	breq	.+20     	; 0x1552 <xTaskResumeAll+0xb0>
    153e:	e2 de       	rcall	.-572    	; 0x1304 <xTaskIncrementTick>
    1540:	88 23       	and	r24, r24
    1542:	19 f0       	breq	.+6      	; 0x154a <xTaskResumeAll+0xa8>
    1544:	81 e0       	ldi	r24, 0x01	; 1
    1546:	80 93 55 1c 	sts	0x1C55, r24	; 0x801c55 <xYieldPending>
    154a:	c1 50       	subi	r28, 0x01	; 1
    154c:	c1 f7       	brne	.-16     	; 0x153e <xTaskResumeAll+0x9c>
    154e:	10 92 56 1c 	sts	0x1C56, r1	; 0x801c56 <uxPendedTicks>
    1552:	80 91 55 1c 	lds	r24, 0x1C55	; 0x801c55 <xYieldPending>
    1556:	88 23       	and	r24, r24
    1558:	29 f0       	breq	.+10     	; 0x1564 <xTaskResumeAll+0xc2>
    155a:	c4 d8       	rcall	.-3704   	; 0x6e4 <vPortYield>
    155c:	81 e0       	ldi	r24, 0x01	; 1
    155e:	03 c0       	rjmp	.+6      	; 0x1566 <xTaskResumeAll+0xc4>
    1560:	80 e0       	ldi	r24, 0x00	; 0
    1562:	01 c0       	rjmp	.+2      	; 0x1566 <xTaskResumeAll+0xc4>
    1564:	80 e0       	ldi	r24, 0x00	; 0
    1566:	0f 90       	pop	r0
    1568:	0f be       	out	0x3f, r0	; 63
    156a:	df 91       	pop	r29
    156c:	cf 91       	pop	r28
    156e:	1f 91       	pop	r17
    1570:	0f 91       	pop	r16
    1572:	08 95       	ret

00001574 <vTaskDelay>:
    1574:	cf 92       	push	r12
    1576:	df 92       	push	r13
    1578:	ef 92       	push	r14
    157a:	ff 92       	push	r15
    157c:	6b 01       	movw	r12, r22
    157e:	7c 01       	movw	r14, r24
    1580:	67 2b       	or	r22, r23
    1582:	68 2b       	or	r22, r24
    1584:	69 2b       	or	r22, r25
    1586:	39 f0       	breq	.+14     	; 0x1596 <vTaskDelay+0x22>
    1588:	a9 de       	rcall	.-686    	; 0x12dc <vTaskSuspendAll>
    158a:	40 e0       	ldi	r20, 0x00	; 0
    158c:	c7 01       	movw	r24, r14
    158e:	b6 01       	movw	r22, r12
    1590:	66 dd       	rcall	.-1332   	; 0x105e <prvAddCurrentTaskToDelayedList>
    1592:	87 df       	rcall	.-242    	; 0x14a2 <xTaskResumeAll>
    1594:	01 c0       	rjmp	.+2      	; 0x1598 <vTaskDelay+0x24>
    1596:	80 e0       	ldi	r24, 0x00	; 0
    1598:	81 11       	cpse	r24, r1
    159a:	01 c0       	rjmp	.+2      	; 0x159e <vTaskDelay+0x2a>
    159c:	a3 d8       	rcall	.-3770   	; 0x6e4 <vPortYield>
    159e:	ff 90       	pop	r15
    15a0:	ef 90       	pop	r14
    15a2:	df 90       	pop	r13
    15a4:	cf 90       	pop	r12
    15a6:	08 95       	ret

000015a8 <prvCheckTasksWaitingTermination>:
    15a8:	cf 93       	push	r28
    15aa:	df 93       	push	r29
    15ac:	21 c0       	rjmp	.+66     	; 0x15f0 <prvCheckTasksWaitingTermination+0x48>
    15ae:	96 de       	rcall	.-724    	; 0x12dc <vTaskSuspendAll>
    15b0:	c0 91 6a 1c 	lds	r28, 0x1C6A	; 0x801c6a <xTasksWaitingTermination>
    15b4:	76 df       	rcall	.-276    	; 0x14a2 <xTaskResumeAll>
    15b6:	cc 23       	and	r28, r28
    15b8:	d9 f0       	breq	.+54     	; 0x15f0 <prvCheckTasksWaitingTermination+0x48>
    15ba:	0f b6       	in	r0, 0x3f	; 63
    15bc:	f8 94       	cli
    15be:	0f 92       	push	r0
    15c0:	e0 91 71 1c 	lds	r30, 0x1C71	; 0x801c71 <xTasksWaitingTermination+0x7>
    15c4:	f0 91 72 1c 	lds	r31, 0x1C72	; 0x801c72 <xTasksWaitingTermination+0x8>
    15c8:	c0 85       	ldd	r28, Z+8	; 0x08
    15ca:	d1 85       	ldd	r29, Z+9	; 0x09
    15cc:	ce 01       	movw	r24, r28
    15ce:	02 96       	adiw	r24, 0x02	; 2
    15d0:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    15d4:	80 91 5d 1c 	lds	r24, 0x1C5D	; 0x801c5d <uxCurrentNumberOfTasks>
    15d8:	81 50       	subi	r24, 0x01	; 1
    15da:	80 93 5d 1c 	sts	0x1C5D, r24	; 0x801c5d <uxCurrentNumberOfTasks>
    15de:	80 91 69 1c 	lds	r24, 0x1C69	; 0x801c69 <uxDeletedTasksWaitingCleanUp>
    15e2:	81 50       	subi	r24, 0x01	; 1
    15e4:	80 93 69 1c 	sts	0x1C69, r24	; 0x801c69 <uxDeletedTasksWaitingCleanUp>
    15e8:	0f 90       	pop	r0
    15ea:	0f be       	out	0x3f, r0	; 63
    15ec:	ce 01       	movw	r24, r28
    15ee:	41 dc       	rcall	.-1918   	; 0xe72 <prvDeleteTCB>
    15f0:	80 91 69 1c 	lds	r24, 0x1C69	; 0x801c69 <uxDeletedTasksWaitingCleanUp>
    15f4:	81 11       	cpse	r24, r1
    15f6:	db cf       	rjmp	.-74     	; 0x15ae <prvCheckTasksWaitingTermination+0x6>
    15f8:	df 91       	pop	r29
    15fa:	cf 91       	pop	r28
    15fc:	08 95       	ret

000015fe <prvIdleTask>:
    15fe:	d4 df       	rcall	.-88     	; 0x15a8 <prvCheckTasksWaitingTermination>
    1600:	80 91 9a 1c 	lds	r24, 0x1C9A	; 0x801c9a <pxReadyTasksLists>
    1604:	82 30       	cpi	r24, 0x02	; 2
    1606:	d8 f3       	brcs	.-10     	; 0x15fe <prvIdleTask>
    1608:	6d d8       	rcall	.-3878   	; 0x6e4 <vPortYield>
    160a:	f9 cf       	rjmp	.-14     	; 0x15fe <prvIdleTask>

0000160c <vTaskSwitchContext>:
    160c:	80 91 4c 1c 	lds	r24, 0x1C4C	; 0x801c4c <uxSchedulerSuspended>
    1610:	88 23       	and	r24, r24
    1612:	21 f0       	breq	.+8      	; 0x161c <vTaskSwitchContext+0x10>
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	80 93 55 1c 	sts	0x1C55, r24	; 0x801c55 <xYieldPending>
    161a:	08 95       	ret
    161c:	10 92 55 1c 	sts	0x1C55, r1	; 0x801c55 <xYieldPending>
    1620:	80 91 58 1c 	lds	r24, 0x1C58	; 0x801c58 <uxTopReadyPriority>
    1624:	01 c0       	rjmp	.+2      	; 0x1628 <vTaskSwitchContext+0x1c>
    1626:	81 50       	subi	r24, 0x01	; 1
    1628:	28 2f       	mov	r18, r24
    162a:	30 e0       	ldi	r19, 0x00	; 0
    162c:	9b e0       	ldi	r25, 0x0B	; 11
    162e:	92 9f       	mul	r25, r18
    1630:	f0 01       	movw	r30, r0
    1632:	93 9f       	mul	r25, r19
    1634:	f0 0d       	add	r31, r0
    1636:	11 24       	eor	r1, r1
    1638:	e6 56       	subi	r30, 0x66	; 102
    163a:	f3 4e       	sbci	r31, 0xE3	; 227
    163c:	90 81       	ld	r25, Z
    163e:	99 23       	and	r25, r25
    1640:	91 f3       	breq	.-28     	; 0x1626 <vTaskSwitchContext+0x1a>
    1642:	9b e0       	ldi	r25, 0x0B	; 11
    1644:	92 9f       	mul	r25, r18
    1646:	a0 01       	movw	r20, r0
    1648:	93 9f       	mul	r25, r19
    164a:	50 0d       	add	r21, r0
    164c:	11 24       	eor	r1, r1
    164e:	df 01       	movw	r26, r30
    1650:	01 80       	ldd	r0, Z+1	; 0x01
    1652:	f2 81       	ldd	r31, Z+2	; 0x02
    1654:	e0 2d       	mov	r30, r0
    1656:	04 80       	ldd	r0, Z+4	; 0x04
    1658:	f5 81       	ldd	r31, Z+5	; 0x05
    165a:	e0 2d       	mov	r30, r0
    165c:	12 96       	adiw	r26, 0x02	; 2
    165e:	fc 93       	st	X, r31
    1660:	ee 93       	st	-X, r30
    1662:	11 97       	sbiw	r26, 0x01	; 1
    1664:	43 56       	subi	r20, 0x63	; 99
    1666:	53 4e       	sbci	r21, 0xE3	; 227
    1668:	e4 17       	cp	r30, r20
    166a:	f5 07       	cpc	r31, r21
    166c:	29 f4       	brne	.+10     	; 0x1678 <vTaskSwitchContext+0x6c>
    166e:	44 81       	ldd	r20, Z+4	; 0x04
    1670:	55 81       	ldd	r21, Z+5	; 0x05
    1672:	fd 01       	movw	r30, r26
    1674:	52 83       	std	Z+2, r21	; 0x02
    1676:	41 83       	std	Z+1, r20	; 0x01
    1678:	9b e0       	ldi	r25, 0x0B	; 11
    167a:	92 9f       	mul	r25, r18
    167c:	f0 01       	movw	r30, r0
    167e:	93 9f       	mul	r25, r19
    1680:	f0 0d       	add	r31, r0
    1682:	11 24       	eor	r1, r1
    1684:	e6 56       	subi	r30, 0x66	; 102
    1686:	f3 4e       	sbci	r31, 0xE3	; 227
    1688:	01 80       	ldd	r0, Z+1	; 0x01
    168a:	f2 81       	ldd	r31, Z+2	; 0x02
    168c:	e0 2d       	mov	r30, r0
    168e:	20 85       	ldd	r18, Z+8	; 0x08
    1690:	31 85       	ldd	r19, Z+9	; 0x09
    1692:	30 93 d2 1c 	sts	0x1CD2, r19	; 0x801cd2 <pxCurrentTCB+0x1>
    1696:	20 93 d1 1c 	sts	0x1CD1, r18	; 0x801cd1 <pxCurrentTCB>
    169a:	80 93 58 1c 	sts	0x1C58, r24	; 0x801c58 <uxTopReadyPriority>
    169e:	08 95       	ret

000016a0 <vTaskPlaceOnEventList>:
    16a0:	cf 92       	push	r12
    16a2:	df 92       	push	r13
    16a4:	ef 92       	push	r14
    16a6:	ff 92       	push	r15
    16a8:	6a 01       	movw	r12, r20
    16aa:	7b 01       	movw	r14, r22
    16ac:	60 91 d1 1c 	lds	r22, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    16b0:	70 91 d2 1c 	lds	r23, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    16b4:	62 5f       	subi	r22, 0xF2	; 242
    16b6:	7f 4f       	sbci	r23, 0xFF	; 255
    16b8:	0e 94 16 01 	call	0x22c	; 0x22c <vListInsert>
    16bc:	41 e0       	ldi	r20, 0x01	; 1
    16be:	c7 01       	movw	r24, r14
    16c0:	b6 01       	movw	r22, r12
    16c2:	cd dc       	rcall	.-1638   	; 0x105e <prvAddCurrentTaskToDelayedList>
    16c4:	ff 90       	pop	r15
    16c6:	ef 90       	pop	r14
    16c8:	df 90       	pop	r13
    16ca:	cf 90       	pop	r12
    16cc:	08 95       	ret

000016ce <xTaskRemoveFromEventList>:
    16ce:	0f 93       	push	r16
    16d0:	1f 93       	push	r17
    16d2:	cf 93       	push	r28
    16d4:	df 93       	push	r29
    16d6:	dc 01       	movw	r26, r24
    16d8:	17 96       	adiw	r26, 0x07	; 7
    16da:	ed 91       	ld	r30, X+
    16dc:	fc 91       	ld	r31, X
    16de:	18 97       	sbiw	r26, 0x08	; 8
    16e0:	c0 85       	ldd	r28, Z+8	; 0x08
    16e2:	d1 85       	ldd	r29, Z+9	; 0x09
    16e4:	8e 01       	movw	r16, r28
    16e6:	02 5f       	subi	r16, 0xF2	; 242
    16e8:	1f 4f       	sbci	r17, 0xFF	; 255
    16ea:	c8 01       	movw	r24, r16
    16ec:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    16f0:	80 91 4c 1c 	lds	r24, 0x1C4C	; 0x801c4c <uxSchedulerSuspended>
    16f4:	81 11       	cpse	r24, r1
    16f6:	16 c0       	rjmp	.+44     	; 0x1724 <xTaskRemoveFromEventList+0x56>
    16f8:	0c 50       	subi	r16, 0x0C	; 12
    16fa:	11 09       	sbc	r17, r1
    16fc:	c8 01       	movw	r24, r16
    16fe:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    1702:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1704:	90 91 58 1c 	lds	r25, 0x1C58	; 0x801c58 <uxTopReadyPriority>
    1708:	98 17       	cp	r25, r24
    170a:	10 f4       	brcc	.+4      	; 0x1710 <xTaskRemoveFromEventList+0x42>
    170c:	80 93 58 1c 	sts	0x1C58, r24	; 0x801c58 <uxTopReadyPriority>
    1710:	bb e0       	ldi	r27, 0x0B	; 11
    1712:	8b 9f       	mul	r24, r27
    1714:	c0 01       	movw	r24, r0
    1716:	11 24       	eor	r1, r1
    1718:	b8 01       	movw	r22, r16
    171a:	86 56       	subi	r24, 0x66	; 102
    171c:	93 4e       	sbci	r25, 0xE3	; 227
    171e:	0e 94 f5 00 	call	0x1ea	; 0x1ea <vListInsertEnd>
    1722:	05 c0       	rjmp	.+10     	; 0x172e <xTaskRemoveFromEventList+0x60>
    1724:	b8 01       	movw	r22, r16
    1726:	85 e7       	ldi	r24, 0x75	; 117
    1728:	9c e1       	ldi	r25, 0x1C	; 28
    172a:	0e 94 f5 00 	call	0x1ea	; 0x1ea <vListInsertEnd>
    172e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1730:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    1734:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1738:	82 8d       	ldd	r24, Z+26	; 0x1a
    173a:	89 17       	cp	r24, r25
    173c:	20 f4       	brcc	.+8      	; 0x1746 <xTaskRemoveFromEventList+0x78>
    173e:	81 e0       	ldi	r24, 0x01	; 1
    1740:	80 93 55 1c 	sts	0x1C55, r24	; 0x801c55 <xYieldPending>
    1744:	01 c0       	rjmp	.+2      	; 0x1748 <xTaskRemoveFromEventList+0x7a>
    1746:	80 e0       	ldi	r24, 0x00	; 0
    1748:	df 91       	pop	r29
    174a:	cf 91       	pop	r28
    174c:	1f 91       	pop	r17
    174e:	0f 91       	pop	r16
    1750:	08 95       	ret

00001752 <vTaskSetTimeOutState>:
    1752:	20 91 54 1c 	lds	r18, 0x1C54	; 0x801c54 <xNumOfOverflows>
    1756:	fc 01       	movw	r30, r24
    1758:	20 83       	st	Z, r18
    175a:	40 91 59 1c 	lds	r20, 0x1C59	; 0x801c59 <xTickCount>
    175e:	50 91 5a 1c 	lds	r21, 0x1C5A	; 0x801c5a <xTickCount+0x1>
    1762:	60 91 5b 1c 	lds	r22, 0x1C5B	; 0x801c5b <xTickCount+0x2>
    1766:	70 91 5c 1c 	lds	r23, 0x1C5C	; 0x801c5c <xTickCount+0x3>
    176a:	41 83       	std	Z+1, r20	; 0x01
    176c:	52 83       	std	Z+2, r21	; 0x02
    176e:	63 83       	std	Z+3, r22	; 0x03
    1770:	74 83       	std	Z+4, r23	; 0x04
    1772:	08 95       	ret

00001774 <xTaskCheckForTimeOut>:
    1774:	8f 92       	push	r8
    1776:	9f 92       	push	r9
    1778:	af 92       	push	r10
    177a:	bf 92       	push	r11
    177c:	cf 92       	push	r12
    177e:	df 92       	push	r13
    1780:	ef 92       	push	r14
    1782:	ff 92       	push	r15
    1784:	0f 93       	push	r16
    1786:	1f 93       	push	r17
    1788:	cf 93       	push	r28
    178a:	df 93       	push	r29
    178c:	fb 01       	movw	r30, r22
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	0f 92       	push	r0
    1794:	00 91 59 1c 	lds	r16, 0x1C59	; 0x801c59 <xTickCount>
    1798:	10 91 5a 1c 	lds	r17, 0x1C5A	; 0x801c5a <xTickCount+0x1>
    179c:	20 91 5b 1c 	lds	r18, 0x1C5B	; 0x801c5b <xTickCount+0x2>
    17a0:	30 91 5c 1c 	lds	r19, 0x1C5C	; 0x801c5c <xTickCount+0x3>
    17a4:	40 81       	ld	r20, Z
    17a6:	51 81       	ldd	r21, Z+1	; 0x01
    17a8:	62 81       	ldd	r22, Z+2	; 0x02
    17aa:	73 81       	ldd	r23, Z+3	; 0x03
    17ac:	4f 3f       	cpi	r20, 0xFF	; 255
    17ae:	af ef       	ldi	r26, 0xFF	; 255
    17b0:	5a 07       	cpc	r21, r26
    17b2:	6a 07       	cpc	r22, r26
    17b4:	7a 07       	cpc	r23, r26
    17b6:	81 f1       	breq	.+96     	; 0x1818 <xTaskCheckForTimeOut+0xa4>
    17b8:	ec 01       	movw	r28, r24
    17ba:	b8 81       	ld	r27, Y
    17bc:	a0 91 54 1c 	lds	r26, 0x1C54	; 0x801c54 <xNumOfOverflows>
    17c0:	ba 17       	cp	r27, r26
    17c2:	49 f0       	breq	.+18     	; 0x17d6 <xTaskCheckForTimeOut+0x62>
    17c4:	c9 80       	ldd	r12, Y+1	; 0x01
    17c6:	da 80       	ldd	r13, Y+2	; 0x02
    17c8:	eb 80       	ldd	r14, Y+3	; 0x03
    17ca:	fc 80       	ldd	r15, Y+4	; 0x04
    17cc:	0c 15       	cp	r16, r12
    17ce:	1d 05       	cpc	r17, r13
    17d0:	2e 05       	cpc	r18, r14
    17d2:	3f 05       	cpc	r19, r15
    17d4:	18 f5       	brcc	.+70     	; 0x181c <xTaskCheckForTimeOut+0xa8>
    17d6:	dc 01       	movw	r26, r24
    17d8:	11 96       	adiw	r26, 0x01	; 1
    17da:	cd 90       	ld	r12, X+
    17dc:	dd 90       	ld	r13, X+
    17de:	ed 90       	ld	r14, X+
    17e0:	fc 90       	ld	r15, X
    17e2:	14 97       	sbiw	r26, 0x04	; 4
    17e4:	48 01       	movw	r8, r16
    17e6:	59 01       	movw	r10, r18
    17e8:	8c 18       	sub	r8, r12
    17ea:	9d 08       	sbc	r9, r13
    17ec:	ae 08       	sbc	r10, r14
    17ee:	bf 08       	sbc	r11, r15
    17f0:	84 16       	cp	r8, r20
    17f2:	95 06       	cpc	r9, r21
    17f4:	a6 06       	cpc	r10, r22
    17f6:	b7 06       	cpc	r11, r23
    17f8:	98 f4       	brcc	.+38     	; 0x1820 <xTaskCheckForTimeOut+0xac>
    17fa:	c0 1a       	sub	r12, r16
    17fc:	d1 0a       	sbc	r13, r17
    17fe:	e2 0a       	sbc	r14, r18
    1800:	f3 0a       	sbc	r15, r19
    1802:	4c 0d       	add	r20, r12
    1804:	5d 1d       	adc	r21, r13
    1806:	6e 1d       	adc	r22, r14
    1808:	7f 1d       	adc	r23, r15
    180a:	40 83       	st	Z, r20
    180c:	51 83       	std	Z+1, r21	; 0x01
    180e:	62 83       	std	Z+2, r22	; 0x02
    1810:	73 83       	std	Z+3, r23	; 0x03
    1812:	9f df       	rcall	.-194    	; 0x1752 <vTaskSetTimeOutState>
    1814:	80 e0       	ldi	r24, 0x00	; 0
    1816:	05 c0       	rjmp	.+10     	; 0x1822 <xTaskCheckForTimeOut+0xae>
    1818:	80 e0       	ldi	r24, 0x00	; 0
    181a:	03 c0       	rjmp	.+6      	; 0x1822 <xTaskCheckForTimeOut+0xae>
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	01 c0       	rjmp	.+2      	; 0x1822 <xTaskCheckForTimeOut+0xae>
    1820:	81 e0       	ldi	r24, 0x01	; 1
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63
    1826:	df 91       	pop	r29
    1828:	cf 91       	pop	r28
    182a:	1f 91       	pop	r17
    182c:	0f 91       	pop	r16
    182e:	ff 90       	pop	r15
    1830:	ef 90       	pop	r14
    1832:	df 90       	pop	r13
    1834:	cf 90       	pop	r12
    1836:	bf 90       	pop	r11
    1838:	af 90       	pop	r10
    183a:	9f 90       	pop	r9
    183c:	8f 90       	pop	r8
    183e:	08 95       	ret

00001840 <vTaskMissedYield>:
    1840:	81 e0       	ldi	r24, 0x01	; 1
    1842:	80 93 55 1c 	sts	0x1C55, r24	; 0x801c55 <xYieldPending>
    1846:	08 95       	ret

00001848 <vTaskPriorityInherit>:
    1848:	0f 93       	push	r16
    184a:	1f 93       	push	r17
    184c:	cf 93       	push	r28
    184e:	df 93       	push	r29
    1850:	fc 01       	movw	r30, r24
    1852:	89 2b       	or	r24, r25
    1854:	09 f4       	brne	.+2      	; 0x1858 <vTaskPriorityInherit+0x10>
    1856:	51 c0       	rjmp	.+162    	; 0x18fa <vTaskPriorityInherit+0xb2>
    1858:	82 8d       	ldd	r24, Z+26	; 0x1a
    185a:	a0 91 d1 1c 	lds	r26, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    185e:	b0 91 d2 1c 	lds	r27, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1862:	5a 96       	adiw	r26, 0x1a	; 26
    1864:	9c 91       	ld	r25, X
    1866:	89 17       	cp	r24, r25
    1868:	08 f0       	brcs	.+2      	; 0x186c <vTaskPriorityInherit+0x24>
    186a:	47 c0       	rjmp	.+142    	; 0x18fa <vTaskPriorityInherit+0xb2>
    186c:	46 85       	ldd	r20, Z+14	; 0x0e
    186e:	57 85       	ldd	r21, Z+15	; 0x0f
    1870:	60 89       	ldd	r22, Z+16	; 0x10
    1872:	71 89       	ldd	r23, Z+17	; 0x11
    1874:	77 23       	and	r23, r23
    1876:	94 f0       	brlt	.+36     	; 0x189c <vTaskPriorityInherit+0x54>
    1878:	a0 91 d1 1c 	lds	r26, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    187c:	b0 91 d2 1c 	lds	r27, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1880:	5a 96       	adiw	r26, 0x1a	; 26
    1882:	9c 91       	ld	r25, X
    1884:	45 e0       	ldi	r20, 0x05	; 5
    1886:	50 e0       	ldi	r21, 0x00	; 0
    1888:	60 e0       	ldi	r22, 0x00	; 0
    188a:	70 e0       	ldi	r23, 0x00	; 0
    188c:	49 1b       	sub	r20, r25
    188e:	51 09       	sbc	r21, r1
    1890:	61 09       	sbc	r22, r1
    1892:	71 09       	sbc	r23, r1
    1894:	46 87       	std	Z+14, r20	; 0x0e
    1896:	57 87       	std	Z+15, r21	; 0x0f
    1898:	60 8b       	std	Z+16, r22	; 0x10
    189a:	71 8b       	std	Z+17, r23	; 0x11
    189c:	24 85       	ldd	r18, Z+12	; 0x0c
    189e:	35 85       	ldd	r19, Z+13	; 0x0d
    18a0:	4b e0       	ldi	r20, 0x0B	; 11
    18a2:	84 9f       	mul	r24, r20
    18a4:	c0 01       	movw	r24, r0
    18a6:	11 24       	eor	r1, r1
    18a8:	86 56       	subi	r24, 0x66	; 102
    18aa:	93 4e       	sbci	r25, 0xE3	; 227
    18ac:	28 17       	cp	r18, r24
    18ae:	39 07       	cpc	r19, r25
    18b0:	e9 f4       	brne	.+58     	; 0x18ec <vTaskPriorityInherit+0xa4>
    18b2:	8f 01       	movw	r16, r30
    18b4:	ef 01       	movw	r28, r30
    18b6:	22 96       	adiw	r28, 0x02	; 2
    18b8:	ce 01       	movw	r24, r28
    18ba:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    18be:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    18c2:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    18c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    18c8:	f8 01       	movw	r30, r16
    18ca:	82 8f       	std	Z+26, r24	; 0x1a
    18cc:	90 91 58 1c 	lds	r25, 0x1C58	; 0x801c58 <uxTopReadyPriority>
    18d0:	98 17       	cp	r25, r24
    18d2:	10 f4       	brcc	.+4      	; 0x18d8 <vTaskPriorityInherit+0x90>
    18d4:	80 93 58 1c 	sts	0x1C58, r24	; 0x801c58 <uxTopReadyPriority>
    18d8:	fb e0       	ldi	r31, 0x0B	; 11
    18da:	8f 9f       	mul	r24, r31
    18dc:	c0 01       	movw	r24, r0
    18de:	11 24       	eor	r1, r1
    18e0:	be 01       	movw	r22, r28
    18e2:	86 56       	subi	r24, 0x66	; 102
    18e4:	93 4e       	sbci	r25, 0xE3	; 227
    18e6:	0e 94 f5 00 	call	0x1ea	; 0x1ea <vListInsertEnd>
    18ea:	07 c0       	rjmp	.+14     	; 0x18fa <vTaskPriorityInherit+0xb2>
    18ec:	a0 91 d1 1c 	lds	r26, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    18f0:	b0 91 d2 1c 	lds	r27, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    18f4:	5a 96       	adiw	r26, 0x1a	; 26
    18f6:	8c 91       	ld	r24, X
    18f8:	82 8f       	std	Z+26, r24	; 0x1a
    18fa:	df 91       	pop	r29
    18fc:	cf 91       	pop	r28
    18fe:	1f 91       	pop	r17
    1900:	0f 91       	pop	r16
    1902:	08 95       	ret

00001904 <xTaskPriorityDisinherit>:
    1904:	0f 93       	push	r16
    1906:	1f 93       	push	r17
    1908:	cf 93       	push	r28
    190a:	df 93       	push	r29
    190c:	fc 01       	movw	r30, r24
    190e:	89 2b       	or	r24, r25
    1910:	79 f1       	breq	.+94     	; 0x1970 <xTaskPriorityDisinherit+0x6c>
    1912:	82 a9       	ldd	r24, Z+50	; 0x32
    1914:	81 50       	subi	r24, 0x01	; 1
    1916:	82 ab       	std	Z+50, r24	; 0x32
    1918:	22 8d       	ldd	r18, Z+26	; 0x1a
    191a:	91 a9       	ldd	r25, Z+49	; 0x31
    191c:	29 17       	cp	r18, r25
    191e:	51 f1       	breq	.+84     	; 0x1974 <xTaskPriorityDisinherit+0x70>
    1920:	81 11       	cpse	r24, r1
    1922:	2a c0       	rjmp	.+84     	; 0x1978 <xTaskPriorityDisinherit+0x74>
    1924:	ef 01       	movw	r28, r30
    1926:	8f 01       	movw	r16, r30
    1928:	0e 5f       	subi	r16, 0xFE	; 254
    192a:	1f 4f       	sbci	r17, 0xFF	; 255
    192c:	c8 01       	movw	r24, r16
    192e:	0e 94 53 01 	call	0x2a6	; 0x2a6 <uxListRemove>
    1932:	89 a9       	ldd	r24, Y+49	; 0x31
    1934:	8a 8f       	std	Y+26, r24	; 0x1a
    1936:	45 e0       	ldi	r20, 0x05	; 5
    1938:	50 e0       	ldi	r21, 0x00	; 0
    193a:	60 e0       	ldi	r22, 0x00	; 0
    193c:	70 e0       	ldi	r23, 0x00	; 0
    193e:	48 1b       	sub	r20, r24
    1940:	51 09       	sbc	r21, r1
    1942:	61 09       	sbc	r22, r1
    1944:	71 09       	sbc	r23, r1
    1946:	4e 87       	std	Y+14, r20	; 0x0e
    1948:	5f 87       	std	Y+15, r21	; 0x0f
    194a:	68 8b       	std	Y+16, r22	; 0x10
    194c:	79 8b       	std	Y+17, r23	; 0x11
    194e:	90 91 58 1c 	lds	r25, 0x1C58	; 0x801c58 <uxTopReadyPriority>
    1952:	98 17       	cp	r25, r24
    1954:	10 f4       	brcc	.+4      	; 0x195a <xTaskPriorityDisinherit+0x56>
    1956:	80 93 58 1c 	sts	0x1C58, r24	; 0x801c58 <uxTopReadyPriority>
    195a:	2b e0       	ldi	r18, 0x0B	; 11
    195c:	82 9f       	mul	r24, r18
    195e:	c0 01       	movw	r24, r0
    1960:	11 24       	eor	r1, r1
    1962:	b8 01       	movw	r22, r16
    1964:	86 56       	subi	r24, 0x66	; 102
    1966:	93 4e       	sbci	r25, 0xE3	; 227
    1968:	0e 94 f5 00 	call	0x1ea	; 0x1ea <vListInsertEnd>
    196c:	81 e0       	ldi	r24, 0x01	; 1
    196e:	05 c0       	rjmp	.+10     	; 0x197a <xTaskPriorityDisinherit+0x76>
    1970:	80 e0       	ldi	r24, 0x00	; 0
    1972:	03 c0       	rjmp	.+6      	; 0x197a <xTaskPriorityDisinherit+0x76>
    1974:	80 e0       	ldi	r24, 0x00	; 0
    1976:	01 c0       	rjmp	.+2      	; 0x197a <xTaskPriorityDisinherit+0x76>
    1978:	80 e0       	ldi	r24, 0x00	; 0
    197a:	df 91       	pop	r29
    197c:	cf 91       	pop	r28
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	08 95       	ret

00001984 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1984:	80 91 d1 1c 	lds	r24, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    1988:	90 91 d2 1c 	lds	r25, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    198c:	89 2b       	or	r24, r25
    198e:	39 f0       	breq	.+14     	; 0x199e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1990:	e0 91 d1 1c 	lds	r30, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    1994:	f0 91 d2 1c 	lds	r31, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
    1998:	82 a9       	ldd	r24, Z+50	; 0x32
    199a:	8f 5f       	subi	r24, 0xFF	; 255
    199c:	82 ab       	std	Z+50, r24	; 0x32
		}

		return pxCurrentTCB;
    199e:	80 91 d1 1c 	lds	r24, 0x1CD1	; 0x801cd1 <pxCurrentTCB>
    19a2:	90 91 d2 1c 	lds	r25, 0x1CD2	; 0x801cd2 <pxCurrentTCB+0x1>
	}
    19a6:	08 95       	ret

000019a8 <component_init_and_tests>:

#define RX_QUEUE_LEN 30
#define EVENTS_QUEUE_LEN 10
#define SIM_PRESSURE_LEN 10

void component_init_and_tests() {
    19a8:	0f 93       	push	r16
    19aa:	1f 93       	push	r17
    19ac:	cf 93       	push	r28
    19ae:	df 93       	push	r29
    19b0:	cd b7       	in	r28, 0x3d	; 61
    19b2:	de b7       	in	r29, 0x3e	; 62
    19b4:	6e 97       	sbiw	r28, 0x1e	; 30
    19b6:	0f b6       	in	r0, 0x3f	; 63
    19b8:	f8 94       	cli
    19ba:	de bf       	out	0x3e, r29	; 62
    19bc:	0f be       	out	0x3f, r0	; 63
    19be:	cd bf       	out	0x3d, r28	; 61
	
	sei();
    19c0:	78 94       	sei
	
	SPI_init();
    19c2:	34 d7       	rcall	.+3688   	; 0x282c <SPI_init>
	i2c_init();
    19c4:	af d6       	rcall	.+3422   	; 0x2724 <i2c_init>
	BMP390_init(); // get required coefficients for BMP390
    19c6:	fb d4       	rcall	.+2550   	; 0x23be <BMP390_init>
    19c8:	3d d5       	rcall	.+2682   	; 0x2444 <BNO055_init>
	BNO055_init();
    19ca:	81 e1       	ldi	r24, 0x11	; 17
    19cc:	92 e0       	ldi	r25, 0x02	; 2
	// W25QXX_init(); // Only use in BOOTLOADER
	
	print("CatSat 75percent\r\n");
    19ce:	0e 94 45 1a 	call	0x348a	; 0x348a <print>
    19d2:	84 e2       	ldi	r24, 0x24	; 36
    19d4:	92 e0       	ldi	r25, 0x02	; 2
	print("----------------\r\n");
    19d6:	0e 94 45 1a 	call	0x348a	; 0x348a <print>
    19da:	87 e3       	ldi	r24, 0x37	; 55
    19dc:	92 e0       	ldi	r25, 0x02	; 2
	print("Initializing and Testing...\r\n");
    19de:	0e 94 45 1a 	call	0x348a	; 0x348a <print>
    19e2:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <W25QXX_test>
	
	// Component Tests
	char output[30];
	// W25Q32
	sprintf(output, "W25Q32: %d\r\n", W25QXX_test());
    19e6:	1f 92       	push	r1
    19e8:	8f 93       	push	r24
    19ea:	85 e5       	ldi	r24, 0x55	; 85
    19ec:	92 e0       	ldi	r25, 0x02	; 2
    19ee:	9f 93       	push	r25
    19f0:	8f 93       	push	r24
    19f2:	8e 01       	movw	r16, r28
    19f4:	0f 5f       	subi	r16, 0xFF	; 255
    19f6:	1f 4f       	sbci	r17, 0xFF	; 255
    19f8:	1f 93       	push	r17
    19fa:	0f 93       	push	r16
    19fc:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <sprintf>
    1a00:	c8 01       	movw	r24, r16
	print(output);
    1a02:	0e 94 45 1a 	call	0x348a	; 0x348a <print>
    1a06:	23 d1       	rcall	.+582    	; 0x1c4e <BMP390_test>
	// BMP390
	sprintf(output, "BMP390: %d\r\n", BMP390_test());
    1a08:	1f 92       	push	r1
    1a0a:	8f 93       	push	r24
    1a0c:	82 e6       	ldi	r24, 0x62	; 98
    1a0e:	92 e0       	ldi	r25, 0x02	; 2
    1a10:	9f 93       	push	r25
    1a12:	8f 93       	push	r24
    1a14:	1f 93       	push	r17
    1a16:	0f 93       	push	r16
    1a18:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <sprintf>
    1a1c:	c8 01       	movw	r24, r16
	print(output);
    1a1e:	0e 94 45 1a 	call	0x348a	; 0x348a <print>
    1a22:	1a d5       	rcall	.+2612   	; 0x2458 <BNO055_test>
	// BNO055
	sprintf(output, "BNO055: %d\r\n", BNO055_test());
    1a24:	1f 92       	push	r1
    1a26:	8f 93       	push	r24
    1a28:	8f e6       	ldi	r24, 0x6F	; 111
    1a2a:	92 e0       	ldi	r25, 0x02	; 2
    1a2c:	9f 93       	push	r25
    1a2e:	8f 93       	push	r24
    1a30:	1f 93       	push	r17
    1a32:	0f 93       	push	r16
    1a34:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <sprintf>
    1a38:	c8 01       	movw	r24, r16
	print(output);
    1a3a:	0e 94 45 1a 	call	0x348a	; 0x348a <print>
    1a3e:	5c d6       	rcall	.+3256   	; 0x26f8 <buzzer_start>
	// servo and buzzer
	//move_servo();
	buzzer_start();
    1a40:	2f ef       	ldi	r18, 0xFF	; 255
    1a42:	89 e6       	ldi	r24, 0x69	; 105
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1a44:	98 e1       	ldi	r25, 0x18	; 24
    1a46:	21 50       	subi	r18, 0x01	; 1
    1a48:	80 40       	sbci	r24, 0x00	; 0
    1a4a:	90 40       	sbci	r25, 0x00	; 0
    1a4c:	e1 f7       	brne	.-8      	; 0x1a46 <component_init_and_tests+0x9e>
    1a4e:	00 c0       	rjmp	.+0      	; 0x1a50 <component_init_and_tests+0xa8>
    1a50:	00 00       	nop
	_delay_ms(500);
	buzzer_stop();
    1a52:	5d d6       	rcall	.+3258   	; 0x270e <buzzer_stop>
    1a54:	cd d6       	rcall	.+3482   	; 0x27f0 <reset_servo>
	reset_servo();
    1a56:	2f ef       	ldi	r18, 0xFF	; 255
    1a58:	89 e6       	ldi	r24, 0x69	; 105
    1a5a:	98 e1       	ldi	r25, 0x18	; 24
    1a5c:	21 50       	subi	r18, 0x01	; 1
    1a5e:	80 40       	sbci	r24, 0x00	; 0
    1a60:	90 40       	sbci	r25, 0x00	; 0
    1a62:	e1 f7       	brne	.-8      	; 0x1a5c <component_init_and_tests+0xb4>
    1a64:	00 c0       	rjmp	.+0      	; 0x1a66 <component_init_and_tests+0xbe>
    1a66:	00 00       	nop
    1a68:	0f b6       	in	r0, 0x3f	; 63
    1a6a:	f8 94       	cli
	_delay_ms(500);
}
    1a6c:	de bf       	out	0x3e, r29	; 62
    1a6e:	0f be       	out	0x3f, r0	; 63
    1a70:	cd bf       	out	0x3d, r28	; 61
    1a72:	6e 96       	adiw	r28, 0x1e	; 30
    1a74:	0f b6       	in	r0, 0x3f	; 63
    1a76:	f8 94       	cli
    1a78:	de bf       	out	0x3e, r29	; 62
    1a7a:	0f be       	out	0x3f, r0	; 63
    1a7c:	cd bf       	out	0x3d, r28	; 61
    1a7e:	df 91       	pop	r29
    1a80:	cf 91       	pop	r28
    1a82:	1f 91       	pop	r17
    1a84:	0f 91       	pop	r16
    1a86:	08 95       	ret

00001a88 <main>:
    1a88:	cf 93       	push	r28
    1a8a:	df 93       	push	r29

int main(void)
{	
    1a8c:	cd b7       	in	r28, 0x3d	; 61
    1a8e:	de b7       	in	r29, 0x3e	; 62
    1a90:	68 97       	sbiw	r28, 0x18	; 24
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	f8 94       	cli
    1a96:	de bf       	out	0x3e, r29	; 62
    1a98:	0f be       	out	0x3f, r0	; 63
    1a9a:	cd bf       	out	0x3d, r28	; 61
	// read app size from the bootloader
	
	UART_init(UBBR);
    1a9c:	87 e6       	ldi	r24, 0x67	; 103
    1a9e:	90 e0       	ldi	r25, 0x00	; 0
    1aa0:	0e 94 23 1a 	call	0x3446	; 0x3446 <UART_init>
	
	uint32_t app_size = eeprom_read_dword((uint32_t*)0x00);
    1aa4:	80 e0       	ldi	r24, 0x00	; 0
    1aa6:	90 e0       	ldi	r25, 0x00	; 0
    1aa8:	0e 94 6d 22 	call	0x44da	; 0x44da <eeprom_read_dword>
    1aac:	69 83       	std	Y+1, r22	; 0x01
    1aae:	7a 83       	std	Y+2, r23	; 0x02
    1ab0:	8b 83       	std	Y+3, r24	; 0x03
    1ab2:	9c 83       	std	Y+4, r25	; 0x04
	
	uint8_t size_buf[20];
	sprintf(size_buf, "size: %lu\r\n", app_size);
    1ab4:	9f 93       	push	r25
    1ab6:	8f 93       	push	r24
    1ab8:	7f 93       	push	r23
    1aba:	6f 93       	push	r22
    1abc:	8c e7       	ldi	r24, 0x7C	; 124
    1abe:	92 e0       	ldi	r25, 0x02	; 2
    1ac0:	9f 93       	push	r25
    1ac2:	8f 93       	push	r24
    1ac4:	8e 01       	movw	r16, r28
    1ac6:	0b 5f       	subi	r16, 0xFB	; 251
    1ac8:	1f 4f       	sbci	r17, 0xFF	; 255
    1aca:	1f 93       	push	r17
    1acc:	0f 93       	push	r16
    1ace:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <sprintf>
	print(size_buf);
    1ad2:	c8 01       	movw	r24, r16
    1ad4:	0e 94 45 1a 	call	0x348a	; 0x348a <print>
	
	component_init_and_tests();
    1ad8:	67 df       	rcall	.-306    	; 0x19a8 <component_init_and_tests>
	
	stateMutex = xSemaphoreCreateMutex();
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	a4 d8       	rcall	.-3768   	; 0xc26 <xQueueCreateMutex>
    1ade:	90 93 ad 1d 	sts	0x1DAD, r25	; 0x801dad <stateMutex+0x1>
    1ae2:	80 93 ac 1d 	sts	0x1DAC, r24	; 0x801dac <stateMutex>
	uart1_rx_queue = xQueueCreate(RX_QUEUE_LEN, sizeof(uint8_t));
    1ae6:	40 e0       	ldi	r20, 0x00	; 0
    1ae8:	61 e0       	ldi	r22, 0x01	; 1
    1aea:	8e e1       	ldi	r24, 0x1E	; 30
    1aec:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xQueueGenericCreate>
    1af0:	90 93 ee 1d 	sts	0x1DEE, r25	; 0x801dee <uart1_rx_queue+0x1>
    1af4:	80 93 ed 1d 	sts	0x1DED, r24	; 0x801ded <uart1_rx_queue>
	events_queue = xQueueCreate(EVENTS_QUEUE_LEN, sizeof(CanSatEvents_t));
    1af8:	40 e0       	ldi	r20, 0x00	; 0
    1afa:	61 e0       	ldi	r22, 0x01	; 1
    1afc:	8a e0       	ldi	r24, 0x0A	; 10
    1afe:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xQueueGenericCreate>
    1b02:	90 93 e6 1d 	sts	0x1DE6, r25	; 0x801de6 <events_queue+0x1>
    1b06:	80 93 e5 1d 	sts	0x1DE5, r24	; 0x801de5 <events_queue>
	simulated_pressure_queue = xQueueCreate(SIM_PRESSURE_LEN, sizeof(float));
    1b0a:	40 e0       	ldi	r20, 0x00	; 0
    1b0c:	64 e0       	ldi	r22, 0x04	; 4
    1b0e:	8a e0       	ldi	r24, 0x0A	; 10
    1b10:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xQueueGenericCreate>
    1b14:	90 93 ec 1d 	sts	0x1DEC, r25	; 0x801dec <simulated_pressure_queue+0x1>
    1b18:	80 93 eb 1d 	sts	0x1DEB, r24	; 0x801deb <simulated_pressure_queue>
	
	extern void send_to_ground (void *pvParameters);
	xTaskCreate(send_to_ground, "Task to send telemetry to ground", 200, NULL, 2, NULL);
    1b1c:	e1 2c       	mov	r14, r1
    1b1e:	f1 2c       	mov	r15, r1
    1b20:	02 e0       	ldi	r16, 0x02	; 2
    1b22:	20 e0       	ldi	r18, 0x00	; 0
    1b24:	30 e0       	ldi	r19, 0x00	; 0
    1b26:	48 ec       	ldi	r20, 0xC8	; 200
    1b28:	50 e0       	ldi	r21, 0x00	; 0
    1b2a:	68 e8       	ldi	r22, 0x88	; 136
    1b2c:	72 e0       	ldi	r23, 0x02	; 2
    1b2e:	8a ea       	ldi	r24, 0xAA	; 170
    1b30:	98 e1       	ldi	r25, 0x18	; 24
    1b32:	08 db       	rcall	.-2544   	; 0x1144 <xTaskCreate>
	
	extern void receive_from_ground (void *pvParameters);
	xTaskCreate(receive_from_ground, "Task to receive commands from ground", 500, NULL, 2, NULL);
    1b34:	20 e0       	ldi	r18, 0x00	; 0
    1b36:	30 e0       	ldi	r19, 0x00	; 0
    1b38:	44 ef       	ldi	r20, 0xF4	; 244
    1b3a:	51 e0       	ldi	r21, 0x01	; 1
    1b3c:	69 ea       	ldi	r22, 0xA9	; 169
    1b3e:	72 e0       	ldi	r23, 0x02	; 2
    1b40:	8d e4       	ldi	r24, 0x4D	; 77
    1b42:	99 e1       	ldi	r25, 0x19	; 25
    1b44:	ff da       	rcall	.-2562   	; 0x1144 <xTaskCreate>
	
	extern void state_manager (void *pvParameters);
	xTaskCreate(state_manager, "Task to handle all events", 100, NULL, 2, NULL);
    1b46:	20 e0       	ldi	r18, 0x00	; 0
    1b48:	30 e0       	ldi	r19, 0x00	; 0
    1b4a:	44 e6       	ldi	r20, 0x64	; 100
    1b4c:	50 e0       	ldi	r21, 0x00	; 0
    1b4e:	6e ec       	ldi	r22, 0xCE	; 206
    1b50:	72 e0       	ldi	r23, 0x02	; 2
    1b52:	88 e6       	ldi	r24, 0x68	; 104
    1b54:	95 e1       	ldi	r25, 0x15	; 21
    1b56:	f6 da       	rcall	.-2580   	; 0x1144 <xTaskCreate>
	
	extern void data_reading (void *pvParameters);
	xTaskCreate(data_reading, "Task to read data from sensors", 400, NULL, 2, NULL);
    1b58:	20 e0       	ldi	r18, 0x00	; 0
    1b5a:	30 e0       	ldi	r19, 0x00	; 0
    1b5c:	40 e9       	ldi	r20, 0x90	; 144
    1b5e:	51 e0       	ldi	r21, 0x01	; 1
    1b60:	68 ee       	ldi	r22, 0xE8	; 232
    1b62:	72 e0       	ldi	r23, 0x02	; 2
    1b64:	8d eb       	ldi	r24, 0xBD	; 189
    1b66:	95 e1       	ldi	r25, 0x15	; 21
    1b68:	ed da       	rcall	.-2598   	; 0x1144 <xTaskCreate>
	
	extern void pgm_verifier(void *pvParameters);
	xTaskCreate(pgm_verifier, "Task to calculate checksum of the app", 100, (void *)&app_size, 2, NULL);
    1b6a:	9e 01       	movw	r18, r28
    1b6c:	2f 5f       	subi	r18, 0xFF	; 255
    1b6e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b70:	44 e6       	ldi	r20, 0x64	; 100
    1b72:	50 e0       	ldi	r21, 0x00	; 0
    1b74:	67 e0       	ldi	r22, 0x07	; 7
    1b76:	73 e0       	ldi	r23, 0x03	; 3
    1b78:	8b e1       	ldi	r24, 0x1B	; 27
    1b7a:	97 e1       	ldi	r25, 0x17	; 23
    1b7c:	e3 da       	rcall	.-2618   	; 0x1144 <xTaskCreate>
	
	extern void bootWatchdog(void *pvParameters);
	xTaskCreate(bootWatchdog, "Task to enter bootloader if no response", 100, NULL, 2, NULL);
    1b7e:	20 e0       	ldi	r18, 0x00	; 0
    1b80:	30 e0       	ldi	r19, 0x00	; 0
    1b82:	44 e6       	ldi	r20, 0x64	; 100
    1b84:	50 e0       	ldi	r21, 0x00	; 0
    1b86:	6d e2       	ldi	r22, 0x2D	; 45
    1b88:	73 e0       	ldi	r23, 0x03	; 3
    1b8a:	8e e6       	ldi	r24, 0x6E	; 110
    1b8c:	97 e1       	ldi	r25, 0x17	; 23
	
	print("Starting...\r\n");
    1b8e:	da da       	rcall	.-2636   	; 0x1144 <xTaskCreate>
    1b90:	85 e5       	ldi	r24, 0x55	; 85
    1b92:	93 e0       	ldi	r25, 0x03	; 3
    1b94:	0e 94 45 1a 	call	0x348a	; 0x348a <print>
	
	// Start Scheduler
	vTaskStartScheduler();
    1b98:	70 db       	rcall	.-2336   	; 0x127a <vTaskStartScheduler>
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	f8 94       	cli
    1b9e:	de bf       	out	0x3e, r29	; 62
    1ba0:	0f be       	out	0x3f, r0	; 63
    1ba2:	cd bf       	out	0x3d, r28	; 61
    1ba4:	ff cf       	rjmp	.-2      	; 0x1ba4 <main+0x11c>

00001ba6 <BMP390_read_series>:
void BMP390_read_id(uint8_t *response) {
	BMP390_read(CHIP_ID, response);
}

void BMP390_read_status(uint8_t *response) {
	BMP390_read(STATUS, response);
    1ba6:	cf 92       	push	r12
    1ba8:	df 92       	push	r13
    1baa:	ef 92       	push	r14
    1bac:	ff 92       	push	r15
    1bae:	0f 93       	push	r16
    1bb0:	1f 93       	push	r17
    1bb2:	cf 93       	push	r28
    1bb4:	df 93       	push	r29
    1bb6:	c8 2f       	mov	r28, r24
    1bb8:	6b 01       	movw	r12, r22
    1bba:	7a 01       	movw	r14, r20
    1bbc:	84 e0       	ldi	r24, 0x04	; 4
    1bbe:	40 d6       	rcall	.+3200   	; 0x2840 <SPI_select>
    1bc0:	8c 2f       	mov	r24, r28
    1bc2:	80 68       	ori	r24, 0x80	; 128
    1bc4:	54 d6       	rcall	.+3240   	; 0x286e <SPI_transaction>
    1bc6:	80 e0       	ldi	r24, 0x00	; 0
    1bc8:	52 d6       	rcall	.+3236   	; 0x286e <SPI_transaction>
    1bca:	c0 e0       	ldi	r28, 0x00	; 0
    1bcc:	d0 e0       	ldi	r29, 0x00	; 0
    1bce:	08 c0       	rjmp	.+16     	; 0x1be0 <BMP390_read_series+0x3a>
    1bd0:	86 01       	movw	r16, r12
    1bd2:	0c 0f       	add	r16, r28
    1bd4:	1d 1f       	adc	r17, r29
    1bd6:	80 e0       	ldi	r24, 0x00	; 0
    1bd8:	4a d6       	rcall	.+3220   	; 0x286e <SPI_transaction>
    1bda:	f8 01       	movw	r30, r16
    1bdc:	80 83       	st	Z, r24
    1bde:	21 96       	adiw	r28, 0x01	; 1
    1be0:	ce 15       	cp	r28, r14
    1be2:	df 05       	cpc	r29, r15
    1be4:	a8 f3       	brcs	.-22     	; 0x1bd0 <BMP390_read_series+0x2a>
    1be6:	84 e0       	ldi	r24, 0x04	; 4
    1be8:	37 d6       	rcall	.+3182   	; 0x2858 <SPI_deselect>
    1bea:	df 91       	pop	r29
    1bec:	cf 91       	pop	r28
    1bee:	1f 91       	pop	r17
    1bf0:	0f 91       	pop	r16
    1bf2:	ff 90       	pop	r15
    1bf4:	ef 90       	pop	r14
    1bf6:	df 90       	pop	r13
    1bf8:	cf 90       	pop	r12
    1bfa:	08 95       	ret

00001bfc <BMP390_read>:
    1bfc:	1f 93       	push	r17
    1bfe:	cf 93       	push	r28
    1c00:	df 93       	push	r29
    1c02:	18 2f       	mov	r17, r24
    1c04:	eb 01       	movw	r28, r22
    1c06:	84 e0       	ldi	r24, 0x04	; 4
    1c08:	1b d6       	rcall	.+3126   	; 0x2840 <SPI_select>
    1c0a:	81 2f       	mov	r24, r17
    1c0c:	80 68       	ori	r24, 0x80	; 128
    1c0e:	2f d6       	rcall	.+3166   	; 0x286e <SPI_transaction>
    1c10:	80 e0       	ldi	r24, 0x00	; 0
    1c12:	2d d6       	rcall	.+3162   	; 0x286e <SPI_transaction>
    1c14:	80 e0       	ldi	r24, 0x00	; 0
    1c16:	2b d6       	rcall	.+3158   	; 0x286e <SPI_transaction>
    1c18:	88 83       	st	Y, r24
    1c1a:	84 e0       	ldi	r24, 0x04	; 4
    1c1c:	1d d6       	rcall	.+3130   	; 0x2858 <SPI_deselect>
    1c1e:	df 91       	pop	r29
    1c20:	cf 91       	pop	r28
    1c22:	1f 91       	pop	r17
    1c24:	08 95       	ret

00001c26 <BMP390_write>:
    1c26:	cf 93       	push	r28
    1c28:	df 93       	push	r29
    1c2a:	d8 2f       	mov	r29, r24
    1c2c:	c6 2f       	mov	r28, r22
    1c2e:	84 e0       	ldi	r24, 0x04	; 4
    1c30:	07 d6       	rcall	.+3086   	; 0x2840 <SPI_select>
    1c32:	8d 2f       	mov	r24, r29
    1c34:	8f 77       	andi	r24, 0x7F	; 127
    1c36:	1b d6       	rcall	.+3126   	; 0x286e <SPI_transaction>
    1c38:	8c 2f       	mov	r24, r28
    1c3a:	19 d6       	rcall	.+3122   	; 0x286e <SPI_transaction>
    1c3c:	84 e0       	ldi	r24, 0x04	; 4
    1c3e:	0c d6       	rcall	.+3096   	; 0x2858 <SPI_deselect>
    1c40:	df 91       	pop	r29
    1c42:	cf 91       	pop	r28
    1c44:	08 95       	ret

00001c46 <BMP390_read_id>:
    1c46:	bc 01       	movw	r22, r24
    1c48:	80 e0       	ldi	r24, 0x00	; 0
    1c4a:	d8 cf       	rjmp	.-80     	; 0x1bfc <BMP390_read>
    1c4c:	08 95       	ret

00001c4e <BMP390_test>:
    1c4e:	cf 93       	push	r28
    1c50:	df 93       	push	r29
    1c52:	1f 92       	push	r1
    1c54:	cd b7       	in	r28, 0x3d	; 61
    1c56:	de b7       	in	r29, 0x3e	; 62
    1c58:	ce 01       	movw	r24, r28
    1c5a:	01 96       	adiw	r24, 0x01	; 1
    1c5c:	f4 df       	rcall	.-24     	; 0x1c46 <BMP390_read_id>
    1c5e:	81 e0       	ldi	r24, 0x01	; 1
    1c60:	99 81       	ldd	r25, Y+1	; 0x01
    1c62:	90 36       	cpi	r25, 0x60	; 96
    1c64:	09 f0       	breq	.+2      	; 0x1c68 <BMP390_test+0x1a>
    1c66:	80 e0       	ldi	r24, 0x00	; 0
    1c68:	0f 90       	pop	r0
    1c6a:	df 91       	pop	r29
    1c6c:	cf 91       	pop	r28
    1c6e:	08 95       	ret

00001c70 <BMP390_read_data>:
}

void BMP390_read_data(uint32_t *pressure, uint32_t *temperature) {
    1c70:	ef 92       	push	r14
    1c72:	ff 92       	push	r15
    1c74:	0f 93       	push	r16
    1c76:	1f 93       	push	r17
    1c78:	cf 93       	push	r28
    1c7a:	df 93       	push	r29
    1c7c:	00 d0       	rcall	.+0      	; 0x1c7e <BMP390_read_data+0xe>
    1c7e:	00 d0       	rcall	.+0      	; 0x1c80 <BMP390_read_data+0x10>
    1c80:	cd b7       	in	r28, 0x3d	; 61
    1c82:	de b7       	in	r29, 0x3e	; 62
    1c84:	7c 01       	movw	r14, r24
    1c86:	8b 01       	movw	r16, r22
	uint8_t data_bytes[6] = {0};
    1c88:	be 01       	movw	r22, r28
    1c8a:	6f 5f       	subi	r22, 0xFF	; 255
    1c8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c8e:	86 e0       	ldi	r24, 0x06	; 6
    1c90:	fb 01       	movw	r30, r22
    1c92:	11 92       	st	Z+, r1
    1c94:	8a 95       	dec	r24
    1c96:	e9 f7       	brne	.-6      	; 0x1c92 <BMP390_read_data+0x22>
	BMP390_read_series(DATA, data_bytes, 6);
    1c98:	46 e0       	ldi	r20, 0x06	; 6
    1c9a:	50 e0       	ldi	r21, 0x00	; 0
    1c9c:	84 e0       	ldi	r24, 0x04	; 4
    1c9e:	83 df       	rcall	.-250    	; 0x1ba6 <BMP390_read_series>
	
	*pressure = CONCAT_3_BYTES(data_bytes[2], data_bytes[1], data_bytes[0]);
    1ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	a0 e0       	ldi	r26, 0x00	; 0
    1ca6:	b0 e0       	ldi	r27, 0x00	; 0
    1ca8:	bc 01       	movw	r22, r24
    1caa:	55 27       	eor	r21, r21
    1cac:	44 27       	eor	r20, r20
    1cae:	9a 81       	ldd	r25, Y+2	; 0x02
    1cb0:	89 2f       	mov	r24, r25
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
    1cb4:	a0 e0       	ldi	r26, 0x00	; 0
    1cb6:	b0 e0       	ldi	r27, 0x00	; 0
    1cb8:	ba 2f       	mov	r27, r26
    1cba:	a9 2f       	mov	r26, r25
    1cbc:	98 2f       	mov	r25, r24
    1cbe:	88 27       	eor	r24, r24
    1cc0:	84 2b       	or	r24, r20
    1cc2:	95 2b       	or	r25, r21
    1cc4:	a6 2b       	or	r26, r22
    1cc6:	b7 2b       	or	r27, r23
    1cc8:	29 81       	ldd	r18, Y+1	; 0x01
    1cca:	82 2b       	or	r24, r18
    1ccc:	f7 01       	movw	r30, r14
    1cce:	80 83       	st	Z, r24
    1cd0:	91 83       	std	Z+1, r25	; 0x01
    1cd2:	a2 83       	std	Z+2, r26	; 0x02
    1cd4:	b3 83       	std	Z+3, r27	; 0x03
	*temperature = CONCAT_3_BYTES(data_bytes[5], data_bytes[4], data_bytes[3]);
    1cd6:	8e 81       	ldd	r24, Y+6	; 0x06
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	a0 e0       	ldi	r26, 0x00	; 0
    1cdc:	b0 e0       	ldi	r27, 0x00	; 0
    1cde:	bc 01       	movw	r22, r24
    1ce0:	55 27       	eor	r21, r21
    1ce2:	44 27       	eor	r20, r20
    1ce4:	9d 81       	ldd	r25, Y+5	; 0x05
    1ce6:	89 2f       	mov	r24, r25
    1ce8:	90 e0       	ldi	r25, 0x00	; 0
    1cea:	a0 e0       	ldi	r26, 0x00	; 0
    1cec:	b0 e0       	ldi	r27, 0x00	; 0
    1cee:	ba 2f       	mov	r27, r26
    1cf0:	a9 2f       	mov	r26, r25
    1cf2:	98 2f       	mov	r25, r24
    1cf4:	88 27       	eor	r24, r24
    1cf6:	84 2b       	or	r24, r20
    1cf8:	95 2b       	or	r25, r21
    1cfa:	a6 2b       	or	r26, r22
    1cfc:	b7 2b       	or	r27, r23
    1cfe:	2c 81       	ldd	r18, Y+4	; 0x04
    1d00:	82 2b       	or	r24, r18
    1d02:	f8 01       	movw	r30, r16
    1d04:	80 83       	st	Z, r24
    1d06:	91 83       	std	Z+1, r25	; 0x01
    1d08:	a2 83       	std	Z+2, r26	; 0x02
    1d0a:	b3 83       	std	Z+3, r27	; 0x03
}
    1d0c:	26 96       	adiw	r28, 0x06	; 6
    1d0e:	0f b6       	in	r0, 0x3f	; 63
    1d10:	f8 94       	cli
    1d12:	de bf       	out	0x3e, r29	; 62
    1d14:	0f be       	out	0x3f, r0	; 63
    1d16:	cd bf       	out	0x3d, r28	; 61
    1d18:	df 91       	pop	r29
    1d1a:	cf 91       	pop	r28
    1d1c:	1f 91       	pop	r17
    1d1e:	0f 91       	pop	r16
    1d20:	ff 90       	pop	r15
    1d22:	ef 90       	pop	r14
    1d24:	08 95       	ret

00001d26 <BMP390_get_temp_data>:
	BMP390_read_data(&raw_readings.pressure, &raw_readings.temperature); // get raw data values
	
	BMP390_get_pres_data(pressure, BMP390_get_temp_data(temperature));
}

void BMP390_get_temp_data(float *temperature) {
    1d26:	8f 92       	push	r8
    1d28:	9f 92       	push	r9
    1d2a:	af 92       	push	r10
    1d2c:	bf 92       	push	r11
    1d2e:	cf 92       	push	r12
    1d30:	df 92       	push	r13
    1d32:	ef 92       	push	r14
    1d34:	ff 92       	push	r15
    1d36:	0f 93       	push	r16
    1d38:	1f 93       	push	r17
    1d3a:	cf 93       	push	r28
    1d3c:	df 93       	push	r29
    1d3e:	8c 01       	movw	r16, r24
	double partial_data1;
	double partial_data2;
	
	// UART0_send_bytes(&raw_data.temperature, 4);
	
	partial_data1 = (double)(raw_readings.temperature - calculated_calibs.par_t1);
    1d40:	60 91 5b 1d 	lds	r22, 0x1D5B	; 0x801d5b <raw_readings+0x4>
    1d44:	70 91 5c 1d 	lds	r23, 0x1D5C	; 0x801d5c <raw_readings+0x5>
    1d48:	80 91 5d 1d 	lds	r24, 0x1D5D	; 0x801d5d <raw_readings+0x6>
    1d4c:	90 91 5e 1d 	lds	r25, 0x1D5E	; 0x801d5e <raw_readings+0x7>
    1d50:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <__floatunsisf>
    1d54:	c4 e7       	ldi	r28, 0x74	; 116
    1d56:	dd e1       	ldi	r29, 0x1D	; 29
    1d58:	28 81       	ld	r18, Y
    1d5a:	39 81       	ldd	r19, Y+1	; 0x01
    1d5c:	4a 81       	ldd	r20, Y+2	; 0x02
    1d5e:	5b 81       	ldd	r21, Y+3	; 0x03
    1d60:	0e 94 0a 1c 	call	0x3814	; 0x3814 <__subsf3>
    1d64:	6b 01       	movw	r12, r22
    1d66:	7c 01       	movw	r14, r24
	partial_data2 = (double)(partial_data1 * calculated_calibs.par_t2);
    1d68:	2c 81       	ldd	r18, Y+4	; 0x04
    1d6a:	3d 81       	ldd	r19, Y+5	; 0x05
    1d6c:	4e 81       	ldd	r20, Y+6	; 0x06
    1d6e:	5f 81       	ldd	r21, Y+7	; 0x07
    1d70:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1d74:	4b 01       	movw	r8, r22
    1d76:	5c 01       	movw	r10, r24
	
	*temperature = partial_data2 + (partial_data1 * partial_data1) * calculated_calibs.par_t3;
    1d78:	a7 01       	movw	r20, r14
    1d7a:	96 01       	movw	r18, r12
    1d7c:	c7 01       	movw	r24, r14
    1d7e:	b6 01       	movw	r22, r12
    1d80:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1d84:	28 85       	ldd	r18, Y+8	; 0x08
    1d86:	39 85       	ldd	r19, Y+9	; 0x09
    1d88:	4a 85       	ldd	r20, Y+10	; 0x0a
    1d8a:	5b 85       	ldd	r21, Y+11	; 0x0b
    1d8c:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1d90:	9b 01       	movw	r18, r22
    1d92:	ac 01       	movw	r20, r24
    1d94:	c5 01       	movw	r24, r10
    1d96:	b4 01       	movw	r22, r8
    1d98:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    1d9c:	f8 01       	movw	r30, r16
    1d9e:	60 83       	st	Z, r22
    1da0:	71 83       	std	Z+1, r23	; 0x01
    1da2:	82 83       	std	Z+2, r24	; 0x02
    1da4:	93 83       	std	Z+3, r25	; 0x03
}
    1da6:	df 91       	pop	r29
    1da8:	cf 91       	pop	r28
    1daa:	1f 91       	pop	r17
    1dac:	0f 91       	pop	r16
    1dae:	ff 90       	pop	r15
    1db0:	ef 90       	pop	r14
    1db2:	df 90       	pop	r13
    1db4:	cf 90       	pop	r12
    1db6:	bf 90       	pop	r11
    1db8:	af 90       	pop	r10
    1dba:	9f 90       	pop	r9
    1dbc:	8f 90       	pop	r8
    1dbe:	08 95       	ret

00001dc0 <BMP390_get_pres_data>:

void BMP390_get_pres_data(float *pressure, float calculated_temperature)
{
    1dc0:	4f 92       	push	r4
    1dc2:	5f 92       	push	r5
    1dc4:	6f 92       	push	r6
    1dc6:	7f 92       	push	r7
    1dc8:	8f 92       	push	r8
    1dca:	9f 92       	push	r9
    1dcc:	af 92       	push	r10
    1dce:	bf 92       	push	r11
    1dd0:	cf 92       	push	r12
    1dd2:	df 92       	push	r13
    1dd4:	ef 92       	push	r14
    1dd6:	ff 92       	push	r15
    1dd8:	0f 93       	push	r16
    1dda:	1f 93       	push	r17
    1ddc:	cf 93       	push	r28
    1dde:	df 93       	push	r29
    1de0:	cd b7       	in	r28, 0x3d	; 61
    1de2:	de b7       	in	r29, 0x3e	; 62
    1de4:	60 97       	sbiw	r28, 0x10	; 16
    1de6:	0f b6       	in	r0, 0x3f	; 63
    1de8:	f8 94       	cli
    1dea:	de bf       	out	0x3e, r29	; 62
    1dec:	0f be       	out	0x3f, r0	; 63
    1dee:	cd bf       	out	0x3d, r28	; 61
    1df0:	8c 01       	movw	r16, r24
    1df2:	49 83       	std	Y+1, r20	; 0x01
    1df4:	5a 83       	std	Y+2, r21	; 0x02
    1df6:	6b 83       	std	Y+3, r22	; 0x03
    1df8:	7c 83       	std	Y+4, r23	; 0x04
	double partial_data3;
	double partial_data4;
	double partial_out1;
	double partial_out2;

	partial_data1 = calculated_calibs.par_p6 * calculated_temperature;
    1dfa:	60 91 94 1d 	lds	r22, 0x1D94	; 0x801d94 <calculated_calibs+0x20>
    1dfe:	70 91 95 1d 	lds	r23, 0x1D95	; 0x801d95 <calculated_calibs+0x21>
    1e02:	80 91 96 1d 	lds	r24, 0x1D96	; 0x801d96 <calculated_calibs+0x22>
    1e06:	90 91 97 1d 	lds	r25, 0x1D97	; 0x801d97 <calculated_calibs+0x23>
    1e0a:	29 81       	ldd	r18, Y+1	; 0x01
    1e0c:	3a 81       	ldd	r19, Y+2	; 0x02
    1e0e:	4b 81       	ldd	r20, Y+3	; 0x03
    1e10:	5c 81       	ldd	r21, Y+4	; 0x04
    1e12:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1e16:	6d 83       	std	Y+5, r22	; 0x05
    1e18:	7e 83       	std	Y+6, r23	; 0x06
    1e1a:	8f 83       	std	Y+7, r24	; 0x07
    1e1c:	98 87       	std	Y+8, r25	; 0x08
	partial_data2 = calculated_calibs.par_p7 * (calculated_temperature * calculated_temperature);
    1e1e:	c0 90 98 1d 	lds	r12, 0x1D98	; 0x801d98 <calculated_calibs+0x24>
    1e22:	d0 90 99 1d 	lds	r13, 0x1D99	; 0x801d99 <calculated_calibs+0x25>
    1e26:	e0 90 9a 1d 	lds	r14, 0x1D9A	; 0x801d9a <calculated_calibs+0x26>
    1e2a:	f0 90 9b 1d 	lds	r15, 0x1D9B	; 0x801d9b <calculated_calibs+0x27>
    1e2e:	29 81       	ldd	r18, Y+1	; 0x01
    1e30:	3a 81       	ldd	r19, Y+2	; 0x02
    1e32:	4b 81       	ldd	r20, Y+3	; 0x03
    1e34:	5c 81       	ldd	r21, Y+4	; 0x04
    1e36:	ca 01       	movw	r24, r20
    1e38:	b9 01       	movw	r22, r18
    1e3a:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1e3e:	2b 01       	movw	r4, r22
    1e40:	3c 01       	movw	r6, r24
    1e42:	9b 01       	movw	r18, r22
    1e44:	ac 01       	movw	r20, r24
    1e46:	c7 01       	movw	r24, r14
    1e48:	b6 01       	movw	r22, r12
    1e4a:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1e4e:	69 87       	std	Y+9, r22	; 0x09
    1e50:	7a 87       	std	Y+10, r23	; 0x0a
    1e52:	8b 87       	std	Y+11, r24	; 0x0b
    1e54:	9c 87       	std	Y+12, r25	; 0x0c
	partial_data3 = calculated_calibs.par_p8 * (calculated_temperature * calculated_temperature * calculated_temperature);
    1e56:	80 90 9c 1d 	lds	r8, 0x1D9C	; 0x801d9c <calculated_calibs+0x28>
    1e5a:	90 90 9d 1d 	lds	r9, 0x1D9D	; 0x801d9d <calculated_calibs+0x29>
    1e5e:	a0 90 9e 1d 	lds	r10, 0x1D9E	; 0x801d9e <calculated_calibs+0x2a>
    1e62:	b0 90 9f 1d 	lds	r11, 0x1D9F	; 0x801d9f <calculated_calibs+0x2b>
    1e66:	a3 01       	movw	r20, r6
    1e68:	92 01       	movw	r18, r4
    1e6a:	69 81       	ldd	r22, Y+1	; 0x01
    1e6c:	7a 81       	ldd	r23, Y+2	; 0x02
    1e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e70:	9c 81       	ldd	r25, Y+4	; 0x04
    1e72:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1e76:	6b 01       	movw	r12, r22
    1e78:	7c 01       	movw	r14, r24
    1e7a:	9b 01       	movw	r18, r22
    1e7c:	ac 01       	movw	r20, r24
    1e7e:	c5 01       	movw	r24, r10
    1e80:	b4 01       	movw	r22, r8
    1e82:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1e86:	4b 01       	movw	r8, r22
    1e88:	5c 01       	movw	r10, r24
	partial_out1 = calculated_calibs.par_p5 + partial_data1 + partial_data2 + partial_data3;
    1e8a:	20 91 90 1d 	lds	r18, 0x1D90	; 0x801d90 <calculated_calibs+0x1c>
    1e8e:	30 91 91 1d 	lds	r19, 0x1D91	; 0x801d91 <calculated_calibs+0x1d>
    1e92:	40 91 92 1d 	lds	r20, 0x1D92	; 0x801d92 <calculated_calibs+0x1e>
    1e96:	50 91 93 1d 	lds	r21, 0x1D93	; 0x801d93 <calculated_calibs+0x1f>
    1e9a:	6d 81       	ldd	r22, Y+5	; 0x05
    1e9c:	7e 81       	ldd	r23, Y+6	; 0x06
    1e9e:	8f 81       	ldd	r24, Y+7	; 0x07
    1ea0:	98 85       	ldd	r25, Y+8	; 0x08
    1ea2:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    1ea6:	9b 01       	movw	r18, r22
    1ea8:	ac 01       	movw	r20, r24
    1eaa:	69 85       	ldd	r22, Y+9	; 0x09
    1eac:	7a 85       	ldd	r23, Y+10	; 0x0a
    1eae:	8b 85       	ldd	r24, Y+11	; 0x0b
    1eb0:	9c 85       	ldd	r25, Y+12	; 0x0c
    1eb2:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    1eb6:	9b 01       	movw	r18, r22
    1eb8:	ac 01       	movw	r20, r24
    1eba:	c5 01       	movw	r24, r10
    1ebc:	b4 01       	movw	r22, r8
    1ebe:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    1ec2:	69 87       	std	Y+9, r22	; 0x09
    1ec4:	7a 87       	std	Y+10, r23	; 0x0a
    1ec6:	8b 87       	std	Y+11, r24	; 0x0b
    1ec8:	9c 87       	std	Y+12, r25	; 0x0c
	
	partial_data1 = calculated_calibs.par_p2 * calculated_temperature;
    1eca:	20 91 84 1d 	lds	r18, 0x1D84	; 0x801d84 <calculated_calibs+0x10>
    1ece:	30 91 85 1d 	lds	r19, 0x1D85	; 0x801d85 <calculated_calibs+0x11>
    1ed2:	40 91 86 1d 	lds	r20, 0x1D86	; 0x801d86 <calculated_calibs+0x12>
    1ed6:	50 91 87 1d 	lds	r21, 0x1D87	; 0x801d87 <calculated_calibs+0x13>
    1eda:	69 81       	ldd	r22, Y+1	; 0x01
    1edc:	7a 81       	ldd	r23, Y+2	; 0x02
    1ede:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee2:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1ee6:	4b 01       	movw	r8, r22
    1ee8:	5c 01       	movw	r10, r24
	partial_data2 = calculated_calibs.par_p3 * (calculated_temperature * calculated_temperature);
    1eea:	20 91 88 1d 	lds	r18, 0x1D88	; 0x801d88 <calculated_calibs+0x14>
    1eee:	30 91 89 1d 	lds	r19, 0x1D89	; 0x801d89 <calculated_calibs+0x15>
    1ef2:	40 91 8a 1d 	lds	r20, 0x1D8A	; 0x801d8a <calculated_calibs+0x16>
    1ef6:	50 91 8b 1d 	lds	r21, 0x1D8B	; 0x801d8b <calculated_calibs+0x17>
    1efa:	c3 01       	movw	r24, r6
    1efc:	b2 01       	movw	r22, r4
    1efe:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1f02:	2b 01       	movw	r4, r22
    1f04:	3c 01       	movw	r6, r24
	partial_data3 = calculated_calibs.par_p4 * (calculated_temperature * calculated_temperature * calculated_temperature);
    1f06:	20 91 8c 1d 	lds	r18, 0x1D8C	; 0x801d8c <calculated_calibs+0x18>
    1f0a:	30 91 8d 1d 	lds	r19, 0x1D8D	; 0x801d8d <calculated_calibs+0x19>
    1f0e:	40 91 8e 1d 	lds	r20, 0x1D8E	; 0x801d8e <calculated_calibs+0x1a>
    1f12:	50 91 8f 1d 	lds	r21, 0x1D8F	; 0x801d8f <calculated_calibs+0x1b>
    1f16:	c7 01       	movw	r24, r14
    1f18:	b6 01       	movw	r22, r12
    1f1a:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1f1e:	6d 87       	std	Y+13, r22	; 0x0d
    1f20:	7e 87       	std	Y+14, r23	; 0x0e
    1f22:	8f 87       	std	Y+15, r24	; 0x0f
    1f24:	98 8b       	std	Y+16, r25	; 0x10
	partial_out2 = raw_readings.pressure *
    1f26:	c0 90 57 1d 	lds	r12, 0x1D57	; 0x801d57 <raw_readings>
    1f2a:	d0 90 58 1d 	lds	r13, 0x1D58	; 0x801d58 <raw_readings+0x1>
    1f2e:	e0 90 59 1d 	lds	r14, 0x1D59	; 0x801d59 <raw_readings+0x2>
    1f32:	f0 90 5a 1d 	lds	r15, 0x1D5A	; 0x801d5a <raw_readings+0x3>
    1f36:	c7 01       	movw	r24, r14
    1f38:	b6 01       	movw	r22, r12
    1f3a:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <__floatunsisf>
    1f3e:	6d 83       	std	Y+5, r22	; 0x05
    1f40:	7e 83       	std	Y+6, r23	; 0x06
    1f42:	8f 83       	std	Y+7, r24	; 0x07
    1f44:	98 87       	std	Y+8, r25	; 0x08
	(calculated_calibs.par_p1 + partial_data1 + partial_data2 + partial_data3);
    1f46:	20 91 80 1d 	lds	r18, 0x1D80	; 0x801d80 <calculated_calibs+0xc>
    1f4a:	30 91 81 1d 	lds	r19, 0x1D81	; 0x801d81 <calculated_calibs+0xd>
    1f4e:	40 91 82 1d 	lds	r20, 0x1D82	; 0x801d82 <calculated_calibs+0xe>
    1f52:	50 91 83 1d 	lds	r21, 0x1D83	; 0x801d83 <calculated_calibs+0xf>
    1f56:	c5 01       	movw	r24, r10
    1f58:	b4 01       	movw	r22, r8
    1f5a:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    1f5e:	9b 01       	movw	r18, r22
    1f60:	ac 01       	movw	r20, r24
    1f62:	c3 01       	movw	r24, r6
    1f64:	b2 01       	movw	r22, r4
    1f66:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    1f6a:	9b 01       	movw	r18, r22
    1f6c:	ac 01       	movw	r20, r24
    1f6e:	6d 85       	ldd	r22, Y+13	; 0x0d
    1f70:	7e 85       	ldd	r23, Y+14	; 0x0e
    1f72:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f74:	98 89       	ldd	r25, Y+16	; 0x10
    1f76:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    1f7a:	9b 01       	movw	r18, r22
    1f7c:	ac 01       	movw	r20, r24
	partial_out1 = calculated_calibs.par_p5 + partial_data1 + partial_data2 + partial_data3;
	
	partial_data1 = calculated_calibs.par_p2 * calculated_temperature;
	partial_data2 = calculated_calibs.par_p3 * (calculated_temperature * calculated_temperature);
	partial_data3 = calculated_calibs.par_p4 * (calculated_temperature * calculated_temperature * calculated_temperature);
	partial_out2 = raw_readings.pressure *
    1f7e:	6d 81       	ldd	r22, Y+5	; 0x05
    1f80:	7e 81       	ldd	r23, Y+6	; 0x06
    1f82:	8f 81       	ldd	r24, Y+7	; 0x07
    1f84:	98 85       	ldd	r25, Y+8	; 0x08
    1f86:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1f8a:	6d 87       	std	Y+13, r22	; 0x0d
    1f8c:	7e 87       	std	Y+14, r23	; 0x0e
    1f8e:	8f 87       	std	Y+15, r24	; 0x0f
    1f90:	98 8b       	std	Y+16, r25	; 0x10
	(calculated_calibs.par_p1 + partial_data1 + partial_data2 + partial_data3);
	
	partial_data1 = (raw_readings.pressure * raw_readings.pressure);
    1f92:	a7 01       	movw	r20, r14
    1f94:	96 01       	movw	r18, r12
    1f96:	c7 01       	movw	r24, r14
    1f98:	b6 01       	movw	r22, r12
    1f9a:	0e 94 59 1f 	call	0x3eb2	; 0x3eb2 <__mulsi3>
    1f9e:	6d 83       	std	Y+5, r22	; 0x05
    1fa0:	7e 83       	std	Y+6, r23	; 0x06
    1fa2:	8f 83       	std	Y+7, r24	; 0x07
    1fa4:	98 87       	std	Y+8, r25	; 0x08
    1fa6:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <__floatunsisf>
    1faa:	4b 01       	movw	r8, r22
    1fac:	5c 01       	movw	r10, r24
	partial_data2 = calculated_calibs.par_p9 + calculated_calibs.par_p10 * calculated_temperature;
    1fae:	40 90 a0 1d 	lds	r4, 0x1DA0	; 0x801da0 <calculated_calibs+0x2c>
    1fb2:	50 90 a1 1d 	lds	r5, 0x1DA1	; 0x801da1 <calculated_calibs+0x2d>
    1fb6:	60 90 a2 1d 	lds	r6, 0x1DA2	; 0x801da2 <calculated_calibs+0x2e>
    1fba:	70 90 a3 1d 	lds	r7, 0x1DA3	; 0x801da3 <calculated_calibs+0x2f>
    1fbe:	20 91 a4 1d 	lds	r18, 0x1DA4	; 0x801da4 <calculated_calibs+0x30>
    1fc2:	30 91 a5 1d 	lds	r19, 0x1DA5	; 0x801da5 <calculated_calibs+0x31>
    1fc6:	40 91 a6 1d 	lds	r20, 0x1DA6	; 0x801da6 <calculated_calibs+0x32>
    1fca:	50 91 a7 1d 	lds	r21, 0x1DA7	; 0x801da7 <calculated_calibs+0x33>
    1fce:	69 81       	ldd	r22, Y+1	; 0x01
    1fd0:	7a 81       	ldd	r23, Y+2	; 0x02
    1fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd6:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1fda:	9b 01       	movw	r18, r22
    1fdc:	ac 01       	movw	r20, r24
    1fde:	c3 01       	movw	r24, r6
    1fe0:	b2 01       	movw	r22, r4
    1fe2:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    1fe6:	9b 01       	movw	r18, r22
    1fe8:	ac 01       	movw	r20, r24
	partial_data3 = partial_data1 * partial_data2;
    1fea:	c5 01       	movw	r24, r10
    1fec:	b4 01       	movw	r22, r8
    1fee:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    1ff2:	4b 01       	movw	r8, r22
    1ff4:	5c 01       	movw	r10, r24
	partial_data4 = partial_data3 + (raw_readings.pressure * raw_readings.pressure * raw_readings.pressure) * calculated_calibs.par_p11;
    1ff6:	a7 01       	movw	r20, r14
    1ff8:	96 01       	movw	r18, r12
    1ffa:	6d 81       	ldd	r22, Y+5	; 0x05
    1ffc:	7e 81       	ldd	r23, Y+6	; 0x06
    1ffe:	8f 81       	ldd	r24, Y+7	; 0x07
    2000:	98 85       	ldd	r25, Y+8	; 0x08
    2002:	0e 94 59 1f 	call	0x3eb2	; 0x3eb2 <__mulsi3>
    2006:	c0 90 a8 1d 	lds	r12, 0x1DA8	; 0x801da8 <calculated_calibs+0x34>
    200a:	d0 90 a9 1d 	lds	r13, 0x1DA9	; 0x801da9 <calculated_calibs+0x35>
    200e:	e0 90 aa 1d 	lds	r14, 0x1DAA	; 0x801daa <calculated_calibs+0x36>
    2012:	f0 90 ab 1d 	lds	r15, 0x1DAB	; 0x801dab <calculated_calibs+0x37>
    2016:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <__floatunsisf>
    201a:	a7 01       	movw	r20, r14
    201c:	96 01       	movw	r18, r12
    201e:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    2022:	9b 01       	movw	r18, r22
    2024:	ac 01       	movw	r20, r24
    2026:	c5 01       	movw	r24, r10
    2028:	b4 01       	movw	r22, r8
    202a:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    202e:	6b 01       	movw	r12, r22
    2030:	7c 01       	movw	r14, r24
	comp_press = partial_out1 + partial_out2 + partial_data4;
    2032:	2d 85       	ldd	r18, Y+13	; 0x0d
    2034:	3e 85       	ldd	r19, Y+14	; 0x0e
    2036:	4f 85       	ldd	r20, Y+15	; 0x0f
    2038:	58 89       	ldd	r21, Y+16	; 0x10
    203a:	69 85       	ldd	r22, Y+9	; 0x09
    203c:	7a 85       	ldd	r23, Y+10	; 0x0a
    203e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2040:	9c 85       	ldd	r25, Y+12	; 0x0c
    2042:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    2046:	9b 01       	movw	r18, r22
    2048:	ac 01       	movw	r20, r24
    204a:	c7 01       	movw	r24, r14
    204c:	b6 01       	movw	r22, r12
    204e:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>

	*pressure = comp_press + PRESSURE_OFFSET;
    2052:	20 e0       	ldi	r18, 0x00	; 0
    2054:	30 e0       	ldi	r19, 0x00	; 0
    2056:	4c ed       	ldi	r20, 0xDC	; 220
    2058:	53 e4       	ldi	r21, 0x43	; 67
    205a:	0e 94 0b 1c 	call	0x3816	; 0x3816 <__addsf3>
    205e:	f8 01       	movw	r30, r16
    2060:	60 83       	st	Z, r22
    2062:	71 83       	std	Z+1, r23	; 0x01
    2064:	82 83       	std	Z+2, r24	; 0x02
    2066:	93 83       	std	Z+3, r25	; 0x03
}
    2068:	60 96       	adiw	r28, 0x10	; 16
    206a:	0f b6       	in	r0, 0x3f	; 63
    206c:	f8 94       	cli
    206e:	de bf       	out	0x3e, r29	; 62
    2070:	0f be       	out	0x3f, r0	; 63
    2072:	cd bf       	out	0x3d, r28	; 61
    2074:	df 91       	pop	r29
    2076:	cf 91       	pop	r28
    2078:	1f 91       	pop	r17
    207a:	0f 91       	pop	r16
    207c:	ff 90       	pop	r15
    207e:	ef 90       	pop	r14
    2080:	df 90       	pop	r13
    2082:	cf 90       	pop	r12
    2084:	bf 90       	pop	r11
    2086:	af 90       	pop	r10
    2088:	9f 90       	pop	r9
    208a:	8f 90       	pop	r8
    208c:	7f 90       	pop	r7
    208e:	6f 90       	pop	r6
    2090:	5f 90       	pop	r5
    2092:	4f 90       	pop	r4
    2094:	08 95       	ret

00002096 <BMP390_get_readings>:
	uint8_t reg_data[21] = {0};
	BMP390_read_series(CALIB_DATA, reg_data, 21);
	parse_calib_data(reg_data);
}

void BMP390_get_readings(float *pressure, float *temperature) {
    2096:	0f 93       	push	r16
    2098:	1f 93       	push	r17
    209a:	cf 93       	push	r28
    209c:	df 93       	push	r29
    209e:	ec 01       	movw	r28, r24
    20a0:	8b 01       	movw	r16, r22
	BMP390_read_data(&raw_readings.pressure, &raw_readings.temperature); // get raw data values
    20a2:	6b e5       	ldi	r22, 0x5B	; 91
    20a4:	7d e1       	ldi	r23, 0x1D	; 29
    20a6:	87 e5       	ldi	r24, 0x57	; 87
    20a8:	9d e1       	ldi	r25, 0x1D	; 29
    20aa:	e2 dd       	rcall	.-1084   	; 0x1c70 <BMP390_read_data>
	
	BMP390_get_pres_data(pressure, BMP390_get_temp_data(temperature));
    20ac:	c8 01       	movw	r24, r16
    20ae:	3b de       	rcall	.-906    	; 0x1d26 <BMP390_get_temp_data>
    20b0:	bc 01       	movw	r22, r24
    20b2:	ce 01       	movw	r24, r28
    20b4:	85 de       	rcall	.-758    	; 0x1dc0 <BMP390_get_pres_data>
}
    20b6:	df 91       	pop	r29
    20b8:	cf 91       	pop	r28
    20ba:	1f 91       	pop	r17
    20bc:	0f 91       	pop	r16
    20be:	08 95       	ret

000020c0 <parse_calib_data>:

	*pressure = comp_press + PRESSURE_OFFSET;
}

void parse_calib_data(const uint8_t *reg_data)
{
    20c0:	ef 92       	push	r14
    20c2:	ff 92       	push	r15
    20c4:	0f 93       	push	r16
    20c6:	1f 93       	push	r17
    20c8:	cf 93       	push	r28
    20ca:	df 93       	push	r29
    20cc:	ec 01       	movw	r28, r24
	/* Temporary variable */
	double temp_var;

	/* 1 / 2^8 */
	temp_var = 0.00390625f;
	raw_calibs.par_t1 = CONCAT_BYTES(reg_data[1], reg_data[0]);
    20ce:	69 81       	ldd	r22, Y+1	; 0x01
    20d0:	70 e0       	ldi	r23, 0x00	; 0
    20d2:	76 2f       	mov	r23, r22
    20d4:	66 27       	eor	r22, r22
    20d6:	88 81       	ld	r24, Y
    20d8:	68 2b       	or	r22, r24
    20da:	0f 2e       	mov	r0, r31
    20dc:	ff e5       	ldi	r31, 0x5F	; 95
    20de:	ef 2e       	mov	r14, r31
    20e0:	fd e1       	ldi	r31, 0x1D	; 29
    20e2:	ff 2e       	mov	r15, r31
    20e4:	f0 2d       	mov	r31, r0
    20e6:	f7 01       	movw	r30, r14
    20e8:	71 83       	std	Z+1, r23	; 0x01
    20ea:	60 83       	st	Z, r22
	calculated_calibs.par_t1 = ((double)raw_calibs.par_t1 / temp_var);
    20ec:	80 e0       	ldi	r24, 0x00	; 0
    20ee:	90 e0       	ldi	r25, 0x00	; 0
    20f0:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <__floatunsisf>
    20f4:	20 e0       	ldi	r18, 0x00	; 0
    20f6:	30 e0       	ldi	r19, 0x00	; 0
    20f8:	40 e8       	ldi	r20, 0x80	; 128
    20fa:	53 e4       	ldi	r21, 0x43	; 67
    20fc:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    2100:	04 e7       	ldi	r16, 0x74	; 116
    2102:	1d e1       	ldi	r17, 0x1D	; 29
    2104:	f8 01       	movw	r30, r16
    2106:	60 83       	st	Z, r22
    2108:	71 83       	std	Z+1, r23	; 0x01
    210a:	82 83       	std	Z+2, r24	; 0x02
    210c:	93 83       	std	Z+3, r25	; 0x03
	raw_calibs.par_t2 = CONCAT_BYTES(reg_data[3], reg_data[2]);
    210e:	6b 81       	ldd	r22, Y+3	; 0x03
    2110:	70 e0       	ldi	r23, 0x00	; 0
    2112:	76 2f       	mov	r23, r22
    2114:	66 27       	eor	r22, r22
    2116:	8a 81       	ldd	r24, Y+2	; 0x02
    2118:	68 2b       	or	r22, r24
    211a:	f7 01       	movw	r30, r14
    211c:	73 83       	std	Z+3, r23	; 0x03
    211e:	62 83       	std	Z+2, r22	; 0x02
	temp_var = 1073741824.0f;
	calculated_calibs.par_t2 = ((double)raw_calibs.par_t2 / temp_var);
    2120:	80 e0       	ldi	r24, 0x00	; 0
    2122:	90 e0       	ldi	r25, 0x00	; 0
    2124:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <__floatunsisf>
    2128:	20 e0       	ldi	r18, 0x00	; 0
    212a:	30 e0       	ldi	r19, 0x00	; 0
    212c:	40 e8       	ldi	r20, 0x80	; 128
    212e:	50 e3       	ldi	r21, 0x30	; 48
    2130:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    2134:	f8 01       	movw	r30, r16
    2136:	64 83       	std	Z+4, r22	; 0x04
    2138:	75 83       	std	Z+5, r23	; 0x05
    213a:	86 83       	std	Z+6, r24	; 0x06
    213c:	97 83       	std	Z+7, r25	; 0x07
	raw_calibs.par_t3 = (int8_t)reg_data[4];
    213e:	6c 81       	ldd	r22, Y+4	; 0x04
    2140:	f7 01       	movw	r30, r14
    2142:	64 83       	std	Z+4, r22	; 0x04
	temp_var = 281474976710656.0f;
	calculated_calibs.par_t3 = ((double)raw_calibs.par_t3 / temp_var);
    2144:	06 2e       	mov	r0, r22
    2146:	00 0c       	add	r0, r0
    2148:	77 0b       	sbc	r23, r23
    214a:	88 0b       	sbc	r24, r24
    214c:	99 0b       	sbc	r25, r25
    214e:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    2152:	20 e0       	ldi	r18, 0x00	; 0
    2154:	30 e0       	ldi	r19, 0x00	; 0
    2156:	40 e8       	ldi	r20, 0x80	; 128
    2158:	57 e2       	ldi	r21, 0x27	; 39
    215a:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    215e:	f8 01       	movw	r30, r16
    2160:	60 87       	std	Z+8, r22	; 0x08
    2162:	71 87       	std	Z+9, r23	; 0x09
    2164:	82 87       	std	Z+10, r24	; 0x0a
    2166:	93 87       	std	Z+11, r25	; 0x0b
	raw_calibs.par_p1 = (int16_t)CONCAT_BYTES(reg_data[6], reg_data[5]);
    2168:	6e 81       	ldd	r22, Y+6	; 0x06
    216a:	70 e0       	ldi	r23, 0x00	; 0
    216c:	76 2f       	mov	r23, r22
    216e:	66 27       	eor	r22, r22
    2170:	8d 81       	ldd	r24, Y+5	; 0x05
    2172:	68 2b       	or	r22, r24
    2174:	f7 01       	movw	r30, r14
    2176:	76 83       	std	Z+6, r23	; 0x06
    2178:	65 83       	std	Z+5, r22	; 0x05
	temp_var = 1048576.0f;
	calculated_calibs.par_p1 = ((double)(raw_calibs.par_p1 - (16384)) / temp_var);
    217a:	70 54       	subi	r23, 0x40	; 64
    217c:	07 2e       	mov	r0, r23
    217e:	00 0c       	add	r0, r0
    2180:	88 0b       	sbc	r24, r24
    2182:	99 0b       	sbc	r25, r25
    2184:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    2188:	20 e0       	ldi	r18, 0x00	; 0
    218a:	30 e0       	ldi	r19, 0x00	; 0
    218c:	40 e8       	ldi	r20, 0x80	; 128
    218e:	55 e3       	ldi	r21, 0x35	; 53
    2190:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    2194:	f8 01       	movw	r30, r16
    2196:	64 87       	std	Z+12, r22	; 0x0c
    2198:	75 87       	std	Z+13, r23	; 0x0d
    219a:	86 87       	std	Z+14, r24	; 0x0e
    219c:	97 87       	std	Z+15, r25	; 0x0f
	raw_calibs.par_p2 = (int16_t)CONCAT_BYTES(reg_data[8], reg_data[7]);
    219e:	68 85       	ldd	r22, Y+8	; 0x08
    21a0:	70 e0       	ldi	r23, 0x00	; 0
    21a2:	76 2f       	mov	r23, r22
    21a4:	66 27       	eor	r22, r22
    21a6:	8f 81       	ldd	r24, Y+7	; 0x07
    21a8:	68 2b       	or	r22, r24
    21aa:	f7 01       	movw	r30, r14
    21ac:	70 87       	std	Z+8, r23	; 0x08
    21ae:	67 83       	std	Z+7, r22	; 0x07
	temp_var = 536870912.0f;
	calculated_calibs.par_p2 = ((double)(raw_calibs.par_p2 - (16384)) / temp_var);
    21b0:	70 54       	subi	r23, 0x40	; 64
    21b2:	07 2e       	mov	r0, r23
    21b4:	00 0c       	add	r0, r0
    21b6:	88 0b       	sbc	r24, r24
    21b8:	99 0b       	sbc	r25, r25
    21ba:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    21be:	20 e0       	ldi	r18, 0x00	; 0
    21c0:	30 e0       	ldi	r19, 0x00	; 0
    21c2:	40 e0       	ldi	r20, 0x00	; 0
    21c4:	51 e3       	ldi	r21, 0x31	; 49
    21c6:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    21ca:	f8 01       	movw	r30, r16
    21cc:	60 8b       	std	Z+16, r22	; 0x10
    21ce:	71 8b       	std	Z+17, r23	; 0x11
    21d0:	82 8b       	std	Z+18, r24	; 0x12
    21d2:	93 8b       	std	Z+19, r25	; 0x13
	raw_calibs.par_p3 = (int8_t)reg_data[9];
    21d4:	69 85       	ldd	r22, Y+9	; 0x09
    21d6:	f7 01       	movw	r30, r14
    21d8:	61 87       	std	Z+9, r22	; 0x09
	temp_var = 4294967296.0f;
	calculated_calibs.par_p3 = ((double)raw_calibs.par_p3 / temp_var);
    21da:	06 2e       	mov	r0, r22
    21dc:	00 0c       	add	r0, r0
    21de:	77 0b       	sbc	r23, r23
    21e0:	88 0b       	sbc	r24, r24
    21e2:	99 0b       	sbc	r25, r25
    21e4:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    21e8:	20 e0       	ldi	r18, 0x00	; 0
    21ea:	30 e0       	ldi	r19, 0x00	; 0
    21ec:	40 e8       	ldi	r20, 0x80	; 128
    21ee:	5f e2       	ldi	r21, 0x2F	; 47
    21f0:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    21f4:	f8 01       	movw	r30, r16
    21f6:	64 8b       	std	Z+20, r22	; 0x14
    21f8:	75 8b       	std	Z+21, r23	; 0x15
    21fa:	86 8b       	std	Z+22, r24	; 0x16
    21fc:	97 8b       	std	Z+23, r25	; 0x17
	raw_calibs.par_p4 = (int8_t)reg_data[10];
    21fe:	6a 85       	ldd	r22, Y+10	; 0x0a
    2200:	f7 01       	movw	r30, r14
    2202:	62 87       	std	Z+10, r22	; 0x0a
	temp_var = 137438953472.0f;
	calculated_calibs.par_p4 = ((double)raw_calibs.par_p4 / temp_var);
    2204:	06 2e       	mov	r0, r22
    2206:	00 0c       	add	r0, r0
    2208:	77 0b       	sbc	r23, r23
    220a:	88 0b       	sbc	r24, r24
    220c:	99 0b       	sbc	r25, r25
    220e:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    2212:	20 e0       	ldi	r18, 0x00	; 0
    2214:	30 e0       	ldi	r19, 0x00	; 0
    2216:	40 e0       	ldi	r20, 0x00	; 0
    2218:	5d e2       	ldi	r21, 0x2D	; 45
    221a:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    221e:	f8 01       	movw	r30, r16
    2220:	60 8f       	std	Z+24, r22	; 0x18
    2222:	71 8f       	std	Z+25, r23	; 0x19
    2224:	82 8f       	std	Z+26, r24	; 0x1a
    2226:	93 8f       	std	Z+27, r25	; 0x1b
	raw_calibs.par_p5 = CONCAT_BYTES(reg_data[12], reg_data[11]);
    2228:	6c 85       	ldd	r22, Y+12	; 0x0c
    222a:	70 e0       	ldi	r23, 0x00	; 0
    222c:	76 2f       	mov	r23, r22
    222e:	66 27       	eor	r22, r22
    2230:	8b 85       	ldd	r24, Y+11	; 0x0b
    2232:	68 2b       	or	r22, r24
    2234:	f7 01       	movw	r30, r14
    2236:	74 87       	std	Z+12, r23	; 0x0c
    2238:	63 87       	std	Z+11, r22	; 0x0b

	/* 1 / 2^3 */
	temp_var = 0.125f;
	calculated_calibs.par_p5 = ((double)raw_calibs.par_p5 / temp_var);
    223a:	80 e0       	ldi	r24, 0x00	; 0
    223c:	90 e0       	ldi	r25, 0x00	; 0
    223e:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <__floatunsisf>
    2242:	20 e0       	ldi	r18, 0x00	; 0
    2244:	30 e0       	ldi	r19, 0x00	; 0
    2246:	40 e0       	ldi	r20, 0x00	; 0
    2248:	51 e4       	ldi	r21, 0x41	; 65
    224a:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    224e:	f8 01       	movw	r30, r16
    2250:	64 8f       	std	Z+28, r22	; 0x1c
    2252:	75 8f       	std	Z+29, r23	; 0x1d
    2254:	86 8f       	std	Z+30, r24	; 0x1e
    2256:	97 8f       	std	Z+31, r25	; 0x1f
	raw_calibs.par_p6 = CONCAT_BYTES(reg_data[14], reg_data[13]);
    2258:	6e 85       	ldd	r22, Y+14	; 0x0e
    225a:	70 e0       	ldi	r23, 0x00	; 0
    225c:	76 2f       	mov	r23, r22
    225e:	66 27       	eor	r22, r22
    2260:	8d 85       	ldd	r24, Y+13	; 0x0d
    2262:	68 2b       	or	r22, r24
    2264:	f7 01       	movw	r30, r14
    2266:	76 87       	std	Z+14, r23	; 0x0e
    2268:	65 87       	std	Z+13, r22	; 0x0d
	temp_var = 64.0f;
	calculated_calibs.par_p6 = ((double)raw_calibs.par_p6 / temp_var);
    226a:	80 e0       	ldi	r24, 0x00	; 0
    226c:	90 e0       	ldi	r25, 0x00	; 0
    226e:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <__floatunsisf>
    2272:	20 e0       	ldi	r18, 0x00	; 0
    2274:	30 e0       	ldi	r19, 0x00	; 0
    2276:	40 e8       	ldi	r20, 0x80	; 128
    2278:	5c e3       	ldi	r21, 0x3C	; 60
    227a:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    227e:	f8 01       	movw	r30, r16
    2280:	60 a3       	std	Z+32, r22	; 0x20
    2282:	71 a3       	std	Z+33, r23	; 0x21
    2284:	82 a3       	std	Z+34, r24	; 0x22
    2286:	93 a3       	std	Z+35, r25	; 0x23
	raw_calibs.par_p7 = (int8_t)reg_data[15];
    2288:	6f 85       	ldd	r22, Y+15	; 0x0f
    228a:	f7 01       	movw	r30, r14
    228c:	67 87       	std	Z+15, r22	; 0x0f
	temp_var = 256.0f;
	calculated_calibs.par_p7 = ((double)raw_calibs.par_p7 / temp_var);
    228e:	06 2e       	mov	r0, r22
    2290:	00 0c       	add	r0, r0
    2292:	77 0b       	sbc	r23, r23
    2294:	88 0b       	sbc	r24, r24
    2296:	99 0b       	sbc	r25, r25
    2298:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    229c:	20 e0       	ldi	r18, 0x00	; 0
    229e:	30 e0       	ldi	r19, 0x00	; 0
    22a0:	40 e8       	ldi	r20, 0x80	; 128
    22a2:	5b e3       	ldi	r21, 0x3B	; 59
    22a4:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    22a8:	f8 01       	movw	r30, r16
    22aa:	64 a3       	std	Z+36, r22	; 0x24
    22ac:	75 a3       	std	Z+37, r23	; 0x25
    22ae:	86 a3       	std	Z+38, r24	; 0x26
    22b0:	97 a3       	std	Z+39, r25	; 0x27
	raw_calibs.par_p8 = (int8_t)reg_data[16];
    22b2:	68 89       	ldd	r22, Y+16	; 0x10
    22b4:	f7 01       	movw	r30, r14
    22b6:	60 8b       	std	Z+16, r22	; 0x10
	temp_var = 32768.0f;
	calculated_calibs.par_p8 = ((double)raw_calibs.par_p8 / temp_var);
    22b8:	06 2e       	mov	r0, r22
    22ba:	00 0c       	add	r0, r0
    22bc:	77 0b       	sbc	r23, r23
    22be:	88 0b       	sbc	r24, r24
    22c0:	99 0b       	sbc	r25, r25
    22c2:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    22c6:	20 e0       	ldi	r18, 0x00	; 0
    22c8:	30 e0       	ldi	r19, 0x00	; 0
    22ca:	40 e0       	ldi	r20, 0x00	; 0
    22cc:	58 e3       	ldi	r21, 0x38	; 56
    22ce:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    22d2:	f8 01       	movw	r30, r16
    22d4:	60 a7       	std	Z+40, r22	; 0x28
    22d6:	71 a7       	std	Z+41, r23	; 0x29
    22d8:	82 a7       	std	Z+42, r24	; 0x2a
    22da:	93 a7       	std	Z+43, r25	; 0x2b
	raw_calibs.par_p9 = (int16_t)CONCAT_BYTES(reg_data[18], reg_data[17]);
    22dc:	6a 89       	ldd	r22, Y+18	; 0x12
    22de:	70 e0       	ldi	r23, 0x00	; 0
    22e0:	76 2f       	mov	r23, r22
    22e2:	66 27       	eor	r22, r22
    22e4:	89 89       	ldd	r24, Y+17	; 0x11
    22e6:	68 2b       	or	r22, r24
    22e8:	f7 01       	movw	r30, r14
    22ea:	72 8b       	std	Z+18, r23	; 0x12
    22ec:	61 8b       	std	Z+17, r22	; 0x11
	temp_var = 281474976710656.0f;
	calculated_calibs.par_p9 = ((double)raw_calibs.par_p9 / temp_var);
    22ee:	07 2e       	mov	r0, r23
    22f0:	00 0c       	add	r0, r0
    22f2:	88 0b       	sbc	r24, r24
    22f4:	99 0b       	sbc	r25, r25
    22f6:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    22fa:	20 e0       	ldi	r18, 0x00	; 0
    22fc:	30 e0       	ldi	r19, 0x00	; 0
    22fe:	40 e8       	ldi	r20, 0x80	; 128
    2300:	57 e2       	ldi	r21, 0x27	; 39
    2302:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    2306:	f8 01       	movw	r30, r16
    2308:	64 a7       	std	Z+44, r22	; 0x2c
    230a:	75 a7       	std	Z+45, r23	; 0x2d
    230c:	86 a7       	std	Z+46, r24	; 0x2e
    230e:	97 a7       	std	Z+47, r25	; 0x2f
	raw_calibs.par_p10 = (int8_t)reg_data[19];
    2310:	6b 89       	ldd	r22, Y+19	; 0x13
    2312:	f7 01       	movw	r30, r14
    2314:	63 8b       	std	Z+19, r22	; 0x13
	temp_var = 281474976710656.0f;
	calculated_calibs.par_p10 = ((double)raw_calibs.par_p10 / temp_var);
    2316:	06 2e       	mov	r0, r22
    2318:	00 0c       	add	r0, r0
    231a:	77 0b       	sbc	r23, r23
    231c:	88 0b       	sbc	r24, r24
    231e:	99 0b       	sbc	r25, r25
    2320:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    2324:	20 e0       	ldi	r18, 0x00	; 0
    2326:	30 e0       	ldi	r19, 0x00	; 0
    2328:	40 e8       	ldi	r20, 0x80	; 128
    232a:	57 e2       	ldi	r21, 0x27	; 39
    232c:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    2330:	f8 01       	movw	r30, r16
    2332:	60 ab       	std	Z+48, r22	; 0x30
    2334:	71 ab       	std	Z+49, r23	; 0x31
    2336:	82 ab       	std	Z+50, r24	; 0x32
    2338:	93 ab       	std	Z+51, r25	; 0x33
	raw_calibs.par_p11 = (int8_t)reg_data[20];
    233a:	6c 89       	ldd	r22, Y+20	; 0x14
    233c:	f7 01       	movw	r30, r14
    233e:	64 8b       	std	Z+20, r22	; 0x14
	temp_var = 36893488147419103232.0f;
	calculated_calibs.par_p11 = ((double)raw_calibs.par_p11 / temp_var);
    2340:	06 2e       	mov	r0, r22
    2342:	00 0c       	add	r0, r0
    2344:	77 0b       	sbc	r23, r23
    2346:	88 0b       	sbc	r24, r24
    2348:	99 0b       	sbc	r25, r25
    234a:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    234e:	20 e0       	ldi	r18, 0x00	; 0
    2350:	30 e0       	ldi	r19, 0x00	; 0
    2352:	40 e0       	ldi	r20, 0x00	; 0
    2354:	5f e1       	ldi	r21, 0x1F	; 31
    2356:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    235a:	f8 01       	movw	r30, r16
    235c:	64 ab       	std	Z+52, r22	; 0x34
    235e:	75 ab       	std	Z+53, r23	; 0x35
    2360:	86 ab       	std	Z+54, r24	; 0x36
    2362:	97 ab       	std	Z+55, r25	; 0x37
    2364:	df 91       	pop	r29
    2366:	cf 91       	pop	r28
    2368:	1f 91       	pop	r17
    236a:	0f 91       	pop	r16
    236c:	ff 90       	pop	r15
    236e:	ef 90       	pop	r14
    2370:	08 95       	ret

00002372 <BMP390_read_calib>:
	
	*pressure = CONCAT_3_BYTES(data_bytes[2], data_bytes[1], data_bytes[0]);
	*temperature = CONCAT_3_BYTES(data_bytes[5], data_bytes[4], data_bytes[3]);
}

void BMP390_read_calib() {
    2372:	0f 93       	push	r16
    2374:	1f 93       	push	r17
    2376:	cf 93       	push	r28
    2378:	df 93       	push	r29
    237a:	cd b7       	in	r28, 0x3d	; 61
    237c:	de b7       	in	r29, 0x3e	; 62
    237e:	65 97       	sbiw	r28, 0x15	; 21
    2380:	0f b6       	in	r0, 0x3f	; 63
    2382:	f8 94       	cli
    2384:	de bf       	out	0x3e, r29	; 62
    2386:	0f be       	out	0x3f, r0	; 63
    2388:	cd bf       	out	0x3d, r28	; 61
	// create reg_data_array
	uint8_t reg_data[21] = {0};
    238a:	8e 01       	movw	r16, r28
    238c:	0f 5f       	subi	r16, 0xFF	; 255
    238e:	1f 4f       	sbci	r17, 0xFF	; 255
    2390:	85 e1       	ldi	r24, 0x15	; 21
    2392:	f8 01       	movw	r30, r16
    2394:	11 92       	st	Z+, r1
    2396:	8a 95       	dec	r24
    2398:	e9 f7       	brne	.-6      	; 0x2394 <BMP390_read_calib+0x22>
	BMP390_read_series(CALIB_DATA, reg_data, 21);
    239a:	45 e1       	ldi	r20, 0x15	; 21
    239c:	50 e0       	ldi	r21, 0x00	; 0
    239e:	b8 01       	movw	r22, r16
    23a0:	81 e3       	ldi	r24, 0x31	; 49
    23a2:	01 dc       	rcall	.-2046   	; 0x1ba6 <BMP390_read_series>
	parse_calib_data(reg_data);
    23a4:	c8 01       	movw	r24, r16
    23a6:	8c de       	rcall	.-744    	; 0x20c0 <parse_calib_data>
}
    23a8:	65 96       	adiw	r28, 0x15	; 21
    23aa:	0f b6       	in	r0, 0x3f	; 63
    23ac:	f8 94       	cli
    23ae:	de bf       	out	0x3e, r29	; 62
    23b0:	0f be       	out	0x3f, r0	; 63
    23b2:	cd bf       	out	0x3d, r28	; 61
    23b4:	df 91       	pop	r29
    23b6:	cf 91       	pop	r28
    23b8:	1f 91       	pop	r17
    23ba:	0f 91       	pop	r16
    23bc:	08 95       	ret

000023be <BMP390_init>:
	SPI_transaction(write_byte);
	SPI_deselect(SS_BMP390);
}

void BMP390_init() {
	BMP390_write(0x1C, 0x03); // set osr
    23be:	63 e0       	ldi	r22, 0x03	; 3
    23c0:	8c e1       	ldi	r24, 0x1C	; 28
    23c2:	31 dc       	rcall	.-1950   	; 0x1c26 <BMP390_write>
	BMP390_write(0x1D, 0x02); // set odr
    23c4:	62 e0       	ldi	r22, 0x02	; 2
    23c6:	8d e1       	ldi	r24, 0x1D	; 29
    23c8:	2e dc       	rcall	.-1956   	; 0x1c26 <BMP390_write>
	BMP390_write(0x1B, 0x33); // enter normal mode
    23ca:	63 e3       	ldi	r22, 0x33	; 51
    23cc:	8b e1       	ldi	r24, 0x1B	; 27
	
	BMP390_read_calib(); // read and calculated calibrations
    23ce:	2b dc       	rcall	.-1962   	; 0x1c26 <BMP390_write>
    23d0:	d0 cf       	rjmp	.-96     	; 0x2372 <BMP390_read_calib>
    23d2:	08 95       	ret

000023d4 <BNO055_multiread>:
	BNO055_read_test(&id);
	return ((id & 0x0F) == 0x0F);
}

void BNO055_read_temp(int8_t *buf) {
	BNO055_multiread(0x34, buf, 1);
    23d4:	ef 92       	push	r14
    23d6:	ff 92       	push	r15
    23d8:	0f 93       	push	r16
    23da:	1f 93       	push	r17
    23dc:	cf 93       	push	r28
    23de:	df 93       	push	r29
    23e0:	c8 2f       	mov	r28, r24
    23e2:	8b 01       	movw	r16, r22
    23e4:	7a 01       	movw	r14, r20
    23e6:	a5 d1       	rcall	.+842    	; 0x2732 <i2c_send_start>
    23e8:	89 e2       	ldi	r24, 0x29	; 41
    23ea:	af d1       	rcall	.+862    	; 0x274a <i2c_enter_MT_mode>
    23ec:	8c 2f       	mov	r24, r28
    23ee:	c6 d1       	rcall	.+908    	; 0x277c <i2c_send>
    23f0:	a0 d1       	rcall	.+832    	; 0x2732 <i2c_send_start>
    23f2:	89 e2       	ldi	r24, 0x29	; 41
    23f4:	b5 d1       	rcall	.+874    	; 0x2760 <i2c_enter_MR_mode>
    23f6:	c0 e0       	ldi	r28, 0x00	; 0
    23f8:	d0 e0       	ldi	r29, 0x00	; 0
    23fa:	05 c0       	rjmp	.+10     	; 0x2406 <BNO055_multiread+0x32>
    23fc:	c8 01       	movw	r24, r16
    23fe:	8c 0f       	add	r24, r28
    2400:	9d 1f       	adc	r25, r29
    2402:	d2 d1       	rcall	.+932    	; 0x27a8 <i2c_read_ack>
    2404:	21 96       	adiw	r28, 0x01	; 1
    2406:	c7 01       	movw	r24, r14
    2408:	01 97       	sbiw	r24, 0x01	; 1
    240a:	c8 17       	cp	r28, r24
    240c:	d9 07       	cpc	r29, r25
    240e:	b0 f3       	brcs	.-20     	; 0x23fc <BNO055_multiread+0x28>
    2410:	80 0f       	add	r24, r16
    2412:	91 1f       	adc	r25, r17
    2414:	bd d1       	rcall	.+890    	; 0x2790 <i2c_read_nack>
    2416:	95 d1       	rcall	.+810    	; 0x2742 <i2c_send_stop>
    2418:	df 91       	pop	r29
    241a:	cf 91       	pop	r28
    241c:	1f 91       	pop	r17
    241e:	0f 91       	pop	r16
    2420:	ff 90       	pop	r15
    2422:	ef 90       	pop	r14
    2424:	08 95       	ret

00002426 <BNO055_write>:
    2426:	cf 93       	push	r28
    2428:	df 93       	push	r29
    242a:	d8 2f       	mov	r29, r24
    242c:	c6 2f       	mov	r28, r22
    242e:	81 d1       	rcall	.+770    	; 0x2732 <i2c_send_start>
    2430:	89 e2       	ldi	r24, 0x29	; 41
    2432:	8b d1       	rcall	.+790    	; 0x274a <i2c_enter_MT_mode>
    2434:	8d 2f       	mov	r24, r29
    2436:	a2 d1       	rcall	.+836    	; 0x277c <i2c_send>
    2438:	8c 2f       	mov	r24, r28
    243a:	a0 d1       	rcall	.+832    	; 0x277c <i2c_send>
    243c:	82 d1       	rcall	.+772    	; 0x2742 <i2c_send_stop>
    243e:	df 91       	pop	r29
    2440:	cf 91       	pop	r28
    2442:	08 95       	ret

00002444 <BNO055_init>:
    2444:	6c e0       	ldi	r22, 0x0C	; 12
    2446:	8d e3       	ldi	r24, 0x3D	; 61
    2448:	ee cf       	rjmp	.-36     	; 0x2426 <BNO055_write>
    244a:	08 95       	ret

0000244c <BNO055_read_test>:
    244c:	41 e0       	ldi	r20, 0x01	; 1
    244e:	50 e0       	ldi	r21, 0x00	; 0
    2450:	bc 01       	movw	r22, r24
    2452:	86 e3       	ldi	r24, 0x36	; 54
    2454:	bf cf       	rjmp	.-130    	; 0x23d4 <BNO055_multiread>
    2456:	08 95       	ret

00002458 <BNO055_test>:
    2458:	cf 93       	push	r28
    245a:	df 93       	push	r29
    245c:	1f 92       	push	r1
    245e:	cd b7       	in	r28, 0x3d	; 61
    2460:	de b7       	in	r29, 0x3e	; 62
    2462:	ce 01       	movw	r24, r28
    2464:	01 96       	adiw	r24, 0x01	; 1
    2466:	f2 df       	rcall	.-28     	; 0x244c <BNO055_read_test>
    2468:	99 81       	ldd	r25, Y+1	; 0x01
    246a:	9f 70       	andi	r25, 0x0F	; 15
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	9f 30       	cpi	r25, 0x0F	; 15
    2470:	09 f0       	breq	.+2      	; 0x2474 <BNO055_test+0x1c>
    2472:	80 e0       	ldi	r24, 0x00	; 0
    2474:	0f 90       	pop	r0
    2476:	df 91       	pop	r29
    2478:	cf 91       	pop	r28
    247a:	08 95       	ret

0000247c <BNO055_read_acc>:
}

void BNO055_read_acc(float *accel) {
    247c:	cf 92       	push	r12
    247e:	df 92       	push	r13
    2480:	ef 92       	push	r14
    2482:	ff 92       	push	r15
    2484:	0f 93       	push	r16
    2486:	1f 93       	push	r17
    2488:	cf 93       	push	r28
    248a:	df 93       	push	r29
    248c:	00 d0       	rcall	.+0      	; 0x248e <BNO055_read_acc+0x12>
    248e:	00 d0       	rcall	.+0      	; 0x2490 <BNO055_read_acc+0x14>
    2490:	cd b7       	in	r28, 0x3d	; 61
    2492:	de b7       	in	r29, 0x3e	; 62
    2494:	8c 01       	movw	r16, r24
	uint8_t data_buf[6];
	BNO055_multiread(0x08, data_buf, 6);
    2496:	46 e0       	ldi	r20, 0x06	; 6
    2498:	50 e0       	ldi	r21, 0x00	; 0
    249a:	be 01       	movw	r22, r28
    249c:	6f 5f       	subi	r22, 0xFF	; 255
    249e:	7f 4f       	sbci	r23, 0xFF	; 255
    24a0:	88 e0       	ldi	r24, 0x08	; 8
    24a2:	98 df       	rcall	.-208    	; 0x23d4 <BNO055_multiread>
	
	int16_t partial_x, partial_y, partial_z;
	
	partial_x = (int16_t)((data_buf[1] << 8) | data_buf[0]);
    24a4:	6a 81       	ldd	r22, Y+2	; 0x02
    24a6:	70 e0       	ldi	r23, 0x00	; 0
    24a8:	76 2f       	mov	r23, r22
    24aa:	66 27       	eor	r22, r22
    24ac:	89 81       	ldd	r24, Y+1	; 0x01
    24ae:	68 2b       	or	r22, r24
	partial_y = (int16_t)((data_buf[3] << 8) | data_buf[2]);
    24b0:	8c 81       	ldd	r24, Y+4	; 0x04
    24b2:	90 e0       	ldi	r25, 0x00	; 0
    24b4:	98 2f       	mov	r25, r24
    24b6:	88 27       	eor	r24, r24
    24b8:	2b 81       	ldd	r18, Y+3	; 0x03
    24ba:	6c 01       	movw	r12, r24
    24bc:	c2 2a       	or	r12, r18
	partial_z = (int16_t)((data_buf[5] << 8) | data_buf[4]);
    24be:	8e 81       	ldd	r24, Y+6	; 0x06
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	98 2f       	mov	r25, r24
    24c4:	88 27       	eor	r24, r24
    24c6:	2d 81       	ldd	r18, Y+5	; 0x05
    24c8:	7c 01       	movw	r14, r24
    24ca:	e2 2a       	or	r14, r18
	
	accel[0] = (float)partial_x/ACC_CAL;
    24cc:	07 2e       	mov	r0, r23
    24ce:	00 0c       	add	r0, r0
    24d0:	88 0b       	sbc	r24, r24
    24d2:	99 0b       	sbc	r25, r25
    24d4:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    24d8:	20 e0       	ldi	r18, 0x00	; 0
    24da:	30 e0       	ldi	r19, 0x00	; 0
    24dc:	48 ec       	ldi	r20, 0xC8	; 200
    24de:	52 e4       	ldi	r21, 0x42	; 66
    24e0:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <__divsf3>
    24e4:	f8 01       	movw	r30, r16
    24e6:	60 83       	st	Z, r22
    24e8:	71 83       	std	Z+1, r23	; 0x01
    24ea:	82 83       	std	Z+2, r24	; 0x02
    24ec:	93 83       	std	Z+3, r25	; 0x03
	accel[1] = (float)partial_y/ACC_CAL;
    24ee:	b6 01       	movw	r22, r12
    24f0:	dd 0c       	add	r13, r13
    24f2:	88 0b       	sbc	r24, r24
    24f4:	99 0b       	sbc	r25, r25
    24f6:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    24fa:	20 e0       	ldi	r18, 0x00	; 0
    24fc:	30 e0       	ldi	r19, 0x00	; 0
    24fe:	48 ec       	ldi	r20, 0xC8	; 200
    2500:	52 e4       	ldi	r21, 0x42	; 66
    2502:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <__divsf3>
    2506:	f8 01       	movw	r30, r16
    2508:	64 83       	std	Z+4, r22	; 0x04
    250a:	75 83       	std	Z+5, r23	; 0x05
    250c:	86 83       	std	Z+6, r24	; 0x06
    250e:	97 83       	std	Z+7, r25	; 0x07
	accel[2] = (float)partial_z/ACC_CAL;
    2510:	b7 01       	movw	r22, r14
    2512:	ff 0c       	add	r15, r15
    2514:	88 0b       	sbc	r24, r24
    2516:	99 0b       	sbc	r25, r25
    2518:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    251c:	20 e0       	ldi	r18, 0x00	; 0
    251e:	30 e0       	ldi	r19, 0x00	; 0
    2520:	48 ec       	ldi	r20, 0xC8	; 200
    2522:	52 e4       	ldi	r21, 0x42	; 66
    2524:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <__divsf3>
    2528:	f8 01       	movw	r30, r16
    252a:	60 87       	std	Z+8, r22	; 0x08
    252c:	71 87       	std	Z+9, r23	; 0x09
    252e:	82 87       	std	Z+10, r24	; 0x0a
    2530:	93 87       	std	Z+11, r25	; 0x0b
	
	//char buf[30];
	//sprintf(buf, "check acc_z: %d\r\n", (int)(accel[2]*100));
	//print(buf);
}
    2532:	26 96       	adiw	r28, 0x06	; 6
    2534:	0f b6       	in	r0, 0x3f	; 63
    2536:	f8 94       	cli
    2538:	de bf       	out	0x3e, r29	; 62
    253a:	0f be       	out	0x3f, r0	; 63
    253c:	cd bf       	out	0x3d, r28	; 61
    253e:	df 91       	pop	r29
    2540:	cf 91       	pop	r28
    2542:	1f 91       	pop	r17
    2544:	0f 91       	pop	r16
    2546:	ff 90       	pop	r15
    2548:	ef 90       	pop	r14
    254a:	df 90       	pop	r13
    254c:	cf 90       	pop	r12
    254e:	08 95       	ret

00002550 <BNO055_read_mag>:

void BNO055_read_mag(float *mag) {
    2550:	cf 92       	push	r12
    2552:	df 92       	push	r13
    2554:	ef 92       	push	r14
    2556:	ff 92       	push	r15
    2558:	0f 93       	push	r16
    255a:	1f 93       	push	r17
    255c:	cf 93       	push	r28
    255e:	df 93       	push	r29
    2560:	00 d0       	rcall	.+0      	; 0x2562 <BNO055_read_mag+0x12>
    2562:	00 d0       	rcall	.+0      	; 0x2564 <BNO055_read_mag+0x14>
    2564:	cd b7       	in	r28, 0x3d	; 61
    2566:	de b7       	in	r29, 0x3e	; 62
    2568:	8c 01       	movw	r16, r24
	uint8_t data_buf[6];
	BNO055_multiread(0x0E, data_buf, 6);
    256a:	46 e0       	ldi	r20, 0x06	; 6
    256c:	50 e0       	ldi	r21, 0x00	; 0
    256e:	be 01       	movw	r22, r28
    2570:	6f 5f       	subi	r22, 0xFF	; 255
    2572:	7f 4f       	sbci	r23, 0xFF	; 255
    2574:	8e e0       	ldi	r24, 0x0E	; 14
    2576:	2e df       	rcall	.-420    	; 0x23d4 <BNO055_multiread>
	
	int16_t partial_x, partial_y, partial_z;
	
	partial_x = (int16_t)((data_buf[1] << 8) | data_buf[0]);
    2578:	6a 81       	ldd	r22, Y+2	; 0x02
    257a:	70 e0       	ldi	r23, 0x00	; 0
    257c:	76 2f       	mov	r23, r22
    257e:	66 27       	eor	r22, r22
    2580:	89 81       	ldd	r24, Y+1	; 0x01
    2582:	68 2b       	or	r22, r24
	partial_y = (int16_t)((data_buf[3] << 8) | data_buf[2]);
    2584:	8c 81       	ldd	r24, Y+4	; 0x04
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	98 2f       	mov	r25, r24
    258a:	88 27       	eor	r24, r24
    258c:	2b 81       	ldd	r18, Y+3	; 0x03
    258e:	6c 01       	movw	r12, r24
    2590:	c2 2a       	or	r12, r18
	partial_z = (int16_t)((data_buf[5] << 8) | data_buf[4]);
    2592:	8e 81       	ldd	r24, Y+6	; 0x06
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	98 2f       	mov	r25, r24
    2598:	88 27       	eor	r24, r24
    259a:	2d 81       	ldd	r18, Y+5	; 0x05
    259c:	7c 01       	movw	r14, r24
    259e:	e2 2a       	or	r14, r18
	
	mag[0] = (float)partial_x/MAG_CAL;
    25a0:	07 2e       	mov	r0, r23
    25a2:	00 0c       	add	r0, r0
    25a4:	88 0b       	sbc	r24, r24
    25a6:	99 0b       	sbc	r25, r25
    25a8:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    25ac:	20 e0       	ldi	r18, 0x00	; 0
    25ae:	30 e0       	ldi	r19, 0x00	; 0
    25b0:	40 e8       	ldi	r20, 0x80	; 128
    25b2:	5d e3       	ldi	r21, 0x3D	; 61
    25b4:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    25b8:	f8 01       	movw	r30, r16
    25ba:	60 83       	st	Z, r22
    25bc:	71 83       	std	Z+1, r23	; 0x01
    25be:	82 83       	std	Z+2, r24	; 0x02
    25c0:	93 83       	std	Z+3, r25	; 0x03
	mag[1] = (float)partial_y/MAG_CAL;
    25c2:	b6 01       	movw	r22, r12
    25c4:	dd 0c       	add	r13, r13
    25c6:	88 0b       	sbc	r24, r24
    25c8:	99 0b       	sbc	r25, r25
    25ca:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    25ce:	20 e0       	ldi	r18, 0x00	; 0
    25d0:	30 e0       	ldi	r19, 0x00	; 0
    25d2:	40 e8       	ldi	r20, 0x80	; 128
    25d4:	5d e3       	ldi	r21, 0x3D	; 61
    25d6:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    25da:	f8 01       	movw	r30, r16
    25dc:	64 83       	std	Z+4, r22	; 0x04
    25de:	75 83       	std	Z+5, r23	; 0x05
    25e0:	86 83       	std	Z+6, r24	; 0x06
    25e2:	97 83       	std	Z+7, r25	; 0x07
	mag[2] = (float)partial_z/MAG_CAL;
    25e4:	b7 01       	movw	r22, r14
    25e6:	ff 0c       	add	r15, r15
    25e8:	88 0b       	sbc	r24, r24
    25ea:	99 0b       	sbc	r25, r25
    25ec:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    25f0:	20 e0       	ldi	r18, 0x00	; 0
    25f2:	30 e0       	ldi	r19, 0x00	; 0
    25f4:	40 e8       	ldi	r20, 0x80	; 128
    25f6:	5d e3       	ldi	r21, 0x3D	; 61
    25f8:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    25fc:	f8 01       	movw	r30, r16
    25fe:	60 87       	std	Z+8, r22	; 0x08
    2600:	71 87       	std	Z+9, r23	; 0x09
    2602:	82 87       	std	Z+10, r24	; 0x0a
    2604:	93 87       	std	Z+11, r25	; 0x0b
}
    2606:	26 96       	adiw	r28, 0x06	; 6
    2608:	0f b6       	in	r0, 0x3f	; 63
    260a:	f8 94       	cli
    260c:	de bf       	out	0x3e, r29	; 62
    260e:	0f be       	out	0x3f, r0	; 63
    2610:	cd bf       	out	0x3d, r28	; 61
    2612:	df 91       	pop	r29
    2614:	cf 91       	pop	r28
    2616:	1f 91       	pop	r17
    2618:	0f 91       	pop	r16
    261a:	ff 90       	pop	r15
    261c:	ef 90       	pop	r14
    261e:	df 90       	pop	r13
    2620:	cf 90       	pop	r12
    2622:	08 95       	ret

00002624 <BNO055_read_gyr>:

void BNO055_read_gyr(float *gyr) {
    2624:	cf 92       	push	r12
    2626:	df 92       	push	r13
    2628:	ef 92       	push	r14
    262a:	ff 92       	push	r15
    262c:	0f 93       	push	r16
    262e:	1f 93       	push	r17
    2630:	cf 93       	push	r28
    2632:	df 93       	push	r29
    2634:	00 d0       	rcall	.+0      	; 0x2636 <BNO055_read_gyr+0x12>
    2636:	00 d0       	rcall	.+0      	; 0x2638 <BNO055_read_gyr+0x14>
    2638:	cd b7       	in	r28, 0x3d	; 61
    263a:	de b7       	in	r29, 0x3e	; 62
    263c:	8c 01       	movw	r16, r24
	uint8_t data_buf[6];
	BNO055_multiread(0x14, data_buf, 6);
    263e:	46 e0       	ldi	r20, 0x06	; 6
    2640:	50 e0       	ldi	r21, 0x00	; 0
    2642:	be 01       	movw	r22, r28
    2644:	6f 5f       	subi	r22, 0xFF	; 255
    2646:	7f 4f       	sbci	r23, 0xFF	; 255
    2648:	84 e1       	ldi	r24, 0x14	; 20
    264a:	c4 de       	rcall	.-632    	; 0x23d4 <BNO055_multiread>
	
	int16_t partial_x, partial_y, partial_z;
	
	partial_x = (int16_t)((data_buf[1] << 8) | data_buf[0]);
    264c:	6a 81       	ldd	r22, Y+2	; 0x02
    264e:	70 e0       	ldi	r23, 0x00	; 0
    2650:	76 2f       	mov	r23, r22
    2652:	66 27       	eor	r22, r22
    2654:	89 81       	ldd	r24, Y+1	; 0x01
    2656:	68 2b       	or	r22, r24
	partial_y = (int16_t)((data_buf[3] << 8) | data_buf[2]);
    2658:	8c 81       	ldd	r24, Y+4	; 0x04
    265a:	90 e0       	ldi	r25, 0x00	; 0
    265c:	98 2f       	mov	r25, r24
    265e:	88 27       	eor	r24, r24
    2660:	2b 81       	ldd	r18, Y+3	; 0x03
    2662:	6c 01       	movw	r12, r24
    2664:	c2 2a       	or	r12, r18
	partial_z = (int16_t)((data_buf[5] << 8) | data_buf[4]);
    2666:	8e 81       	ldd	r24, Y+6	; 0x06
    2668:	90 e0       	ldi	r25, 0x00	; 0
    266a:	98 2f       	mov	r25, r24
    266c:	88 27       	eor	r24, r24
    266e:	2d 81       	ldd	r18, Y+5	; 0x05
    2670:	7c 01       	movw	r14, r24
    2672:	e2 2a       	or	r14, r18
	
	gyr[0] = (float)partial_x/GYR_CAL;
    2674:	07 2e       	mov	r0, r23
    2676:	00 0c       	add	r0, r0
    2678:	88 0b       	sbc	r24, r24
    267a:	99 0b       	sbc	r25, r25
    267c:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    2680:	20 e0       	ldi	r18, 0x00	; 0
    2682:	30 e0       	ldi	r19, 0x00	; 0
    2684:	40 e8       	ldi	r20, 0x80	; 128
    2686:	5d e3       	ldi	r21, 0x3D	; 61
    2688:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    268c:	f8 01       	movw	r30, r16
    268e:	60 83       	st	Z, r22
    2690:	71 83       	std	Z+1, r23	; 0x01
    2692:	82 83       	std	Z+2, r24	; 0x02
    2694:	93 83       	std	Z+3, r25	; 0x03
	gyr[1] = (float)partial_y/GYR_CAL;
    2696:	b6 01       	movw	r22, r12
    2698:	dd 0c       	add	r13, r13
    269a:	88 0b       	sbc	r24, r24
    269c:	99 0b       	sbc	r25, r25
    269e:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    26a2:	20 e0       	ldi	r18, 0x00	; 0
    26a4:	30 e0       	ldi	r19, 0x00	; 0
    26a6:	40 e8       	ldi	r20, 0x80	; 128
    26a8:	5d e3       	ldi	r21, 0x3D	; 61
    26aa:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    26ae:	f8 01       	movw	r30, r16
    26b0:	64 83       	std	Z+4, r22	; 0x04
    26b2:	75 83       	std	Z+5, r23	; 0x05
    26b4:	86 83       	std	Z+6, r24	; 0x06
    26b6:	97 83       	std	Z+7, r25	; 0x07
	gyr[2] = (float)partial_z/GYR_CAL;
    26b8:	b7 01       	movw	r22, r14
    26ba:	ff 0c       	add	r15, r15
    26bc:	88 0b       	sbc	r24, r24
    26be:	99 0b       	sbc	r25, r25
    26c0:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <__floatsisf>
    26c4:	20 e0       	ldi	r18, 0x00	; 0
    26c6:	30 e0       	ldi	r19, 0x00	; 0
    26c8:	40 e8       	ldi	r20, 0x80	; 128
    26ca:	5d e3       	ldi	r21, 0x3D	; 61
    26cc:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    26d0:	f8 01       	movw	r30, r16
    26d2:	60 87       	std	Z+8, r22	; 0x08
    26d4:	71 87       	std	Z+9, r23	; 0x09
    26d6:	82 87       	std	Z+10, r24	; 0x0a
    26d8:	93 87       	std	Z+11, r25	; 0x0b
    26da:	26 96       	adiw	r28, 0x06	; 6
    26dc:	0f b6       	in	r0, 0x3f	; 63
    26de:	f8 94       	cli
    26e0:	de bf       	out	0x3e, r29	; 62
    26e2:	0f be       	out	0x3f, r0	; 63
    26e4:	cd bf       	out	0x3d, r28	; 61
    26e6:	df 91       	pop	r29
    26e8:	cf 91       	pop	r28
    26ea:	1f 91       	pop	r17
    26ec:	0f 91       	pop	r16
    26ee:	ff 90       	pop	r15
    26f0:	ef 90       	pop	r14
    26f2:	df 90       	pop	r13
    26f4:	cf 90       	pop	r12
    26f6:	08 95       	ret

000026f8 <buzzer_start>:
 */ 

#include <avr/io.h>

void buzzer_start() {
	DDRL |= (1<<PL5);
    26f8:	ea e0       	ldi	r30, 0x0A	; 10
    26fa:	f1 e0       	ldi	r31, 0x01	; 1
    26fc:	80 81       	ld	r24, Z
    26fe:	80 62       	ori	r24, 0x20	; 32
    2700:	80 83       	st	Z, r24
	PORTL |= (1<<PL5);
    2702:	eb e0       	ldi	r30, 0x0B	; 11
    2704:	f1 e0       	ldi	r31, 0x01	; 1
    2706:	80 81       	ld	r24, Z
    2708:	80 62       	ori	r24, 0x20	; 32
    270a:	80 83       	st	Z, r24
    270c:	08 95       	ret

0000270e <buzzer_stop>:
}

void buzzer_stop() {
	DDRL &= ~(1<<PL5);
    270e:	ea e0       	ldi	r30, 0x0A	; 10
    2710:	f1 e0       	ldi	r31, 0x01	; 1
    2712:	80 81       	ld	r24, Z
    2714:	8f 7d       	andi	r24, 0xDF	; 223
    2716:	80 83       	st	Z, r24
	PORTL &= ~(1<<PL5);
    2718:	eb e0       	ldi	r30, 0x0B	; 11
    271a:	f1 e0       	ldi	r31, 0x01	; 1
    271c:	80 81       	ld	r24, Z
    271e:	8f 7d       	andi	r24, 0xDF	; 223
    2720:	80 83       	st	Z, r24
    2722:	08 95       	ret

00002724 <i2c_init>:
 */ 

#include <avr/io.h>

void i2c_init() {
	TWBR = 12; // 400kHz from 16MHz clock
    2724:	8c e0       	ldi	r24, 0x0C	; 12
    2726:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7c00b8>
	TWCR = (1 << TWEN);
    272a:	84 e0       	ldi	r24, 0x04	; 4
    272c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    2730:	08 95       	ret

00002732 <i2c_send_start>:
}

void i2c_send_start() {
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1 << TWEN);
    2732:	84 ea       	ldi	r24, 0xA4	; 164
    2734:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
	
	// wait for TWINT flag to be set
	while (!(TWCR & (1<<TWINT)));
    2738:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    273c:	88 23       	and	r24, r24
    273e:	e4 f7       	brge	.-8      	; 0x2738 <i2c_send_start+0x6>
	
	//uint8_t a = (TWSR & 0xF8);
	//char output[20];
	//sprintf(output, "START: %x\r\n", a);
	//print(output);
}
    2740:	08 95       	ret

00002742 <i2c_send_stop>:

void i2c_send_stop() {
	TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    2742:	84 e9       	ldi	r24, 0x94	; 148
    2744:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    2748:	08 95       	ret

0000274a <i2c_enter_MT_mode>:
}

void i2c_enter_MT_mode(uint8_t addr) {
	TWDR = (addr << 1);
    274a:	88 0f       	add	r24, r24
    274c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
	TWCR = (1<<TWINT) | (1<<TWEN);
    2750:	84 e8       	ldi	r24, 0x84	; 132
    2752:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
	
	// wait for TWINT flag to be set
	while (!(TWCR & (1<<TWINT)));
    2756:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    275a:	88 23       	and	r24, r24
    275c:	e4 f7       	brge	.-8      	; 0x2756 <i2c_enter_MT_mode+0xc>
	
	//uint8_t a = (TWSR & 0xF8);
	//char output[40];
	//sprintf(output, "Enter MT Mode: %x\r\n", a);
	//print(output);
}
    275e:	08 95       	ret

00002760 <i2c_enter_MR_mode>:

void i2c_enter_MR_mode(uint8_t addr) {
	TWDR = (addr << 1) | 0x01;
    2760:	90 e0       	ldi	r25, 0x00	; 0
    2762:	88 0f       	add	r24, r24
    2764:	99 1f       	adc	r25, r25
    2766:	81 60       	ori	r24, 0x01	; 1
    2768:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
	TWCR = (1<<TWINT) | (1<<TWEN);
    276c:	84 e8       	ldi	r24, 0x84	; 132
    276e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
	
	// wait for TWINT flag to be set
	while (!(TWCR & (1<<TWINT)));
    2772:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    2776:	88 23       	and	r24, r24
    2778:	e4 f7       	brge	.-8      	; 0x2772 <i2c_enter_MR_mode+0x12>
	
	//uint8_t a = (TWSR & 0xF8);
	//char output[40];
	//sprintf(output, "Enter MR mode: %x\r\n", a);
	//print(output);
}
    277a:	08 95       	ret

0000277c <i2c_send>:

void i2c_send(uint8_t data) {
	TWDR = data;
    277c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
	TWCR = (1<<TWINT) | (1<<TWEN);
    2780:	84 e8       	ldi	r24, 0x84	; 132
    2782:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
	
	// wait for TWINT flag to be set
	while (!(TWCR & (1<<TWINT)));
    2786:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    278a:	88 23       	and	r24, r24
    278c:	e4 f7       	brge	.-8      	; 0x2786 <i2c_send+0xa>
}
    278e:	08 95       	ret

00002790 <i2c_read_nack>:

void i2c_read_nack(uint8_t *buffer) {
    2790:	fc 01       	movw	r30, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
    2792:	84 e8       	ldi	r24, 0x84	; 132
    2794:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
	
	// wait for TWINT flag to be set
	while (!(TWCR & (1<<TWINT)));
    2798:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    279c:	99 23       	and	r25, r25
    279e:	e4 f7       	brge	.-8      	; 0x2798 <i2c_read_nack+0x8>
	
	*buffer = TWDR;
    27a0:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
    27a4:	80 83       	st	Z, r24
    27a6:	08 95       	ret

000027a8 <i2c_read_ack>:
}

void i2c_read_ack(uint8_t *buffer) {
    27a8:	fc 01       	movw	r30, r24
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    27aa:	84 ec       	ldi	r24, 0xC4	; 196
    27ac:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
	
	// wait for TWINT flag to be set
	while (!(TWCR & (1<<TWINT)));
    27b0:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    27b4:	99 23       	and	r25, r25
    27b6:	e4 f7       	brge	.-8      	; 0x27b0 <i2c_read_ack+0x8>
	
	*buffer = TWDR;
    27b8:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
    27bc:	80 83       	st	Z, r24
    27be:	08 95       	ret

000027c0 <move_servo>:
 */

#include <avr/io.h>

void move_servo() {
	DDRL |= (1<<PL4);
    27c0:	ea e0       	ldi	r30, 0x0A	; 10
    27c2:	f1 e0       	ldi	r31, 0x01	; 1
    27c4:	80 81       	ld	r24, Z
    27c6:	80 61       	ori	r24, 0x10	; 16
    27c8:	80 83       	st	Z, r24
	
	// refer to notes for details, PIN 45
	TCCR5A = 0b00100010;
    27ca:	82 e2       	ldi	r24, 0x22	; 34
    27cc:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x7c0120>
	TCCR5B = 0b00011011;
    27d0:	8b e1       	ldi	r24, 0x1B	; 27
    27d2:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x7c0121>
	ICR5 = 4999;
    27d6:	87 e8       	ldi	r24, 0x87	; 135
    27d8:	93 e1       	ldi	r25, 0x13	; 19
    27da:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x7c0127>
    27de:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x7c0126>
	OCR5B = 275; // 2ms, to the right
    27e2:	83 e1       	ldi	r24, 0x13	; 19
    27e4:	91 e0       	ldi	r25, 0x01	; 1
    27e6:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <__TEXT_REGION_LENGTH__+0x7c012b>
    27ea:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__TEXT_REGION_LENGTH__+0x7c012a>
    27ee:	08 95       	ret

000027f0 <reset_servo>:
}

// clamped position
void reset_servo() {
	DDRL |= (1<<PL4);
    27f0:	ea e0       	ldi	r30, 0x0A	; 10
    27f2:	f1 e0       	ldi	r31, 0x01	; 1
    27f4:	80 81       	ld	r24, Z
    27f6:	80 61       	ori	r24, 0x10	; 16
    27f8:	80 83       	st	Z, r24
	
	// refer to notes for details, PIN 45
	TCCR5A = 0b00100010;
    27fa:	82 e2       	ldi	r24, 0x22	; 34
    27fc:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x7c0120>
	TCCR5B = 0b00011011;
    2800:	8b e1       	ldi	r24, 0x1B	; 27
    2802:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x7c0121>
	ICR5 = 4999;
    2806:	87 e8       	ldi	r24, 0x87	; 135
    2808:	93 e1       	ldi	r25, 0x13	; 19
    280a:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x7c0127>
    280e:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x7c0126>
	OCR5B = 475; // 2ms, to the right
    2812:	8b ed       	ldi	r24, 0xDB	; 219
    2814:	91 e0       	ldi	r25, 0x01	; 1
    2816:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <__TEXT_REGION_LENGTH__+0x7c012b>
    281a:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__TEXT_REGION_LENGTH__+0x7c012a>
    281e:	08 95       	ret

00002820 <stop_servo>:
}

void stop_servo() {
	DDRL &= ~(1<<PL4);
    2820:	ea e0       	ldi	r30, 0x0A	; 10
    2822:	f1 e0       	ldi	r31, 0x01	; 1
    2824:	80 81       	ld	r24, Z
    2826:	8f 7e       	andi	r24, 0xEF	; 239
    2828:	80 83       	st	Z, r24
    282a:	08 95       	ret

0000282c <SPI_init>:
 */ 

#include "spi.h"

void SPI_init(void) {
	DDR_SPI = (1<<SCK) | (1<<MOSI) | (1<<SS); // set relevant pins to output, set SS to output to enter master mode
    282c:	87 e0       	ldi	r24, 0x07	; 7
    282e:	84 b9       	out	0x04, r24	; 4
	DDR_SS = (1<<SS_W25Qxx) | (1<<SS_BMP390);
    2830:	88 e1       	ldi	r24, 0x18	; 24
    2832:	81 b9       	out	0x01, r24	; 1
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0); // enable spi, set as master, use mode 0, set sck = f/16
    2834:	81 e5       	ldi	r24, 0x51	; 81
    2836:	8c bd       	out	0x2c, r24	; 44
	PORT_SS |= (1<<SS_W25Qxx) | (1<<SS_BMP390); // add when more slaves added
    2838:	82 b1       	in	r24, 0x02	; 2
    283a:	88 61       	ori	r24, 0x18	; 24
    283c:	82 b9       	out	0x02, r24	; 2
    283e:	08 95       	ret

00002840 <SPI_select>:
}

void SPI_select(uint8_t addr) {
	PORT_SS &= ~(1<<addr);
    2840:	92 b1       	in	r25, 0x02	; 2
    2842:	21 e0       	ldi	r18, 0x01	; 1
    2844:	30 e0       	ldi	r19, 0x00	; 0
    2846:	02 c0       	rjmp	.+4      	; 0x284c <SPI_select+0xc>
    2848:	22 0f       	add	r18, r18
    284a:	33 1f       	adc	r19, r19
    284c:	8a 95       	dec	r24
    284e:	e2 f7       	brpl	.-8      	; 0x2848 <SPI_select+0x8>
    2850:	20 95       	com	r18
    2852:	29 23       	and	r18, r25
    2854:	22 b9       	out	0x02, r18	; 2
    2856:	08 95       	ret

00002858 <SPI_deselect>:
}

void SPI_deselect(uint8_t addr) {
	PORT_SS |= (1<<addr);
    2858:	92 b1       	in	r25, 0x02	; 2
    285a:	21 e0       	ldi	r18, 0x01	; 1
    285c:	30 e0       	ldi	r19, 0x00	; 0
    285e:	02 c0       	rjmp	.+4      	; 0x2864 <SPI_deselect+0xc>
    2860:	22 0f       	add	r18, r18
    2862:	33 1f       	adc	r19, r19
    2864:	8a 95       	dec	r24
    2866:	e2 f7       	brpl	.-8      	; 0x2860 <SPI_deselect+0x8>
    2868:	29 2b       	or	r18, r25
    286a:	22 b9       	out	0x02, r18	; 2
    286c:	08 95       	ret

0000286e <SPI_transaction>:
}

uint8_t SPI_transaction(uint8_t data) {
	SPDR = data;
    286e:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1<<SPIF))); // wait until SPIF is 1
    2870:	0d b4       	in	r0, 0x2d	; 45
    2872:	07 fe       	sbrs	r0, 7
    2874:	fd cf       	rjmp	.-6      	; 0x2870 <SPI_transaction+0x2>
	return SPDR;
    2876:	8e b5       	in	r24, 0x2e	; 46
    2878:	08 95       	ret

0000287a <ascent_handler>:
	release_handler,
	landing_handler,
	sim_handler,
	calibration_handler};

void ascent_handler() {
    287a:	0f 93       	push	r16
	xSemaphoreTake(stateMutex, portMAX_DELAY);
    287c:	00 e0       	ldi	r16, 0x00	; 0
    287e:	2f ef       	ldi	r18, 0xFF	; 255
    2880:	3f ef       	ldi	r19, 0xFF	; 255
    2882:	a9 01       	movw	r20, r18
    2884:	60 e0       	ldi	r22, 0x00	; 0
    2886:	70 e0       	ldi	r23, 0x00	; 0
    2888:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    288c:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2890:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
	if (universal_telemetry.stage == LAUNCH_PAD) {
    2894:	80 91 b0 1d 	lds	r24, 0x1DB0	; 0x801db0 <universal_telemetry+0x2>
    2898:	81 11       	cpse	r24, r1
    289a:	06 c0       	rjmp	.+12     	; 0x28a8 <ascent_handler+0x2e>
		universal_telemetry.stage = ASCENT;
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	80 93 b0 1d 	sts	0x1DB0, r24	; 0x801db0 <universal_telemetry+0x2>
		print("Ascending...\r\n");
    28a2:	83 e6       	ldi	r24, 0x63	; 99
    28a4:	93 e0       	ldi	r25, 0x03	; 3
    28a6:	f1 d5       	rcall	.+3042   	; 0x348a <print>
	}
	xSemaphoreGive(stateMutex);
    28a8:	00 e0       	ldi	r16, 0x00	; 0
    28aa:	20 e0       	ldi	r18, 0x00	; 0
    28ac:	30 e0       	ldi	r19, 0x00	; 0
    28ae:	a9 01       	movw	r20, r18
    28b0:	60 e0       	ldi	r22, 0x00	; 0
    28b2:	70 e0       	ldi	r23, 0x00	; 0
    28b4:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    28b8:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    28bc:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
}
    28c0:	0f 91       	pop	r16
    28c2:	08 95       	ret

000028c4 <descent_hander>:

void descent_hander() {
    28c4:	0f 93       	push	r16
    28c6:	cf 93       	push	r28
    28c8:	df 93       	push	r29
	xSemaphoreTake(stateMutex, portMAX_DELAY);
    28ca:	00 e0       	ldi	r16, 0x00	; 0
    28cc:	2f ef       	ldi	r18, 0xFF	; 255
    28ce:	3f ef       	ldi	r19, 0xFF	; 255
    28d0:	a9 01       	movw	r20, r18
    28d2:	60 e0       	ldi	r22, 0x00	; 0
    28d4:	70 e0       	ldi	r23, 0x00	; 0
    28d6:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    28da:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    28de:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
	if (universal_telemetry.stage == ASCENT) {
    28e2:	80 91 b0 1d 	lds	r24, 0x1DB0	; 0x801db0 <universal_telemetry+0x2>
    28e6:	81 30       	cpi	r24, 0x01	; 1
    28e8:	c9 f4       	brne	.+50     	; 0x291c <descent_hander+0x58>
		universal_telemetry.stage = DESCENT;
    28ea:	ce ea       	ldi	r28, 0xAE	; 174
    28ec:	dd e1       	ldi	r29, 0x1D	; 29
    28ee:	82 e0       	ldi	r24, 0x02	; 2
    28f0:	8a 83       	std	Y+2, r24	; 0x02
		print("Descending...\r\n");
    28f2:	82 e7       	ldi	r24, 0x72	; 114
    28f4:	93 e0       	ldi	r25, 0x03	; 3
    28f6:	c9 d5       	rcall	.+2962   	; 0x348a <print>
		// set deploy height to ~75% height reached
		deploy_height = 0.75 * universal_telemetry.altitude;
    28f8:	6b 81       	ldd	r22, Y+3	; 0x03
    28fa:	7c 81       	ldd	r23, Y+4	; 0x04
    28fc:	8d 81       	ldd	r24, Y+5	; 0x05
    28fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2900:	20 e0       	ldi	r18, 0x00	; 0
    2902:	30 e0       	ldi	r19, 0x00	; 0
    2904:	40 e4       	ldi	r20, 0x40	; 64
    2906:	5f e3       	ldi	r21, 0x3F	; 63
    2908:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    290c:	60 93 d3 1c 	sts	0x1CD3, r22	; 0x801cd3 <deploy_height>
    2910:	70 93 d4 1c 	sts	0x1CD4, r23	; 0x801cd4 <deploy_height+0x1>
    2914:	80 93 d5 1c 	sts	0x1CD5, r24	; 0x801cd5 <deploy_height+0x2>
    2918:	90 93 d6 1c 	sts	0x1CD6, r25	; 0x801cd6 <deploy_height+0x3>
		// print("deploy_height established!\r\n");
	}
	xSemaphoreGive(stateMutex);
    291c:	00 e0       	ldi	r16, 0x00	; 0
    291e:	20 e0       	ldi	r18, 0x00	; 0
    2920:	30 e0       	ldi	r19, 0x00	; 0
    2922:	a9 01       	movw	r20, r18
    2924:	60 e0       	ldi	r22, 0x00	; 0
    2926:	70 e0       	ldi	r23, 0x00	; 0
    2928:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    292c:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2930:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
}
    2934:	df 91       	pop	r29
    2936:	cf 91       	pop	r28
    2938:	0f 91       	pop	r16
    293a:	08 95       	ret

0000293c <landing_handler>:
		stop_servo();
	}
	xSemaphoreGive(stateMutex);;
}

void landing_handler() {
    293c:	0f 93       	push	r16
	xSemaphoreTake(stateMutex, portMAX_DELAY);
    293e:	00 e0       	ldi	r16, 0x00	; 0
    2940:	2f ef       	ldi	r18, 0xFF	; 255
    2942:	3f ef       	ldi	r19, 0xFF	; 255
    2944:	a9 01       	movw	r20, r18
    2946:	60 e0       	ldi	r22, 0x00	; 0
    2948:	70 e0       	ldi	r23, 0x00	; 0
    294a:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    294e:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2952:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
	if (universal_telemetry.stage == PROBE_RELEASE) {
    2956:	80 91 b0 1d 	lds	r24, 0x1DB0	; 0x801db0 <universal_telemetry+0x2>
    295a:	83 30       	cpi	r24, 0x03	; 3
    295c:	81 f4       	brne	.+32     	; 0x297e <landing_handler+0x42>
		universal_telemetry.stage = LANDED;
    295e:	84 e0       	ldi	r24, 0x04	; 4
    2960:	80 93 b0 1d 	sts	0x1DB0, r24	; 0x801db0 <universal_telemetry+0x2>
		print("Landed.\r\n");
    2964:	82 e8       	ldi	r24, 0x82	; 130
    2966:	93 e0       	ldi	r25, 0x03	; 3
    2968:	90 d5       	rcall	.+2848   	; 0x348a <print>
		DDRL |= (1<<PL5);
    296a:	ea e0       	ldi	r30, 0x0A	; 10
    296c:	f1 e0       	ldi	r31, 0x01	; 1
    296e:	80 81       	ld	r24, Z
    2970:	80 62       	ori	r24, 0x20	; 32
    2972:	80 83       	st	Z, r24
		PORTL |= (1<<PL5);
    2974:	eb e0       	ldi	r30, 0x0B	; 11
    2976:	f1 e0       	ldi	r31, 0x01	; 1
    2978:	80 81       	ld	r24, Z
    297a:	80 62       	ori	r24, 0x20	; 32
    297c:	80 83       	st	Z, r24
	}
	xSemaphoreGive(stateMutex);;
    297e:	00 e0       	ldi	r16, 0x00	; 0
    2980:	20 e0       	ldi	r18, 0x00	; 0
    2982:	30 e0       	ldi	r19, 0x00	; 0
    2984:	a9 01       	movw	r20, r18
    2986:	60 e0       	ldi	r22, 0x00	; 0
    2988:	70 e0       	ldi	r23, 0x00	; 0
    298a:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    298e:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2992:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
}
    2996:	0f 91       	pop	r16
    2998:	08 95       	ret

0000299a <sim_handler>:

void sim_handler() {
    299a:	0f 93       	push	r16
	print("Entering Simulation Mode...\r\n");
    299c:	8c e8       	ldi	r24, 0x8C	; 140
    299e:	93 e0       	ldi	r25, 0x03	; 3
    29a0:	74 d5       	rcall	.+2792   	; 0x348a <print>
	xSemaphoreTake(stateMutex, portMAX_DELAY);
    29a2:	00 e0       	ldi	r16, 0x00	; 0
    29a4:	2f ef       	ldi	r18, 0xFF	; 255
    29a6:	3f ef       	ldi	r19, 0xFF	; 255
    29a8:	a9 01       	movw	r20, r18
    29aa:	60 e0       	ldi	r22, 0x00	; 0
    29ac:	70 e0       	ldi	r23, 0x00	; 0
    29ae:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    29b2:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    29b6:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
	if (universal_telemetry.mode != MODE_SIMULATION) {
    29ba:	80 91 af 1d 	lds	r24, 0x1DAF	; 0x801daf <universal_telemetry+0x1>
    29be:	81 11       	cpse	r24, r1
		universal_telemetry.mode = MODE_SIMULATION;
    29c0:	10 92 af 1d 	sts	0x1DAF, r1	; 0x801daf <universal_telemetry+0x1>
		// extern void simulated_data_reading (void *pvParameters);
		// xTaskCreate(simulated_data_reading, "Task to simulate reading data from W25Q32, will include other sensors", 100, NULL, 2, NULL);
	}
	xSemaphoreGive(stateMutex);
    29c4:	00 e0       	ldi	r16, 0x00	; 0
    29c6:	20 e0       	ldi	r18, 0x00	; 0
    29c8:	30 e0       	ldi	r19, 0x00	; 0
    29ca:	a9 01       	movw	r20, r18
    29cc:	60 e0       	ldi	r22, 0x00	; 0
    29ce:	70 e0       	ldi	r23, 0x00	; 0
    29d0:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    29d4:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    29d8:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
}
    29dc:	0f 91       	pop	r16
    29de:	08 95       	ret

000029e0 <release_handler>:
		// print("deploy_height established!\r\n");
	}
	xSemaphoreGive(stateMutex);
}

void release_handler() {
    29e0:	0f 93       	push	r16
	xSemaphoreTake(stateMutex, portMAX_DELAY);
    29e2:	00 e0       	ldi	r16, 0x00	; 0
    29e4:	2f ef       	ldi	r18, 0xFF	; 255
    29e6:	3f ef       	ldi	r19, 0xFF	; 255
    29e8:	a9 01       	movw	r20, r18
    29ea:	60 e0       	ldi	r22, 0x00	; 0
    29ec:	70 e0       	ldi	r23, 0x00	; 0
    29ee:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    29f2:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    29f6:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
	if (universal_telemetry.stage == DESCENT) {
    29fa:	80 91 b0 1d 	lds	r24, 0x1DB0	; 0x801db0 <universal_telemetry+0x2>
    29fe:	82 30       	cpi	r24, 0x02	; 2
    2a00:	89 f4       	brne	.+34     	; 0x2a24 <release_handler+0x44>
		universal_telemetry.stage = PROBE_RELEASE;
    2a02:	83 e0       	ldi	r24, 0x03	; 3
    2a04:	80 93 b0 1d 	sts	0x1DB0, r24	; 0x801db0 <universal_telemetry+0x2>
		print("Releasing Probe\r\n");
    2a08:	8a ea       	ldi	r24, 0xAA	; 170
    2a0a:	93 e0       	ldi	r25, 0x03	; 3
    2a0c:	3e d5       	rcall	.+2684   	; 0x348a <print>
		move_servo();
    2a0e:	d8 de       	rcall	.-592    	; 0x27c0 <move_servo>
    2a10:	2f e3       	ldi	r18, 0x3F	; 63
    2a12:	8d e0       	ldi	r24, 0x0D	; 13
    2a14:	93 e0       	ldi	r25, 0x03	; 3
    2a16:	21 50       	subi	r18, 0x01	; 1
    2a18:	80 40       	sbci	r24, 0x00	; 0
    2a1a:	90 40       	sbci	r25, 0x00	; 0
    2a1c:	e1 f7       	brne	.-8      	; 0x2a16 <release_handler+0x36>
    2a1e:	00 c0       	rjmp	.+0      	; 0x2a20 <release_handler+0x40>
    2a20:	00 00       	nop
		_delay_ms(1000);
		stop_servo();
    2a22:	fe de       	rcall	.-516    	; 0x2820 <stop_servo>
    2a24:	00 e0       	ldi	r16, 0x00	; 0
	}
	xSemaphoreGive(stateMutex);;
    2a26:	20 e0       	ldi	r18, 0x00	; 0
    2a28:	30 e0       	ldi	r19, 0x00	; 0
    2a2a:	a9 01       	movw	r20, r18
    2a2c:	60 e0       	ldi	r22, 0x00	; 0
    2a2e:	70 e0       	ldi	r23, 0x00	; 0
    2a30:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    2a34:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2a38:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
    2a3c:	0f 91       	pop	r16
}
    2a3e:	08 95       	ret

00002a40 <calibration_handler>:
    2a40:	cf 93       	push	r28
		// xTaskCreate(simulated_data_reading, "Task to simulate reading data from W25Q32, will include other sensors", 100, NULL, 2, NULL);
	}
	xSemaphoreGive(stateMutex);
}

void calibration_handler() {
    2a42:	df 93       	push	r29
    2a44:	cd b7       	in	r28, 0x3d	; 61
    2a46:	de b7       	in	r29, 0x3e	; 62
    2a48:	28 97       	sbiw	r28, 0x08	; 8
    2a4a:	0f b6       	in	r0, 0x3f	; 63
    2a4c:	f8 94       	cli
    2a4e:	de bf       	out	0x3e, r29	; 62
    2a50:	0f be       	out	0x3f, r0	; 63
    2a52:	cd bf       	out	0x3d, r28	; 61
	print("Calibrating Altitude...\r\n");
    2a54:	8c eb       	ldi	r24, 0xBC	; 188
    2a56:	93 e0       	ldi	r25, 0x03	; 3
    2a58:	18 d5       	rcall	.+2608   	; 0x348a <print>
	float pressure, temperature;
	BMP390_get_readings(&pressure, &temperature);
    2a5a:	be 01       	movw	r22, r28
    2a5c:	6b 5f       	subi	r22, 0xFB	; 251
    2a5e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a60:	ce 01       	movw	r24, r28
    2a62:	01 96       	adiw	r24, 0x01	; 1
    2a64:	18 db       	rcall	.-2512   	; 0x2096 <BMP390_get_readings>
	old_altitude = 0;
    2a66:	10 92 e7 1d 	sts	0x1DE7, r1	; 0x801de7 <old_altitude>
    2a6a:	10 92 e8 1d 	sts	0x1DE8, r1	; 0x801de8 <old_altitude+0x1>
    2a6e:	10 92 e9 1d 	sts	0x1DE9, r1	; 0x801de9 <old_altitude+0x2>
    2a72:	10 92 ea 1d 	sts	0x1DEA, r1	; 0x801dea <old_altitude+0x3>
	calibrated_altitude = 44330.0f * (1.0f-powf(pressure/CURRENT_PRESSURE, 0.1903f));
    2a76:	69 81       	ldd	r22, Y+1	; 0x01
    2a78:	7a 81       	ldd	r23, Y+2	; 0x02
    2a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7e:	20 e0       	ldi	r18, 0x00	; 0
    2a80:	32 e1       	ldi	r19, 0x12	; 18
    2a82:	45 ec       	ldi	r20, 0xC5	; 197
    2a84:	57 e4       	ldi	r21, 0x47	; 71
    2a86:	2f d7       	rcall	.+3678   	; 0x38e6 <__divsf3>
    2a88:	21 e0       	ldi	r18, 0x01	; 1
    2a8a:	3e ed       	ldi	r19, 0xDE	; 222
    2a8c:	42 e4       	ldi	r20, 0x42	; 66
    2a8e:	5e e3       	ldi	r21, 0x3E	; 62
    2a90:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <pow>
    2a94:	9b 01       	movw	r18, r22
    2a96:	ac 01       	movw	r20, r24
    2a98:	60 e0       	ldi	r22, 0x00	; 0
    2a9a:	70 e0       	ldi	r23, 0x00	; 0
    2a9c:	80 e8       	ldi	r24, 0x80	; 128
    2a9e:	9f e3       	ldi	r25, 0x3F	; 63
    2aa0:	b9 d6       	rcall	.+3442   	; 0x3814 <__subsf3>
    2aa2:	20 e0       	ldi	r18, 0x00	; 0
    2aa4:	3a e2       	ldi	r19, 0x2A	; 42
    2aa6:	4d e2       	ldi	r20, 0x2D	; 45
    2aa8:	57 e4       	ldi	r21, 0x47	; 71
    2aaa:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <__mulsf3>
    2aae:	60 93 d7 1c 	sts	0x1CD7, r22	; 0x801cd7 <calibrated_altitude>
    2ab2:	70 93 d8 1c 	sts	0x1CD8, r23	; 0x801cd8 <calibrated_altitude+0x1>
    2ab6:	80 93 d9 1c 	sts	0x1CD9, r24	; 0x801cd9 <calibrated_altitude+0x2>
    2aba:	90 93 da 1c 	sts	0x1CDA, r25	; 0x801cda <calibrated_altitude+0x3>
}
    2abe:	28 96       	adiw	r28, 0x08	; 8
    2ac0:	0f b6       	in	r0, 0x3f	; 63
    2ac2:	f8 94       	cli
    2ac4:	de bf       	out	0x3e, r29	; 62
    2ac6:	0f be       	out	0x3f, r0	; 63
    2ac8:	cd bf       	out	0x3d, r28	; 61
    2aca:	df 91       	pop	r29
    2acc:	cf 91       	pop	r28
    2ace:	08 95       	ret

00002ad0 <state_manager>:

void state_manager(void *pvParameters) {
    2ad0:	cf 93       	push	r28
    2ad2:	df 93       	push	r29
    2ad4:	1f 92       	push	r1
    2ad6:	cd b7       	in	r28, 0x3d	; 61
    2ad8:	de b7       	in	r29, 0x3e	; 62
	universal_telemetry.mode = MODE_FLIGHT; // default: MODE_FLIGHT
    2ada:	ee ea       	ldi	r30, 0xAE	; 174
    2adc:	fd e1       	ldi	r31, 0x1D	; 29
    2ade:	81 e0       	ldi	r24, 0x01	; 1
    2ae0:	81 83       	std	Z+1, r24	; 0x01
	universal_telemetry.stage = LAUNCH_PAD;		// cansat starts off on ground
    2ae2:	12 82       	std	Z+2, r1	; 0x02

	CanSatEvents_t current_event;

	while (1) {
		if (xQueueReceive(events_queue, &current_event, portMAX_DELAY) == pdTRUE) {
    2ae4:	00 e0       	ldi	r16, 0x00	; 0
    2ae6:	2f ef       	ldi	r18, 0xFF	; 255
    2ae8:	3f ef       	ldi	r19, 0xFF	; 255
    2aea:	a9 01       	movw	r20, r18
    2aec:	be 01       	movw	r22, r28
    2aee:	6f 5f       	subi	r22, 0xFF	; 255
    2af0:	7f 4f       	sbci	r23, 0xFF	; 255
    2af2:	80 91 e5 1d 	lds	r24, 0x1DE5	; 0x801de5 <events_queue>
    2af6:	90 91 e6 1d 	lds	r25, 0x1DE6	; 0x801de6 <events_queue+0x1>
    2afa:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
    2afe:	81 30       	cpi	r24, 0x01	; 1
    2b00:	89 f7       	brne	.-30     	; 0x2ae4 <state_manager+0x14>
			functionTable[current_event]();
    2b02:	e9 81       	ldd	r30, Y+1	; 0x01
    2b04:	f0 e0       	ldi	r31, 0x00	; 0
    2b06:	ee 0f       	add	r30, r30
    2b08:	ff 1f       	adc	r31, r31
    2b0a:	e0 50       	subi	r30, 0x00	; 0
    2b0c:	fe 4f       	sbci	r31, 0xFE	; 254
    2b0e:	01 90       	ld	r0, Z+
    2b10:	f0 81       	ld	r31, Z
    2b12:	e0 2d       	mov	r30, r0
    2b14:	19 95       	eicall
    2b16:	e6 cf       	rjmp	.-52     	; 0x2ae4 <state_manager+0x14>

00002b18 <is_falling>:
	DDRB |= (1<<PB7); // built in LED
	PORTB |= (1<<PB7);
	
	while (1) {
		PORTB ^= (1<<PB7);
		vTaskDelay(pdMS_TO_TICKS(1000));
    2b18:	cf 93       	push	r28
    2b1a:	9b 01       	movw	r18, r22
    2b1c:	ac 01       	movw	r20, r24
    2b1e:	60 91 e7 1d 	lds	r22, 0x1DE7	; 0x801de7 <old_altitude>
    2b22:	70 91 e8 1d 	lds	r23, 0x1DE8	; 0x801de8 <old_altitude+0x1>
    2b26:	80 91 e9 1d 	lds	r24, 0x1DE9	; 0x801de9 <old_altitude+0x2>
    2b2a:	90 91 ea 1d 	lds	r25, 0x1DEA	; 0x801dea <old_altitude+0x3>
    2b2e:	72 d6       	rcall	.+3300   	; 0x3814 <__subsf3>
    2b30:	c1 e0       	ldi	r28, 0x01	; 1
    2b32:	20 e0       	ldi	r18, 0x00	; 0
    2b34:	30 e0       	ldi	r19, 0x00	; 0
    2b36:	40 ea       	ldi	r20, 0xA0	; 160
    2b38:	50 e4       	ldi	r21, 0x40	; 64
    2b3a:	ef d7       	rcall	.+4062   	; 0x3b1a <__gesf2>
    2b3c:	18 16       	cp	r1, r24
    2b3e:	0c f0       	brlt	.+2      	; 0x2b42 <is_falling+0x2a>
    2b40:	c0 e0       	ldi	r28, 0x00	; 0
    2b42:	8c 2f       	mov	r24, r28
    2b44:	cf 91       	pop	r28
    2b46:	08 95       	ret

00002b48 <is_stationary>:
    2b48:	cf 93       	push	r28
    2b4a:	9b 01       	movw	r18, r22
    2b4c:	ac 01       	movw	r20, r24
    2b4e:	60 91 e7 1d 	lds	r22, 0x1DE7	; 0x801de7 <old_altitude>
    2b52:	70 91 e8 1d 	lds	r23, 0x1DE8	; 0x801de8 <old_altitude+0x1>
    2b56:	80 91 e9 1d 	lds	r24, 0x1DE9	; 0x801de9 <old_altitude+0x2>
    2b5a:	90 91 ea 1d 	lds	r25, 0x1DEA	; 0x801dea <old_altitude+0x3>
    2b5e:	5a d6       	rcall	.+3252   	; 0x3814 <__subsf3>
    2b60:	9f 77       	andi	r25, 0x7F	; 127
    2b62:	c1 e0       	ldi	r28, 0x01	; 1
    2b64:	20 e0       	ldi	r18, 0x00	; 0
    2b66:	30 e0       	ldi	r19, 0x00	; 0
    2b68:	40 e0       	ldi	r20, 0x00	; 0
    2b6a:	5f e3       	ldi	r21, 0x3F	; 63
    2b6c:	b8 d6       	rcall	.+3440   	; 0x38de <__cmpsf2>
    2b6e:	88 23       	and	r24, r24
    2b70:	0c f0       	brlt	.+2      	; 0x2b74 <is_stationary+0x2c>
    2b72:	c0 e0       	ldi	r28, 0x00	; 0
    2b74:	8c 2f       	mov	r24, r28
    2b76:	cf 91       	pop	r28
    2b78:	08 95       	ret

00002b7a <data_reading>:
	}
}

void data_reading (void *pvParameters) {
    2b7a:	0f 93       	push	r16
    2b7c:	1f 93       	push	r17
    2b7e:	cf 93       	push	r28
    2b80:	df 93       	push	r29
    2b82:	cd b7       	in	r28, 0x3d	; 61
    2b84:	de b7       	in	r29, 0x3e	; 62
    2b86:	ad 97       	sbiw	r28, 0x2d	; 45
    2b88:	0f b6       	in	r0, 0x3f	; 63
    2b8a:	f8 94       	cli
    2b8c:	de bf       	out	0x3e, r29	; 62
    2b8e:	0f be       	out	0x3f, r0	; 63
    2b90:	cd bf       	out	0x3d, r28	; 61
	
	float acc[3];
	float mag[3];
	float gyr[3];
	
	old_altitude = 0.0f;
    2b92:	10 92 e7 1d 	sts	0x1DE7, r1	; 0x801de7 <old_altitude>
    2b96:	10 92 e8 1d 	sts	0x1DE8, r1	; 0x801de8 <old_altitude+0x1>
    2b9a:	10 92 e9 1d 	sts	0x1DE9, r1	; 0x801de9 <old_altitude+0x2>
    2b9e:	10 92 ea 1d 	sts	0x1DEA, r1	; 0x801dea <old_altitude+0x3>
	CanSatEvents_t event;
	while (1) {
		// read queue with pressure data
		xSemaphoreTake(stateMutex, portMAX_DELAY);
    2ba2:	00 e0       	ldi	r16, 0x00	; 0
    2ba4:	2f ef       	ldi	r18, 0xFF	; 255
    2ba6:	3f ef       	ldi	r19, 0xFF	; 255
    2ba8:	a9 01       	movw	r20, r18
    2baa:	60 e0       	ldi	r22, 0x00	; 0
    2bac:	70 e0       	ldi	r23, 0x00	; 0
    2bae:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    2bb2:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2bb6:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
    2bba:	87 ea       	ldi	r24, 0xA7	; 167
    2bbc:	91 e6       	ldi	r25, 0x61	; 97
    2bbe:	01 97       	sbiw	r24, 0x01	; 1
    2bc0:	f1 f7       	brne	.-4      	; 0x2bbe <data_reading+0x44>
    2bc2:	00 c0       	rjmp	.+0      	; 0x2bc4 <data_reading+0x4a>
    2bc4:	00 00       	nop
		
		_delay_ms(100); // must delay
		
		BMP390_get_readings(&pressure, &temperature);
    2bc6:	be 01       	movw	r22, r28
    2bc8:	6b 5f       	subi	r22, 0xFB	; 251
    2bca:	7f 4f       	sbci	r23, 0xFF	; 255
    2bcc:	ce 01       	movw	r24, r28
    2bce:	01 96       	adiw	r24, 0x01	; 1
    2bd0:	62 da       	rcall	.-2876   	; 0x2096 <BMP390_get_readings>
		if (universal_telemetry.mode == MODE_SIMULATION) {
    2bd2:	80 91 af 1d 	lds	r24, 0x1DAF	; 0x801daf <universal_telemetry+0x1>
    2bd6:	81 11       	cpse	r24, r1
    2bd8:	25 c0       	rjmp	.+74     	; 0x2c24 <data_reading+0xaa>
			xSemaphoreGive(stateMutex);
    2bda:	20 e0       	ldi	r18, 0x00	; 0
    2bdc:	30 e0       	ldi	r19, 0x00	; 0
    2bde:	a9 01       	movw	r20, r18
    2be0:	60 e0       	ldi	r22, 0x00	; 0
    2be2:	70 e0       	ldi	r23, 0x00	; 0
    2be4:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    2be8:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2bec:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
			if (xQueueReceive(simulated_pressure_queue, &pressure, portMAX_DELAY) != pdTRUE) {
    2bf0:	2f ef       	ldi	r18, 0xFF	; 255
    2bf2:	3f ef       	ldi	r19, 0xFF	; 255
    2bf4:	a9 01       	movw	r20, r18
    2bf6:	be 01       	movw	r22, r28
    2bf8:	6f 5f       	subi	r22, 0xFF	; 255
    2bfa:	7f 4f       	sbci	r23, 0xFF	; 255
    2bfc:	80 91 eb 1d 	lds	r24, 0x1DEB	; 0x801deb <simulated_pressure_queue>
    2c00:	90 91 ec 1d 	lds	r25, 0x1DEC	; 0x801dec <simulated_pressure_queue+0x1>
    2c04:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
    2c08:	81 30       	cpi	r24, 0x01	; 1
    2c0a:	09 f0       	breq	.+2      	; 0x2c0e <data_reading+0x94>
    2c0c:	09 c1       	rjmp	.+530    	; 0x2e20 <data_reading+0x2a6>
				return 0;
			}
			xSemaphoreTake(stateMutex, portMAX_DELAY);
    2c0e:	2f ef       	ldi	r18, 0xFF	; 255
    2c10:	3f ef       	ldi	r19, 0xFF	; 255
    2c12:	a9 01       	movw	r20, r18
    2c14:	60 e0       	ldi	r22, 0x00	; 0
    2c16:	70 e0       	ldi	r23, 0x00	; 0
    2c18:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    2c1c:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2c20:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
		}
			
		universal_telemetry.pressure = pressure;
    2c24:	69 81       	ldd	r22, Y+1	; 0x01
    2c26:	7a 81       	ldd	r23, Y+2	; 0x02
    2c28:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2c:	0e ea       	ldi	r16, 0xAE	; 174
    2c2e:	1d e1       	ldi	r17, 0x1D	; 29
    2c30:	f8 01       	movw	r30, r16
    2c32:	67 83       	std	Z+7, r22	; 0x07
    2c34:	70 87       	std	Z+8, r23	; 0x08
    2c36:	81 87       	std	Z+9, r24	; 0x09
    2c38:	92 87       	std	Z+10, r25	; 0x0a
		universal_telemetry.altitude = 44330.0f * (1.0f-powf(pressure/CURRENT_PRESSURE, 0.1903f));
    2c3a:	20 e0       	ldi	r18, 0x00	; 0
    2c3c:	32 e1       	ldi	r19, 0x12	; 18
    2c3e:	45 ec       	ldi	r20, 0xC5	; 197
    2c40:	57 e4       	ldi	r21, 0x47	; 71
    2c42:	51 d6       	rcall	.+3234   	; 0x38e6 <__divsf3>
    2c44:	21 e0       	ldi	r18, 0x01	; 1
    2c46:	3e ed       	ldi	r19, 0xDE	; 222
    2c48:	42 e4       	ldi	r20, 0x42	; 66
    2c4a:	5e e3       	ldi	r21, 0x3E	; 62
    2c4c:	cd d7       	rcall	.+3994   	; 0x3be8 <pow>
    2c4e:	9b 01       	movw	r18, r22
    2c50:	ac 01       	movw	r20, r24
    2c52:	60 e0       	ldi	r22, 0x00	; 0
    2c54:	70 e0       	ldi	r23, 0x00	; 0
    2c56:	80 e8       	ldi	r24, 0x80	; 128
    2c58:	9f e3       	ldi	r25, 0x3F	; 63
    2c5a:	dc d5       	rcall	.+3000   	; 0x3814 <__subsf3>
    2c5c:	20 e0       	ldi	r18, 0x00	; 0
    2c5e:	3a e2       	ldi	r19, 0x2A	; 42
    2c60:	4d e2       	ldi	r20, 0x2D	; 45
    2c62:	57 e4       	ldi	r21, 0x47	; 71
    2c64:	5e d7       	rcall	.+3772   	; 0x3b22 <__mulsf3>
		universal_telemetry.altitude -= calibrated_altitude;
    2c66:	20 91 d7 1c 	lds	r18, 0x1CD7	; 0x801cd7 <calibrated_altitude>
    2c6a:	30 91 d8 1c 	lds	r19, 0x1CD8	; 0x801cd8 <calibrated_altitude+0x1>
    2c6e:	40 91 d9 1c 	lds	r20, 0x1CD9	; 0x801cd9 <calibrated_altitude+0x2>
    2c72:	50 91 da 1c 	lds	r21, 0x1CDA	; 0x801cda <calibrated_altitude+0x3>
    2c76:	ce d5       	rcall	.+2972   	; 0x3814 <__subsf3>
    2c78:	f8 01       	movw	r30, r16
    2c7a:	63 83       	std	Z+3, r22	; 0x03
    2c7c:	74 83       	std	Z+4, r23	; 0x04
    2c7e:	85 83       	std	Z+5, r24	; 0x05
    2c80:	96 83       	std	Z+6, r25	; 0x06
		
		universal_telemetry.temperature = temperature;
    2c82:	8d 81       	ldd	r24, Y+5	; 0x05
    2c84:	9e 81       	ldd	r25, Y+6	; 0x06
    2c86:	af 81       	ldd	r26, Y+7	; 0x07
    2c88:	b8 85       	ldd	r27, Y+8	; 0x08
    2c8a:	83 87       	std	Z+11, r24	; 0x0b
    2c8c:	94 87       	std	Z+12, r25	; 0x0c
    2c8e:	a5 87       	std	Z+13, r26	; 0x0d
		
		BNO055_read_acc(acc);
    2c90:	b6 87       	std	Z+14, r27	; 0x0e
    2c92:	ce 01       	movw	r24, r28
    2c94:	09 96       	adiw	r24, 0x09	; 9
		BNO055_read_mag(mag);
    2c96:	f2 db       	rcall	.-2076   	; 0x247c <BNO055_read_acc>
    2c98:	ce 01       	movw	r24, r28
    2c9a:	45 96       	adiw	r24, 0x15	; 21
    2c9c:	59 dc       	rcall	.-1870   	; 0x2550 <BNO055_read_mag>
		BNO055_read_gyr(gyr);
    2c9e:	ce 01       	movw	r24, r28
    2ca0:	81 96       	adiw	r24, 0x21	; 33
    2ca2:	c0 dc       	rcall	.-1664   	; 0x2624 <BNO055_read_gyr>
    2ca4:	89 85       	ldd	r24, Y+9	; 0x09
		
		universal_telemetry.acc_x = acc[0];
    2ca6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ca8:	ab 85       	ldd	r26, Y+11	; 0x0b
    2caa:	bc 85       	ldd	r27, Y+12	; 0x0c
    2cac:	f8 01       	movw	r30, r16
    2cae:	87 87       	std	Z+15, r24	; 0x0f
    2cb0:	90 8b       	std	Z+16, r25	; 0x10
    2cb2:	a1 8b       	std	Z+17, r26	; 0x11
    2cb4:	b2 8b       	std	Z+18, r27	; 0x12
    2cb6:	8d 85       	ldd	r24, Y+13	; 0x0d
		universal_telemetry.acc_y = acc[1];
    2cb8:	9e 85       	ldd	r25, Y+14	; 0x0e
    2cba:	af 85       	ldd	r26, Y+15	; 0x0f
    2cbc:	b8 89       	ldd	r27, Y+16	; 0x10
    2cbe:	83 8b       	std	Z+19, r24	; 0x13
    2cc0:	94 8b       	std	Z+20, r25	; 0x14
    2cc2:	a5 8b       	std	Z+21, r26	; 0x15
    2cc4:	b6 8b       	std	Z+22, r27	; 0x16
    2cc6:	89 89       	ldd	r24, Y+17	; 0x11
		universal_telemetry.acc_z = acc[2];
    2cc8:	9a 89       	ldd	r25, Y+18	; 0x12
    2cca:	ab 89       	ldd	r26, Y+19	; 0x13
    2ccc:	bc 89       	ldd	r27, Y+20	; 0x14
    2cce:	87 8b       	std	Z+23, r24	; 0x17
    2cd0:	90 8f       	std	Z+24, r25	; 0x18
    2cd2:	a1 8f       	std	Z+25, r26	; 0x19
    2cd4:	b2 8f       	std	Z+26, r27	; 0x1a
    2cd6:	8d 89       	ldd	r24, Y+21	; 0x15
		
		universal_telemetry.mag_x = mag[0];
    2cd8:	9e 89       	ldd	r25, Y+22	; 0x16
    2cda:	af 89       	ldd	r26, Y+23	; 0x17
    2cdc:	b8 8d       	ldd	r27, Y+24	; 0x18
    2cde:	83 8f       	std	Z+27, r24	; 0x1b
    2ce0:	94 8f       	std	Z+28, r25	; 0x1c
    2ce2:	a5 8f       	std	Z+29, r26	; 0x1d
    2ce4:	b6 8f       	std	Z+30, r27	; 0x1e
    2ce6:	89 8d       	ldd	r24, Y+25	; 0x19
		universal_telemetry.mag_y = mag[1];
    2ce8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2cea:	ab 8d       	ldd	r26, Y+27	; 0x1b
    2cec:	bc 8d       	ldd	r27, Y+28	; 0x1c
    2cee:	87 8f       	std	Z+31, r24	; 0x1f
    2cf0:	90 a3       	std	Z+32, r25	; 0x20
    2cf2:	a1 a3       	std	Z+33, r26	; 0x21
    2cf4:	b2 a3       	std	Z+34, r27	; 0x22
    2cf6:	8d 8d       	ldd	r24, Y+29	; 0x1d
		universal_telemetry.mag_z = mag[2];
    2cf8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2cfa:	af 8d       	ldd	r26, Y+31	; 0x1f
    2cfc:	b8 a1       	ldd	r27, Y+32	; 0x20
    2cfe:	83 a3       	std	Z+35, r24	; 0x23
    2d00:	94 a3       	std	Z+36, r25	; 0x24
    2d02:	a5 a3       	std	Z+37, r26	; 0x25
    2d04:	b6 a3       	std	Z+38, r27	; 0x26
    2d06:	89 a1       	ldd	r24, Y+33	; 0x21
		
		universal_telemetry.gyr_x = gyr[0];
    2d08:	9a a1       	ldd	r25, Y+34	; 0x22
    2d0a:	ab a1       	ldd	r26, Y+35	; 0x23
    2d0c:	bc a1       	ldd	r27, Y+36	; 0x24
    2d0e:	87 a3       	std	Z+39, r24	; 0x27
    2d10:	90 a7       	std	Z+40, r25	; 0x28
    2d12:	a1 a7       	std	Z+41, r26	; 0x29
    2d14:	b2 a7       	std	Z+42, r27	; 0x2a
    2d16:	8d a1       	ldd	r24, Y+37	; 0x25
		universal_telemetry.gyr_y = gyr[1];
    2d18:	9e a1       	ldd	r25, Y+38	; 0x26
    2d1a:	af a1       	ldd	r26, Y+39	; 0x27
    2d1c:	b8 a5       	ldd	r27, Y+40	; 0x28
    2d1e:	83 a7       	std	Z+43, r24	; 0x2b
    2d20:	94 a7       	std	Z+44, r25	; 0x2c
    2d22:	a5 a7       	std	Z+45, r26	; 0x2d
    2d24:	b6 a7       	std	Z+46, r27	; 0x2e
    2d26:	89 a5       	ldd	r24, Y+41	; 0x29
		universal_telemetry.gyr_z = gyr[2];
    2d28:	9a a5       	ldd	r25, Y+42	; 0x2a
    2d2a:	ab a5       	ldd	r26, Y+43	; 0x2b
    2d2c:	bc a5       	ldd	r27, Y+44	; 0x2c
    2d2e:	87 a7       	std	Z+47, r24	; 0x2f
    2d30:	90 ab       	std	Z+48, r25	; 0x30
    2d32:	a1 ab       	std	Z+49, r26	; 0x31
    2d34:	b2 ab       	std	Z+50, r27	; 0x32
		//char altitude_text[20];
		//sprintf(altitude_text, "Altitude: %d\r\n", (int)(universal_telemetry.altitude * 100));
		//print(altitude_text);
			
		// send events if altitude is high enough
		if (is_falling(universal_telemetry.altitude)) {
    2d36:	63 81       	ldd	r22, Z+3	; 0x03
    2d38:	74 81       	ldd	r23, Z+4	; 0x04
    2d3a:	85 81       	ldd	r24, Z+5	; 0x05
    2d3c:	96 81       	ldd	r25, Z+6	; 0x06
    2d3e:	ec de       	rcall	.-552    	; 0x2b18 <is_falling>
    2d40:	88 23       	and	r24, r24
    2d42:	79 f0       	breq	.+30     	; 0x2d62 <data_reading+0x1e8>
    2d44:	81 e0       	ldi	r24, 0x01	; 1
			// print("Is Falling!\r\n");
			event = MAX_HEIGHT_REACHED;
    2d46:	8d a7       	std	Y+45, r24	; 0x2d
    2d48:	00 e0       	ldi	r16, 0x00	; 0
			xQueueSend(events_queue, &event, portMAX_DELAY);
    2d4a:	2f ef       	ldi	r18, 0xFF	; 255
    2d4c:	3f ef       	ldi	r19, 0xFF	; 255
    2d4e:	a9 01       	movw	r20, r18
    2d50:	be 01       	movw	r22, r28
    2d52:	63 5d       	subi	r22, 0xD3	; 211
    2d54:	7f 4f       	sbci	r23, 0xFF	; 255
    2d56:	80 91 e5 1d 	lds	r24, 0x1DE5	; 0x801de5 <events_queue>
    2d5a:	90 91 e6 1d 	lds	r25, 0x1DE6	; 0x801de6 <events_queue+0x1>
    2d5e:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
    2d62:	60 91 b1 1d 	lds	r22, 0x1DB1	; 0x801db1 <universal_telemetry+0x3>
		}
			
		if (universal_telemetry.altitude < deploy_height) {
    2d66:	70 91 b2 1d 	lds	r23, 0x1DB2	; 0x801db2 <universal_telemetry+0x4>
    2d6a:	80 91 b3 1d 	lds	r24, 0x1DB3	; 0x801db3 <universal_telemetry+0x5>
    2d6e:	90 91 b4 1d 	lds	r25, 0x1DB4	; 0x801db4 <universal_telemetry+0x6>
    2d72:	20 91 d3 1c 	lds	r18, 0x1CD3	; 0x801cd3 <deploy_height>
    2d76:	30 91 d4 1c 	lds	r19, 0x1CD4	; 0x801cd4 <deploy_height+0x1>
    2d7a:	40 91 d5 1c 	lds	r20, 0x1CD5	; 0x801cd5 <deploy_height+0x2>
    2d7e:	50 91 d6 1c 	lds	r21, 0x1CD6	; 0x801cd6 <deploy_height+0x3>
    2d82:	ad d5       	rcall	.+2906   	; 0x38de <__cmpsf2>
    2d84:	88 23       	and	r24, r24
    2d86:	7c f4       	brge	.+30     	; 0x2da6 <data_reading+0x22c>
    2d88:	82 e0       	ldi	r24, 0x02	; 2
			event = RELEASE_HEIGHT_REACHED;
    2d8a:	8d a7       	std	Y+45, r24	; 0x2d
    2d8c:	00 e0       	ldi	r16, 0x00	; 0
			xQueueSend(events_queue, &event, portMAX_DELAY);
    2d8e:	2f ef       	ldi	r18, 0xFF	; 255
    2d90:	3f ef       	ldi	r19, 0xFF	; 255
    2d92:	a9 01       	movw	r20, r18
    2d94:	be 01       	movw	r22, r28
    2d96:	63 5d       	subi	r22, 0xD3	; 211
    2d98:	7f 4f       	sbci	r23, 0xFF	; 255
    2d9a:	80 91 e5 1d 	lds	r24, 0x1DE5	; 0x801de5 <events_queue>
    2d9e:	90 91 e6 1d 	lds	r25, 0x1DE6	; 0x801de6 <events_queue+0x1>
    2da2:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
		}
			
		if (is_stationary(universal_telemetry.altitude)) {
    2da6:	60 91 b1 1d 	lds	r22, 0x1DB1	; 0x801db1 <universal_telemetry+0x3>
    2daa:	70 91 b2 1d 	lds	r23, 0x1DB2	; 0x801db2 <universal_telemetry+0x4>
    2dae:	80 91 b3 1d 	lds	r24, 0x1DB3	; 0x801db3 <universal_telemetry+0x5>
    2db2:	90 91 b4 1d 	lds	r25, 0x1DB4	; 0x801db4 <universal_telemetry+0x6>
    2db6:	c8 de       	rcall	.-624    	; 0x2b48 <is_stationary>
    2db8:	88 23       	and	r24, r24
    2dba:	79 f0       	breq	.+30     	; 0x2dda <data_reading+0x260>
    2dbc:	83 e0       	ldi	r24, 0x03	; 3
			event = IS_LANDED;
    2dbe:	8d a7       	std	Y+45, r24	; 0x2d
    2dc0:	00 e0       	ldi	r16, 0x00	; 0
			xQueueSend(events_queue, &event, portMAX_DELAY);
    2dc2:	2f ef       	ldi	r18, 0xFF	; 255
    2dc4:	3f ef       	ldi	r19, 0xFF	; 255
    2dc6:	a9 01       	movw	r20, r18
    2dc8:	be 01       	movw	r22, r28
    2dca:	63 5d       	subi	r22, 0xD3	; 211
    2dcc:	7f 4f       	sbci	r23, 0xFF	; 255
    2dce:	80 91 e5 1d 	lds	r24, 0x1DE5	; 0x801de5 <events_queue>
    2dd2:	90 91 e6 1d 	lds	r25, 0x1DE6	; 0x801de6 <events_queue+0x1>
    2dd6:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
    2dda:	80 91 b1 1d 	lds	r24, 0x1DB1	; 0x801db1 <universal_telemetry+0x3>
		}
			
		old_altitude = universal_telemetry.altitude;
    2dde:	90 91 b2 1d 	lds	r25, 0x1DB2	; 0x801db2 <universal_telemetry+0x4>
    2de2:	a0 91 b3 1d 	lds	r26, 0x1DB3	; 0x801db3 <universal_telemetry+0x5>
    2de6:	b0 91 b4 1d 	lds	r27, 0x1DB4	; 0x801db4 <universal_telemetry+0x6>
    2dea:	80 93 e7 1d 	sts	0x1DE7, r24	; 0x801de7 <old_altitude>
    2dee:	90 93 e8 1d 	sts	0x1DE8, r25	; 0x801de8 <old_altitude+0x1>
    2df2:	a0 93 e9 1d 	sts	0x1DE9, r26	; 0x801de9 <old_altitude+0x2>
    2df6:	b0 93 ea 1d 	sts	0x1DEA, r27	; 0x801dea <old_altitude+0x3>
    2dfa:	00 e0       	ldi	r16, 0x00	; 0
			
		xSemaphoreGive(stateMutex);
    2dfc:	20 e0       	ldi	r18, 0x00	; 0
    2dfe:	30 e0       	ldi	r19, 0x00	; 0
    2e00:	a9 01       	movw	r20, r18
    2e02:	60 e0       	ldi	r22, 0x00	; 0
    2e04:	70 e0       	ldi	r23, 0x00	; 0
    2e06:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    2e0a:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2e0e:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
    2e12:	68 ee       	ldi	r22, 0xE8	; 232
		
		vTaskDelay(pdMS_TO_TICKS(1000));
    2e14:	73 e0       	ldi	r23, 0x03	; 3
    2e16:	80 e0       	ldi	r24, 0x00	; 0
    2e18:	90 e0       	ldi	r25, 0x00	; 0
    2e1a:	0e 94 ba 0a 	call	0x1574	; 0x1574 <vTaskDelay>
    2e1e:	c1 ce       	rjmp	.-638    	; 0x2ba2 <data_reading+0x28>
	}
    2e20:	ad 96       	adiw	r28, 0x2d	; 45
}
    2e22:	0f b6       	in	r0, 0x3f	; 63
    2e24:	f8 94       	cli
    2e26:	de bf       	out	0x3e, r29	; 62
    2e28:	0f be       	out	0x3f, r0	; 63
    2e2a:	cd bf       	out	0x3d, r28	; 61
    2e2c:	df 91       	pop	r29
    2e2e:	cf 91       	pop	r28
    2e30:	1f 91       	pop	r17
    2e32:	0f 91       	pop	r16
    2e34:	08 95       	ret

00002e36 <pgm_verifier>:
    2e36:	cf 93       	push	r28

void pgm_verifier(void *pvParameters) {
    2e38:	df 93       	push	r29
    2e3a:	1f 92       	push	r1
    2e3c:	cd b7       	in	r28, 0x3d	; 61
    2e3e:	de b7       	in	r29, 0x3e	; 62
	uint32_t app_size = *((uint32_t*)pvParameters);
    2e40:	fc 01       	movw	r30, r24
    2e42:	80 80       	ld	r8, Z
    2e44:	91 80       	ldd	r9, Z+1	; 0x01
    2e46:	a2 80       	ldd	r10, Z+2	; 0x02
    2e48:	b3 80       	ldd	r11, Z+3	; 0x03
	while (1) {
		uint8_t checksum = 0;
		for (uint32_t cntr = 0; cntr < app_size; cntr++) {
    2e4a:	c1 2c       	mov	r12, r1
    2e4c:	d1 2c       	mov	r13, r1
    2e4e:	76 01       	movw	r14, r12
}

void pgm_verifier(void *pvParameters) {
	uint32_t app_size = *((uint32_t*)pvParameters);
	while (1) {
		uint8_t checksum = 0;
    2e50:	10 e0       	ldi	r17, 0x00	; 0
		for (uint32_t cntr = 0; cntr < app_size; cntr++) {
    2e52:	1f c0       	rjmp	.+62     	; 0x2e92 <pgm_verifier+0x5c>
			uint8_t byte;
			if (cntr > 0xFFFF) {
    2e54:	c1 14       	cp	r12, r1
    2e56:	d1 04       	cpc	r13, r1
    2e58:	f1 e0       	ldi	r31, 0x01	; 1
    2e5a:	ef 06       	cpc	r14, r31
    2e5c:	f1 04       	cpc	r15, r1
    2e5e:	58 f0       	brcs	.+22     	; 0x2e76 <pgm_verifier+0x40>
				byte = pgm_read_byte_far(cntr);
    2e60:	eb be       	out	0x3b, r14	; 59
    2e62:	f6 01       	movw	r30, r12
    2e64:	87 91       	elpm	r24, Z+
    2e66:	89 83       	std	Y+1, r24	; 0x01
				checksum ^= checksum_checker(&byte, 1);
    2e68:	61 e0       	ldi	r22, 0x01	; 1
    2e6a:	70 e0       	ldi	r23, 0x00	; 0
    2e6c:	ce 01       	movw	r24, r28
    2e6e:	01 96       	adiw	r24, 0x01	; 1
    2e70:	63 d0       	rcall	.+198    	; 0x2f38 <checksum_checker>
    2e72:	18 27       	eor	r17, r24
    2e74:	09 c0       	rjmp	.+18     	; 0x2e88 <pgm_verifier+0x52>
			} else {
				byte = pgm_read_byte(cntr);
    2e76:	f6 01       	movw	r30, r12
    2e78:	84 91       	lpm	r24, Z
    2e7a:	89 83       	std	Y+1, r24	; 0x01
				checksum ^= checksum_checker(&byte, 1);
    2e7c:	61 e0       	ldi	r22, 0x01	; 1
    2e7e:	70 e0       	ldi	r23, 0x00	; 0
    2e80:	ce 01       	movw	r24, r28
    2e82:	01 96       	adiw	r24, 0x01	; 1
    2e84:	59 d0       	rcall	.+178    	; 0x2f38 <checksum_checker>
    2e86:	18 27       	eor	r17, r24

void pgm_verifier(void *pvParameters) {
	uint32_t app_size = *((uint32_t*)pvParameters);
	while (1) {
		uint8_t checksum = 0;
		for (uint32_t cntr = 0; cntr < app_size; cntr++) {
    2e88:	ff ef       	ldi	r31, 0xFF	; 255
    2e8a:	cf 1a       	sub	r12, r31
    2e8c:	df 0a       	sbc	r13, r31
    2e8e:	ef 0a       	sbc	r14, r31
    2e90:	ff 0a       	sbc	r15, r31
    2e92:	c8 14       	cp	r12, r8
    2e94:	d9 04       	cpc	r13, r9
    2e96:	ea 04       	cpc	r14, r10
    2e98:	fb 04       	cpc	r15, r11
    2e9a:	e0 f2       	brcs	.-72     	; 0x2e54 <pgm_verifier+0x1e>
				byte = pgm_read_byte(cntr);
				checksum ^= checksum_checker(&byte, 1);
			}
		}
		
		xSemaphoreTake(stateMutex, portMAX_DELAY);
    2e9c:	00 e0       	ldi	r16, 0x00	; 0
    2e9e:	2f ef       	ldi	r18, 0xFF	; 255
    2ea0:	3f ef       	ldi	r19, 0xFF	; 255
    2ea2:	a9 01       	movw	r20, r18
    2ea4:	60 e0       	ldi	r22, 0x00	; 0
    2ea6:	70 e0       	ldi	r23, 0x00	; 0
    2ea8:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    2eac:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2eb0:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
		universal_telemetry.app_checksum = checksum;
    2eb4:	10 93 e2 1d 	sts	0x1DE2, r17	; 0x801de2 <universal_telemetry+0x34>
		xSemaphoreGive(stateMutex);
    2eb8:	20 e0       	ldi	r18, 0x00	; 0
    2eba:	30 e0       	ldi	r19, 0x00	; 0
    2ebc:	a9 01       	movw	r20, r18
    2ebe:	60 e0       	ldi	r22, 0x00	; 0
    2ec0:	70 e0       	ldi	r23, 0x00	; 0
    2ec2:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    2ec6:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    2eca:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
		
		vTaskDelay(pdMS_TO_TICKS(1000));
    2ece:	68 ee       	ldi	r22, 0xE8	; 232
    2ed0:	73 e0       	ldi	r23, 0x03	; 3
    2ed2:	80 e0       	ldi	r24, 0x00	; 0
    2ed4:	90 e0       	ldi	r25, 0x00	; 0
    2ed6:	0e 94 ba 0a 	call	0x1574	; 0x1574 <vTaskDelay>
	}
    2eda:	b7 cf       	rjmp	.-146    	; 0x2e4a <pgm_verifier+0x14>

00002edc <bootWatchdog>:
}

void bootWatchdog(void *pvParameters) {
	TickType_t start = xTaskGetTickCount();
    2edc:	0e 94 74 09 	call	0x12e8	; 0x12e8 <xTaskGetTickCount>
    2ee0:	6b 01       	movw	r12, r22
    2ee2:	7c 01       	movw	r14, r24
	
	while (1) {
		if (startup_ack == 1) {
    2ee4:	80 91 3f 1d 	lds	r24, 0x1D3F	; 0x801d3f <startup_ack>
    2ee8:	81 30       	cpi	r24, 0x01	; 1
    2eea:	21 f4       	brne	.+8      	; 0x2ef4 <bootWatchdog+0x18>
			vTaskDelete(NULL);
    2eec:	80 e0       	ldi	r24, 0x00	; 0
    2eee:	90 e0       	ldi	r25, 0x00	; 0
    2ef0:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <vTaskDelete>
		}
		
		if ((xTaskGetTickCount() - start) > pdMS_TO_TICKS(WATCHDOG_TIMEOUT_MS)) {
    2ef4:	0e 94 74 09 	call	0x12e8	; 0x12e8 <xTaskGetTickCount>
    2ef8:	dc 01       	movw	r26, r24
    2efa:	cb 01       	movw	r24, r22
    2efc:	8c 19       	sub	r24, r12
    2efe:	9d 09       	sbc	r25, r13
    2f00:	ae 09       	sbc	r26, r14
    2f02:	bf 09       	sbc	r27, r15
    2f04:	81 33       	cpi	r24, 0x31	; 49
    2f06:	95 47       	sbci	r25, 0x75	; 117
    2f08:	a1 05       	cpc	r26, r1
    2f0a:	b1 05       	cpc	r27, r1
    2f0c:	70 f0       	brcs	.+28     	; 0x2f2a <bootWatchdog+0x4e>
			taskENTER_CRITICAL();
    2f0e:	0f b6       	in	r0, 0x3f	; 63
    2f10:	f8 94       	cli
    2f12:	0f 92       	push	r0
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    2f14:	9c e0       	ldi	r25, 0x0C	; 12
    2f16:	88 e1       	ldi	r24, 0x18	; 24
    2f18:	0f b6       	in	r0, 0x3f	; 63
    2f1a:	f8 94       	cli
    2f1c:	a8 95       	wdr
    2f1e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    2f22:	0f be       	out	0x3f, r0	; 63
    2f24:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    2f28:	ff cf       	rjmp	.-2      	; 0x2f28 <bootWatchdog+0x4c>
			// enter bootloader
			wdt_enable(WDTO_250MS);
			while(1); // wait for reset
		}
		
		vTaskDelay(pdMS_TO_TICKS(1000));
    2f2a:	68 ee       	ldi	r22, 0xE8	; 232
    2f2c:	73 e0       	ldi	r23, 0x03	; 3
    2f2e:	80 e0       	ldi	r24, 0x00	; 0
    2f30:	90 e0       	ldi	r25, 0x00	; 0
    2f32:	0e 94 ba 0a 	call	0x1574	; 0x1574 <vTaskDelay>
	}
    2f36:	d6 cf       	rjmp	.-84     	; 0x2ee4 <bootWatchdog+0x8>

00002f38 <checksum_checker>:
QueueHandle_t telemetryQueue;
uint8_t packet_count = 0;

uint8_t startup_ack = 0;

uint8_t checksum_checker(uint8_t *buf, size_t len) {
    2f38:	ac 01       	movw	r20, r24
    uint8_t checksum = 0;
    for (size_t i = 0; i < len; i++) {
    2f3a:	20 e0       	ldi	r18, 0x00	; 0
    2f3c:	30 e0       	ldi	r19, 0x00	; 0
uint8_t packet_count = 0;

uint8_t startup_ack = 0;

uint8_t checksum_checker(uint8_t *buf, size_t len) {
    uint8_t checksum = 0;
    2f3e:	80 e0       	ldi	r24, 0x00	; 0
    for (size_t i = 0; i < len; i++) {
    2f40:	07 c0       	rjmp	.+14     	; 0x2f50 <checksum_checker+0x18>
        checksum ^= buf[i];
    2f42:	fa 01       	movw	r30, r20
    2f44:	e2 0f       	add	r30, r18
    2f46:	f3 1f       	adc	r31, r19
    2f48:	90 81       	ld	r25, Z
    2f4a:	89 27       	eor	r24, r25

uint8_t startup_ack = 0;

uint8_t checksum_checker(uint8_t *buf, size_t len) {
    uint8_t checksum = 0;
    for (size_t i = 0; i < len; i++) {
    2f4c:	2f 5f       	subi	r18, 0xFF	; 255
    2f4e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f50:	26 17       	cp	r18, r22
    2f52:	37 07       	cpc	r19, r23
    2f54:	b0 f3       	brcs	.-20     	; 0x2f42 <checksum_checker+0xa>
        checksum ^= buf[i];
    }
    return checksum;
}
    2f56:	08 95       	ret

00002f58 <checksum_calculator>:

uint8_t checksum_calculator(TelemetryData *tm_data)
{
    2f58:	9c 01       	movw	r18, r24
	uint8_t checksum = 0;

	// =============== For Automation ===============
	for (size_t i = 0; i < sizeof(tm_data->packet_count); i++)
    2f5a:	40 e0       	ldi	r20, 0x00	; 0
    2f5c:	50 e0       	ldi	r21, 0x00	; 0
    return checksum;
}

uint8_t checksum_calculator(TelemetryData *tm_data)
{
	uint8_t checksum = 0;
    2f5e:	80 e0       	ldi	r24, 0x00	; 0

	// =============== For Automation ===============
	for (size_t i = 0; i < sizeof(tm_data->packet_count); i++)
    2f60:	07 c0       	rjmp	.+14     	; 0x2f70 <checksum_calculator+0x18>
	{
		checksum ^= *((uint8_t *)(&(tm_data->packet_count)) + i);
    2f62:	f9 01       	movw	r30, r18
    2f64:	e4 0f       	add	r30, r20
    2f66:	f5 1f       	adc	r31, r21
    2f68:	90 81       	ld	r25, Z
    2f6a:	89 27       	eor	r24, r25
uint8_t checksum_calculator(TelemetryData *tm_data)
{
	uint8_t checksum = 0;

	// =============== For Automation ===============
	for (size_t i = 0; i < sizeof(tm_data->packet_count); i++)
    2f6c:	4f 5f       	subi	r20, 0xFF	; 255
    2f6e:	5f 4f       	sbci	r21, 0xFF	; 255
    2f70:	41 15       	cp	r20, r1
    2f72:	51 05       	cpc	r21, r1
    2f74:	b1 f3       	breq	.-20     	; 0x2f62 <checksum_calculator+0xa>
    2f76:	40 e0       	ldi	r20, 0x00	; 0
    2f78:	50 e0       	ldi	r21, 0x00	; 0
    2f7a:	08 c0       	rjmp	.+16     	; 0x2f8c <checksum_calculator+0x34>
		checksum ^= *((uint8_t *)(&(tm_data->packet_count)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->mode); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->mode)) + i);
    2f7c:	f9 01       	movw	r30, r18
    2f7e:	31 96       	adiw	r30, 0x01	; 1
    2f80:	e4 0f       	add	r30, r20
    2f82:	f5 1f       	adc	r31, r21
    2f84:	90 81       	ld	r25, Z
    2f86:	89 27       	eor	r24, r25
	for (size_t i = 0; i < sizeof(tm_data->packet_count); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->packet_count)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->mode); i++)
    2f88:	4f 5f       	subi	r20, 0xFF	; 255
    2f8a:	5f 4f       	sbci	r21, 0xFF	; 255
    2f8c:	41 15       	cp	r20, r1
    2f8e:	51 05       	cpc	r21, r1
    2f90:	a9 f3       	breq	.-22     	; 0x2f7c <checksum_calculator+0x24>
    2f92:	40 e0       	ldi	r20, 0x00	; 0
    2f94:	50 e0       	ldi	r21, 0x00	; 0
    2f96:	08 c0       	rjmp	.+16     	; 0x2fa8 <checksum_calculator+0x50>
		checksum ^= *((uint8_t *)(&(tm_data->mode)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->stage); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->stage)) + i);
    2f98:	f9 01       	movw	r30, r18
    2f9a:	32 96       	adiw	r30, 0x02	; 2
    2f9c:	e4 0f       	add	r30, r20
    2f9e:	f5 1f       	adc	r31, r21
    2fa0:	90 81       	ld	r25, Z
    2fa2:	89 27       	eor	r24, r25
	for (size_t i = 0; i < sizeof(tm_data->mode); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->mode)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->stage); i++)
    2fa4:	4f 5f       	subi	r20, 0xFF	; 255
    2fa6:	5f 4f       	sbci	r21, 0xFF	; 255
    2fa8:	41 15       	cp	r20, r1
    2faa:	51 05       	cpc	r21, r1
    2fac:	a9 f3       	breq	.-22     	; 0x2f98 <checksum_calculator+0x40>
    2fae:	40 e0       	ldi	r20, 0x00	; 0
    2fb0:	50 e0       	ldi	r21, 0x00	; 0
    2fb2:	08 c0       	rjmp	.+16     	; 0x2fc4 <checksum_calculator+0x6c>
		checksum ^= *((uint8_t *)(&(tm_data->stage)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->altitude); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->altitude)) + i);
    2fb4:	f9 01       	movw	r30, r18
    2fb6:	33 96       	adiw	r30, 0x03	; 3
    2fb8:	e4 0f       	add	r30, r20
    2fba:	f5 1f       	adc	r31, r21
    2fbc:	90 81       	ld	r25, Z
    2fbe:	89 27       	eor	r24, r25
	for (size_t i = 0; i < sizeof(tm_data->stage); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->stage)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->altitude); i++)
    2fc0:	4f 5f       	subi	r20, 0xFF	; 255
    2fc2:	5f 4f       	sbci	r21, 0xFF	; 255
    2fc4:	44 30       	cpi	r20, 0x04	; 4
    2fc6:	51 05       	cpc	r21, r1
    2fc8:	a8 f3       	brcs	.-22     	; 0x2fb4 <checksum_calculator+0x5c>
    2fca:	40 e0       	ldi	r20, 0x00	; 0
    2fcc:	50 e0       	ldi	r21, 0x00	; 0
    2fce:	08 c0       	rjmp	.+16     	; 0x2fe0 <checksum_calculator+0x88>
		checksum ^= *((uint8_t *)(&(tm_data->altitude)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->pressure); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->pressure)) + i);
    2fd0:	f9 01       	movw	r30, r18
    2fd2:	37 96       	adiw	r30, 0x07	; 7
    2fd4:	e4 0f       	add	r30, r20
    2fd6:	f5 1f       	adc	r31, r21
    2fd8:	90 81       	ld	r25, Z
    2fda:	89 27       	eor	r24, r25
	for (size_t i = 0; i < sizeof(tm_data->altitude); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->altitude)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->pressure); i++)
    2fdc:	4f 5f       	subi	r20, 0xFF	; 255
    2fde:	5f 4f       	sbci	r21, 0xFF	; 255
    2fe0:	44 30       	cpi	r20, 0x04	; 4
    2fe2:	51 05       	cpc	r21, r1
    2fe4:	a8 f3       	brcs	.-22     	; 0x2fd0 <checksum_calculator+0x78>
    2fe6:	40 e0       	ldi	r20, 0x00	; 0
    2fe8:	50 e0       	ldi	r21, 0x00	; 0
    2fea:	08 c0       	rjmp	.+16     	; 0x2ffc <checksum_calculator+0xa4>
		checksum ^= *((uint8_t *)(&(tm_data->pressure)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->temperature); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->temperature)) + i);
    2fec:	f9 01       	movw	r30, r18
    2fee:	3b 96       	adiw	r30, 0x0b	; 11
    2ff0:	e4 0f       	add	r30, r20
    2ff2:	f5 1f       	adc	r31, r21
    2ff4:	90 81       	ld	r25, Z
    2ff6:	89 27       	eor	r24, r25
	for (size_t i = 0; i < sizeof(tm_data->pressure); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->pressure)) + i);
	}
	
	for (size_t i = 0; i < sizeof(tm_data->temperature); i++)
    2ff8:	4f 5f       	subi	r20, 0xFF	; 255
    2ffa:	5f 4f       	sbci	r21, 0xFF	; 255
    2ffc:	44 30       	cpi	r20, 0x04	; 4
    2ffe:	51 05       	cpc	r21, r1
    3000:	a8 f3       	brcs	.-22     	; 0x2fec <checksum_calculator+0x94>
    3002:	40 e0       	ldi	r20, 0x00	; 0
    3004:	50 e0       	ldi	r21, 0x00	; 0
    3006:	08 c0       	rjmp	.+16     	; 0x3018 <checksum_calculator+0xc0>
	{
		checksum ^= *((uint8_t *)(&(tm_data->temperature)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_x); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_x)) + i);
    3008:	f9 01       	movw	r30, r18
    300a:	3f 96       	adiw	r30, 0x0f	; 15
    300c:	e4 0f       	add	r30, r20
    300e:	f5 1f       	adc	r31, r21
    3010:	90 81       	ld	r25, Z
    3012:	89 27       	eor	r24, r25
	
	for (size_t i = 0; i < sizeof(tm_data->temperature); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->temperature)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_x); i++)
    3014:	4f 5f       	subi	r20, 0xFF	; 255
    3016:	5f 4f       	sbci	r21, 0xFF	; 255
    3018:	44 30       	cpi	r20, 0x04	; 4
    301a:	51 05       	cpc	r21, r1
    301c:	a8 f3       	brcs	.-22     	; 0x3008 <checksum_calculator+0xb0>
    301e:	40 e0       	ldi	r20, 0x00	; 0
    3020:	50 e0       	ldi	r21, 0x00	; 0
    3022:	08 c0       	rjmp	.+16     	; 0x3034 <checksum_calculator+0xdc>
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_x)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_y); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_y)) + i);
    3024:	f9 01       	movw	r30, r18
    3026:	73 96       	adiw	r30, 0x13	; 19
    3028:	e4 0f       	add	r30, r20
    302a:	f5 1f       	adc	r31, r21
    302c:	90 81       	ld	r25, Z
    302e:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_x); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_x)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_y); i++)
    3030:	4f 5f       	subi	r20, 0xFF	; 255
    3032:	5f 4f       	sbci	r21, 0xFF	; 255
    3034:	44 30       	cpi	r20, 0x04	; 4
    3036:	51 05       	cpc	r21, r1
    3038:	a8 f3       	brcs	.-22     	; 0x3024 <checksum_calculator+0xcc>
    303a:	40 e0       	ldi	r20, 0x00	; 0
    303c:	50 e0       	ldi	r21, 0x00	; 0
    303e:	08 c0       	rjmp	.+16     	; 0x3050 <checksum_calculator+0xf8>
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_y)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_z); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_z)) + i);
    3040:	f9 01       	movw	r30, r18
    3042:	77 96       	adiw	r30, 0x17	; 23
    3044:	e4 0f       	add	r30, r20
    3046:	f5 1f       	adc	r31, r21
    3048:	90 81       	ld	r25, Z
    304a:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_y); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_y)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_z); i++)
    304c:	4f 5f       	subi	r20, 0xFF	; 255
    304e:	5f 4f       	sbci	r21, 0xFF	; 255
    3050:	44 30       	cpi	r20, 0x04	; 4
    3052:	51 05       	cpc	r21, r1
    3054:	a8 f3       	brcs	.-22     	; 0x3040 <checksum_calculator+0xe8>
    3056:	40 e0       	ldi	r20, 0x00	; 0
    3058:	50 e0       	ldi	r21, 0x00	; 0
    305a:	08 c0       	rjmp	.+16     	; 0x306c <checksum_calculator+0x114>
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_z)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_x); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_x)) + i);
    305c:	f9 01       	movw	r30, r18
    305e:	7b 96       	adiw	r30, 0x1b	; 27
    3060:	e4 0f       	add	r30, r20
    3062:	f5 1f       	adc	r31, r21
    3064:	90 81       	ld	r25, Z
    3066:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->acc_z); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->acc_z)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_x); i++)
    3068:	4f 5f       	subi	r20, 0xFF	; 255
    306a:	5f 4f       	sbci	r21, 0xFF	; 255
    306c:	44 30       	cpi	r20, 0x04	; 4
    306e:	51 05       	cpc	r21, r1
    3070:	a8 f3       	brcs	.-22     	; 0x305c <checksum_calculator+0x104>
    3072:	40 e0       	ldi	r20, 0x00	; 0
    3074:	50 e0       	ldi	r21, 0x00	; 0
    3076:	08 c0       	rjmp	.+16     	; 0x3088 <checksum_calculator+0x130>
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_x)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_y); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_y)) + i);
    3078:	f9 01       	movw	r30, r18
    307a:	7f 96       	adiw	r30, 0x1f	; 31
    307c:	e4 0f       	add	r30, r20
    307e:	f5 1f       	adc	r31, r21
    3080:	90 81       	ld	r25, Z
    3082:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_x); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_x)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_y); i++)
    3084:	4f 5f       	subi	r20, 0xFF	; 255
    3086:	5f 4f       	sbci	r21, 0xFF	; 255
    3088:	44 30       	cpi	r20, 0x04	; 4
    308a:	51 05       	cpc	r21, r1
    308c:	a8 f3       	brcs	.-22     	; 0x3078 <checksum_calculator+0x120>
    308e:	40 e0       	ldi	r20, 0x00	; 0
    3090:	50 e0       	ldi	r21, 0x00	; 0
    3092:	08 c0       	rjmp	.+16     	; 0x30a4 <checksum_calculator+0x14c>
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_y)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_z); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_z)) + i);
    3094:	f9 01       	movw	r30, r18
    3096:	b3 96       	adiw	r30, 0x23	; 35
    3098:	e4 0f       	add	r30, r20
    309a:	f5 1f       	adc	r31, r21
    309c:	90 81       	ld	r25, Z
    309e:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_y); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_y)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_z); i++)
    30a0:	4f 5f       	subi	r20, 0xFF	; 255
    30a2:	5f 4f       	sbci	r21, 0xFF	; 255
    30a4:	44 30       	cpi	r20, 0x04	; 4
    30a6:	51 05       	cpc	r21, r1
    30a8:	a8 f3       	brcs	.-22     	; 0x3094 <checksum_calculator+0x13c>
    30aa:	40 e0       	ldi	r20, 0x00	; 0
    30ac:	50 e0       	ldi	r21, 0x00	; 0
    30ae:	08 c0       	rjmp	.+16     	; 0x30c0 <checksum_calculator+0x168>
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_z)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_x); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_x)) + i);
    30b0:	f9 01       	movw	r30, r18
    30b2:	b7 96       	adiw	r30, 0x27	; 39
    30b4:	e4 0f       	add	r30, r20
    30b6:	f5 1f       	adc	r31, r21
    30b8:	90 81       	ld	r25, Z
    30ba:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->mag_z); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->mag_z)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_x); i++)
    30bc:	4f 5f       	subi	r20, 0xFF	; 255
    30be:	5f 4f       	sbci	r21, 0xFF	; 255
    30c0:	44 30       	cpi	r20, 0x04	; 4
    30c2:	51 05       	cpc	r21, r1
    30c4:	a8 f3       	brcs	.-22     	; 0x30b0 <checksum_calculator+0x158>
    30c6:	40 e0       	ldi	r20, 0x00	; 0
    30c8:	50 e0       	ldi	r21, 0x00	; 0
    30ca:	08 c0       	rjmp	.+16     	; 0x30dc <checksum_calculator+0x184>
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_x)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_y); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_y)) + i);
    30cc:	f9 01       	movw	r30, r18
    30ce:	bb 96       	adiw	r30, 0x2b	; 43
    30d0:	e4 0f       	add	r30, r20
    30d2:	f5 1f       	adc	r31, r21
    30d4:	90 81       	ld	r25, Z
    30d6:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_x); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_x)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_y); i++)
    30d8:	4f 5f       	subi	r20, 0xFF	; 255
    30da:	5f 4f       	sbci	r21, 0xFF	; 255
    30dc:	44 30       	cpi	r20, 0x04	; 4
    30de:	51 05       	cpc	r21, r1
    30e0:	a8 f3       	brcs	.-22     	; 0x30cc <checksum_calculator+0x174>
    30e2:	40 e0       	ldi	r20, 0x00	; 0
    30e4:	50 e0       	ldi	r21, 0x00	; 0
    30e6:	08 c0       	rjmp	.+16     	; 0x30f8 <checksum_calculator+0x1a0>
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_y)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_z); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_z)) + i);
    30e8:	f9 01       	movw	r30, r18
    30ea:	bf 96       	adiw	r30, 0x2f	; 47
    30ec:	e4 0f       	add	r30, r20
    30ee:	f5 1f       	adc	r31, r21
    30f0:	90 81       	ld	r25, Z
    30f2:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_y); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_y)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_z); i++)
    30f4:	4f 5f       	subi	r20, 0xFF	; 255
    30f6:	5f 4f       	sbci	r21, 0xFF	; 255
    30f8:	44 30       	cpi	r20, 0x04	; 4
    30fa:	51 05       	cpc	r21, r1
    30fc:	a8 f3       	brcs	.-22     	; 0x30e8 <checksum_calculator+0x190>
    30fe:	40 e0       	ldi	r20, 0x00	; 0
    3100:	50 e0       	ldi	r21, 0x00	; 0
    3102:	08 c0       	rjmp	.+16     	; 0x3114 <checksum_calculator+0x1bc>
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_z)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->cmd_echo); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->cmd_echo)) + i);
    3104:	f9 01       	movw	r30, r18
    3106:	f3 96       	adiw	r30, 0x33	; 51
    3108:	e4 0f       	add	r30, r20
    310a:	f5 1f       	adc	r31, r21
    310c:	90 81       	ld	r25, Z
    310e:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->gyr_z); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->gyr_z)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->cmd_echo); i++)
    3110:	4f 5f       	subi	r20, 0xFF	; 255
    3112:	5f 4f       	sbci	r21, 0xFF	; 255
    3114:	41 15       	cp	r20, r1
    3116:	51 05       	cpc	r21, r1
    3118:	a9 f3       	breq	.-22     	; 0x3104 <checksum_calculator+0x1ac>
    311a:	40 e0       	ldi	r20, 0x00	; 0
    311c:	50 e0       	ldi	r21, 0x00	; 0
    311e:	08 c0       	rjmp	.+16     	; 0x3130 <checksum_calculator+0x1d8>
	{
		checksum ^= *((uint8_t *)(&(tm_data->cmd_echo)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->app_checksum); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->app_checksum)) + i);
    3120:	f9 01       	movw	r30, r18
    3122:	f4 96       	adiw	r30, 0x34	; 52
    3124:	e4 0f       	add	r30, r20
    3126:	f5 1f       	adc	r31, r21
    3128:	90 81       	ld	r25, Z
    312a:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->cmd_echo); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->cmd_echo)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->app_checksum); i++)
    312c:	4f 5f       	subi	r20, 0xFF	; 255
    312e:	5f 4f       	sbci	r21, 0xFF	; 255
    3130:	41 15       	cp	r20, r1
    3132:	51 05       	cpc	r21, r1
    3134:	a9 f3       	breq	.-22     	; 0x3120 <checksum_calculator+0x1c8>
    3136:	40 e0       	ldi	r20, 0x00	; 0
    3138:	50 e0       	ldi	r21, 0x00	; 0
    313a:	08 c0       	rjmp	.+16     	; 0x314c <checksum_calculator+0x1f4>
	{
		checksum ^= *((uint8_t *)(&(tm_data->app_checksum)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->upload_status); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->upload_status)) + i);
    313c:	f9 01       	movw	r30, r18
    313e:	f5 96       	adiw	r30, 0x35	; 53
    3140:	e4 0f       	add	r30, r20
    3142:	f5 1f       	adc	r31, r21
    3144:	90 81       	ld	r25, Z
    3146:	89 27       	eor	r24, r25
	}
	for (size_t i = 0; i < sizeof(tm_data->app_checksum); i++)
	{
		checksum ^= *((uint8_t *)(&(tm_data->app_checksum)) + i);
	}
	for (size_t i = 0; i < sizeof(tm_data->upload_status); i++)
    3148:	4f 5f       	subi	r20, 0xFF	; 255
    314a:	5f 4f       	sbci	r21, 0xFF	; 255
    314c:	41 15       	cp	r20, r1
    314e:	51 05       	cpc	r21, r1
    3150:	a9 f3       	breq	.-22     	; 0x313c <checksum_calculator+0x1e4>
		checksum ^= *((uint8_t *)(&(tm_data->upload_status)) + i);
	}
	// ==============================================

	return checksum;
}
    3152:	08 95       	ret

00003154 <send_to_ground>:

void send_to_ground(void *pvParameters)
{	
    3154:	cf 93       	push	r28
    3156:	df 93       	push	r29
    3158:	1f 92       	push	r1
    315a:	1f 92       	push	r1
    315c:	cd b7       	in	r28, 0x3d	; 61
    315e:	de b7       	in	r29, 0x3e	; 62
	uint8_t start = START_BYTE;
    3160:	8f ef       	ldi	r24, 0xFF	; 255
    3162:	89 83       	std	Y+1, r24	; 0x01
	uint8_t end = END_BYTE;
	while (1)
	{
		if (!is_updating) {
    3164:	80 91 42 1d 	lds	r24, 0x1D42	; 0x801d42 <is_updating>
    3168:	81 11       	cpse	r24, r1
    316a:	90 c0       	rjmp	.+288    	; 0x328c <send_to_ground+0x138>
			xSemaphoreTake(stateMutex, portMAX_DELAY);
    316c:	00 e0       	ldi	r16, 0x00	; 0
    316e:	2f ef       	ldi	r18, 0xFF	; 255
    3170:	3f ef       	ldi	r19, 0xFF	; 255
    3172:	a9 01       	movw	r20, r18
    3174:	60 e0       	ldi	r22, 0x00	; 0
    3176:	70 e0       	ldi	r23, 0x00	; 0
    3178:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    317c:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    3180:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>

			universal_telemetry.packet_count = packet_count++;
    3184:	80 91 40 1d 	lds	r24, 0x1D40	; 0x801d40 <packet_count>
    3188:	91 e0       	ldi	r25, 0x01	; 1
    318a:	98 0f       	add	r25, r24
    318c:	90 93 40 1d 	sts	0x1D40, r25	; 0x801d40 <packet_count>
    3190:	0e ea       	ldi	r16, 0xAE	; 174
    3192:	1d e1       	ldi	r17, 0x1D	; 29
    3194:	f8 01       	movw	r30, r16
    3196:	80 83       	st	Z, r24
			// calculate checksum
			universal_telemetry.checksum = checksum_calculator(&universal_telemetry);
    3198:	c8 01       	movw	r24, r16
    319a:	de de       	rcall	.-580    	; 0x2f58 <checksum_calculator>
    319c:	f8 01       	movw	r30, r16
    319e:	86 ab       	std	Z+54, r24	; 0x36
		
			UART1_send_bytes(&start, 1);
    31a0:	61 e0       	ldi	r22, 0x01	; 1
    31a2:	70 e0       	ldi	r23, 0x00	; 0
    31a4:	ce 01       	movw	r24, r28
    31a6:	01 96       	adiw	r24, 0x01	; 1
    31a8:	7c d1       	rcall	.+760    	; 0x34a2 <UART1_send_bytes>
		
			uint8_t packet_size =
    31aa:	87 e3       	ldi	r24, 0x37	; 55
    31ac:	8a 83       	std	Y+2, r24	; 0x02
			+ sizeof(universal_telemetry.checksum)
			+ sizeof(universal_telemetry.cmd_echo)
			+ sizeof(universal_telemetry.app_checksum)
			+ sizeof(universal_telemetry.upload_status);
		
			UART1_send_bytes(&packet_size, 1);
    31ae:	61 e0       	ldi	r22, 0x01	; 1
    31b0:	70 e0       	ldi	r23, 0x00	; 0
    31b2:	ce 01       	movw	r24, r28
    31b4:	02 96       	adiw	r24, 0x02	; 2
    31b6:	75 d1       	rcall	.+746    	; 0x34a2 <UART1_send_bytes>

			// =============== For Automation ===============
			UART1_send_bytes(&(universal_telemetry.packet_count), sizeof(universal_telemetry.packet_count));
    31b8:	61 e0       	ldi	r22, 0x01	; 1
    31ba:	70 e0       	ldi	r23, 0x00	; 0
    31bc:	c8 01       	movw	r24, r16
    31be:	71 d1       	rcall	.+738    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.mode), sizeof(universal_telemetry.mode));
    31c0:	61 e0       	ldi	r22, 0x01	; 1
    31c2:	70 e0       	ldi	r23, 0x00	; 0
    31c4:	8f ea       	ldi	r24, 0xAF	; 175
    31c6:	9d e1       	ldi	r25, 0x1D	; 29
    31c8:	6c d1       	rcall	.+728    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.stage), sizeof(universal_telemetry.stage));
    31ca:	61 e0       	ldi	r22, 0x01	; 1
    31cc:	70 e0       	ldi	r23, 0x00	; 0
    31ce:	80 eb       	ldi	r24, 0xB0	; 176
    31d0:	9d e1       	ldi	r25, 0x1D	; 29
    31d2:	67 d1       	rcall	.+718    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.altitude), sizeof(universal_telemetry.altitude));
    31d4:	64 e0       	ldi	r22, 0x04	; 4
    31d6:	70 e0       	ldi	r23, 0x00	; 0
    31d8:	81 eb       	ldi	r24, 0xB1	; 177
    31da:	9d e1       	ldi	r25, 0x1D	; 29
    31dc:	62 d1       	rcall	.+708    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.pressure), sizeof(universal_telemetry.pressure));
    31de:	64 e0       	ldi	r22, 0x04	; 4
    31e0:	70 e0       	ldi	r23, 0x00	; 0
    31e2:	85 eb       	ldi	r24, 0xB5	; 181
    31e4:	9d e1       	ldi	r25, 0x1D	; 29
    31e6:	5d d1       	rcall	.+698    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.temperature), sizeof(universal_telemetry.temperature));
    31e8:	64 e0       	ldi	r22, 0x04	; 4
    31ea:	70 e0       	ldi	r23, 0x00	; 0
    31ec:	89 eb       	ldi	r24, 0xB9	; 185
    31ee:	9d e1       	ldi	r25, 0x1D	; 29
    31f0:	58 d1       	rcall	.+688    	; 0x34a2 <UART1_send_bytes>
		
			UART1_send_bytes(&(universal_telemetry.acc_x), sizeof(universal_telemetry.acc_x));
    31f2:	64 e0       	ldi	r22, 0x04	; 4
    31f4:	70 e0       	ldi	r23, 0x00	; 0
    31f6:	8d eb       	ldi	r24, 0xBD	; 189
    31f8:	9d e1       	ldi	r25, 0x1D	; 29
    31fa:	53 d1       	rcall	.+678    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.acc_y), sizeof(universal_telemetry.acc_y));
    31fc:	64 e0       	ldi	r22, 0x04	; 4
    31fe:	70 e0       	ldi	r23, 0x00	; 0
    3200:	81 ec       	ldi	r24, 0xC1	; 193
    3202:	9d e1       	ldi	r25, 0x1D	; 29
    3204:	4e d1       	rcall	.+668    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.acc_z), sizeof(universal_telemetry.acc_z));
    3206:	64 e0       	ldi	r22, 0x04	; 4
    3208:	70 e0       	ldi	r23, 0x00	; 0
    320a:	85 ec       	ldi	r24, 0xC5	; 197
    320c:	9d e1       	ldi	r25, 0x1D	; 29
    320e:	49 d1       	rcall	.+658    	; 0x34a2 <UART1_send_bytes>

			UART1_send_bytes(&(universal_telemetry.mag_x), sizeof(universal_telemetry.mag_x));
    3210:	64 e0       	ldi	r22, 0x04	; 4
    3212:	70 e0       	ldi	r23, 0x00	; 0
    3214:	89 ec       	ldi	r24, 0xC9	; 201
    3216:	9d e1       	ldi	r25, 0x1D	; 29
    3218:	44 d1       	rcall	.+648    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.mag_y), sizeof(universal_telemetry.mag_y));
    321a:	64 e0       	ldi	r22, 0x04	; 4
    321c:	70 e0       	ldi	r23, 0x00	; 0
    321e:	8d ec       	ldi	r24, 0xCD	; 205
    3220:	9d e1       	ldi	r25, 0x1D	; 29
    3222:	3f d1       	rcall	.+638    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.mag_z), sizeof(universal_telemetry.mag_z));
    3224:	64 e0       	ldi	r22, 0x04	; 4
    3226:	70 e0       	ldi	r23, 0x00	; 0
    3228:	81 ed       	ldi	r24, 0xD1	; 209
    322a:	9d e1       	ldi	r25, 0x1D	; 29
    322c:	3a d1       	rcall	.+628    	; 0x34a2 <UART1_send_bytes>

			UART1_send_bytes(&(universal_telemetry.gyr_x), sizeof(universal_telemetry.gyr_x));
    322e:	64 e0       	ldi	r22, 0x04	; 4
    3230:	70 e0       	ldi	r23, 0x00	; 0
    3232:	85 ed       	ldi	r24, 0xD5	; 213
    3234:	9d e1       	ldi	r25, 0x1D	; 29
    3236:	35 d1       	rcall	.+618    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.gyr_y), sizeof(universal_telemetry.gyr_y));
    3238:	64 e0       	ldi	r22, 0x04	; 4
    323a:	70 e0       	ldi	r23, 0x00	; 0
    323c:	89 ed       	ldi	r24, 0xD9	; 217
    323e:	9d e1       	ldi	r25, 0x1D	; 29
    3240:	30 d1       	rcall	.+608    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.gyr_z), sizeof(universal_telemetry.gyr_z));
    3242:	64 e0       	ldi	r22, 0x04	; 4
    3244:	70 e0       	ldi	r23, 0x00	; 0
    3246:	8d ed       	ldi	r24, 0xDD	; 221
    3248:	9d e1       	ldi	r25, 0x1D	; 29
    324a:	2b d1       	rcall	.+598    	; 0x34a2 <UART1_send_bytes>
		
			UART1_send_bytes(&(universal_telemetry.cmd_echo), sizeof(universal_telemetry.cmd_echo));
    324c:	61 e0       	ldi	r22, 0x01	; 1
    324e:	70 e0       	ldi	r23, 0x00	; 0
    3250:	81 ee       	ldi	r24, 0xE1	; 225
    3252:	9d e1       	ldi	r25, 0x1D	; 29
    3254:	26 d1       	rcall	.+588    	; 0x34a2 <UART1_send_bytes>
			UART1_send_bytes(&(universal_telemetry.app_checksum), sizeof(universal_telemetry.app_checksum));
    3256:	61 e0       	ldi	r22, 0x01	; 1
    3258:	70 e0       	ldi	r23, 0x00	; 0
    325a:	82 ee       	ldi	r24, 0xE2	; 226
    325c:	9d e1       	ldi	r25, 0x1D	; 29
    325e:	21 d1       	rcall	.+578    	; 0x34a2 <UART1_send_bytes>
    3260:	61 e0       	ldi	r22, 0x01	; 1
			UART1_send_bytes(&(universal_telemetry.upload_status), sizeof(universal_telemetry.upload_status));
    3262:	70 e0       	ldi	r23, 0x00	; 0
    3264:	83 ee       	ldi	r24, 0xE3	; 227
    3266:	9d e1       	ldi	r25, 0x1D	; 29
    3268:	1c d1       	rcall	.+568    	; 0x34a2 <UART1_send_bytes>
    326a:	61 e0       	ldi	r22, 0x01	; 1
    326c:	70 e0       	ldi	r23, 0x00	; 0
			// ==============================================

			UART1_send_bytes(&(universal_telemetry.checksum), sizeof(universal_telemetry.checksum));
    326e:	84 ee       	ldi	r24, 0xE4	; 228
    3270:	9d e1       	ldi	r25, 0x1D	; 29
    3272:	17 d1       	rcall	.+558    	; 0x34a2 <UART1_send_bytes>
    3274:	00 e0       	ldi	r16, 0x00	; 0
    3276:	20 e0       	ldi	r18, 0x00	; 0
    3278:	30 e0       	ldi	r19, 0x00	; 0

			xSemaphoreGive(stateMutex);
    327a:	a9 01       	movw	r20, r18
    327c:	60 e0       	ldi	r22, 0x00	; 0
    327e:	70 e0       	ldi	r23, 0x00	; 0
    3280:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    3284:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    3288:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
    328c:	68 ee       	ldi	r22, 0xE8	; 232
    328e:	73 e0       	ldi	r23, 0x03	; 3
    3290:	80 e0       	ldi	r24, 0x00	; 0
		}

		vTaskDelay(pdMS_TO_TICKS(1000));
    3292:	90 e0       	ldi	r25, 0x00	; 0
    3294:	0e 94 ba 0a 	call	0x1574	; 0x1574 <vTaskDelay>
    3298:	65 cf       	rjmp	.-310    	; 0x3164 <send_to_ground+0x10>

0000329a <receive_from_ground>:
    329a:	cf 93       	push	r28
    329c:	df 93       	push	r29
	}
    329e:	00 d0       	rcall	.+0      	; 0x32a0 <receive_from_ground+0x6>
}

void receive_from_ground(void *pvParameters) {
    32a0:	1f 92       	push	r1
    32a2:	cd b7       	in	r28, 0x3d	; 61
    32a4:	de b7       	in	r29, 0x3e	; 62
	static uint8_t buf[100];
	static uint8_t application_code[65];
	
	while (1) {
		
		UART1_receive_bytes(buf);
    32a6:	8b ed       	ldi	r24, 0xDB	; 219
    32a8:	9c e1       	ldi	r25, 0x1C	; 28
    32aa:	0e d1       	rcall	.+540    	; 0x34c8 <UART1_receive_bytes>

		// =============== For Automation ===============

		size_t command_length = buf[0];
    32ac:	eb ed       	ldi	r30, 0xDB	; 219
    32ae:	fc e1       	ldi	r31, 0x1C	; 28
    32b0:	00 81       	ld	r16, Z
    32b2:	e0 2e       	mov	r14, r16
    32b4:	f1 2c       	mov	r15, r1
		uint8_t command_id = buf[1];
    32b6:	11 81       	ldd	r17, Z+1	; 0x01
		CommandID command_echo = command_id;
		CanSatEvents_t event;
		
		// confirm validity of command packet
		if (checksum_checker(&buf[1], command_length) == buf[command_length + 1]) {
    32b8:	b7 01       	movw	r22, r14
    32ba:	8c ed       	ldi	r24, 0xDC	; 220
    32bc:	9c e1       	ldi	r25, 0x1C	; 28
    32be:	3c de       	rcall	.-904    	; 0x2f38 <checksum_checker>
    32c0:	f7 01       	movw	r30, r14
    32c2:	e4 52       	subi	r30, 0x24	; 36
    32c4:	f3 4e       	sbci	r31, 0xE3	; 227
    32c6:	90 81       	ld	r25, Z
    32c8:	89 13       	cpse	r24, r25
    32ca:	98 c0       	rjmp	.+304    	; 0x33fc <receive_from_ground+0x162>
			
			switch ((CommandID)command_id) {
    32cc:	81 2f       	mov	r24, r17
    32ce:	90 e0       	ldi	r25, 0x00	; 0
    32d0:	8b 30       	cpi	r24, 0x0B	; 11
    32d2:	91 05       	cpc	r25, r1
    32d4:	08 f0       	brcs	.+2      	; 0x32d8 <receive_from_ground+0x3e>
    32d6:	88 c0       	rjmp	.+272    	; 0x33e8 <receive_from_ground+0x14e>
    32d8:	fc 01       	movw	r30, r24
    32da:	88 27       	eor	r24, r24
    32dc:	ee 58       	subi	r30, 0x8E	; 142
    32de:	ff 4f       	sbci	r31, 0xFF	; 255
    32e0:	8f 4f       	sbci	r24, 0xFF	; 255
    32e2:	f6 c5       	rjmp	.+3052   	; 0x3ed0 <__tablejump2__>
			case LAUNCH:
				print("LAUNCH\r\n");
    32e4:	86 ed       	ldi	r24, 0xD6	; 214
    32e6:	93 e0       	ldi	r25, 0x03	; 3
    32e8:	d0 d0       	rcall	.+416    	; 0x348a <print>
    32ea:	19 82       	std	Y+1, r1	; 0x01
				event = LAUNCH_OK;
    32ec:	00 e0       	ldi	r16, 0x00	; 0
				xQueueSend(events_queue, &event, portMAX_DELAY);
    32ee:	2f ef       	ldi	r18, 0xFF	; 255
    32f0:	3f ef       	ldi	r19, 0xFF	; 255
    32f2:	a9 01       	movw	r20, r18
    32f4:	be 01       	movw	r22, r28
    32f6:	6f 5f       	subi	r22, 0xFF	; 255
    32f8:	7f 4f       	sbci	r23, 0xFF	; 255
    32fa:	80 91 e5 1d 	lds	r24, 0x1DE5	; 0x801de5 <events_queue>
    32fe:	90 91 e6 1d 	lds	r25, 0x1DE6	; 0x801de6 <events_queue+0x1>
    3302:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
				break;
    3306:	7d c0       	rjmp	.+250    	; 0x3402 <receive_from_ground+0x168>
			case SET_PRESSURE: 
				print("SET_PRESSURE\r\n");
    3308:	8f ed       	ldi	r24, 0xDF	; 223
    330a:	93 e0       	ldi	r25, 0x03	; 3
    330c:	be d0       	rcall	.+380    	; 0x348a <print>
    330e:	80 91 dd 1c 	lds	r24, 0x1CDD	; 0x801cdd <buf.2513+0x2>
				float pressure;
				memcpy(&pressure, &buf[2], sizeof(float));
    3312:	90 91 de 1c 	lds	r25, 0x1CDE	; 0x801cde <buf.2513+0x3>
    3316:	a0 91 df 1c 	lds	r26, 0x1CDF	; 0x801cdf <buf.2513+0x4>
    331a:	b0 91 e0 1c 	lds	r27, 0x1CE0	; 0x801ce0 <buf.2513+0x5>
    331e:	89 83       	std	Y+1, r24	; 0x01
    3320:	9a 83       	std	Y+2, r25	; 0x02
    3322:	ab 83       	std	Y+3, r26	; 0x03
    3324:	bc 83       	std	Y+4, r27	; 0x04
    3326:	00 e0       	ldi	r16, 0x00	; 0
				xQueueSend(simulated_pressure_queue, &pressure, portMAX_DELAY);
    3328:	2f ef       	ldi	r18, 0xFF	; 255
    332a:	3f ef       	ldi	r19, 0xFF	; 255
    332c:	a9 01       	movw	r20, r18
    332e:	be 01       	movw	r22, r28
    3330:	6f 5f       	subi	r22, 0xFF	; 255
    3332:	7f 4f       	sbci	r23, 0xFF	; 255
    3334:	80 91 eb 1d 	lds	r24, 0x1DEB	; 0x801deb <simulated_pressure_queue>
    3338:	90 91 ec 1d 	lds	r25, 0x1DEC	; 0x801dec <simulated_pressure_queue+0x1>
    333c:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
				break;
    3340:	60 c0       	rjmp	.+192    	; 0x3402 <receive_from_ground+0x168>
			case ENTER_SIMULATION:
				print("ENTER_SIMULATION\r\n");
    3342:	8e ee       	ldi	r24, 0xEE	; 238
    3344:	93 e0       	ldi	r25, 0x03	; 3
    3346:	a1 d0       	rcall	.+322    	; 0x348a <print>
    3348:	84 e0       	ldi	r24, 0x04	; 4
				event = ENTER_SIM;
    334a:	89 83       	std	Y+1, r24	; 0x01
    334c:	00 e0       	ldi	r16, 0x00	; 0
				xQueueSend(events_queue, &event, portMAX_DELAY);
    334e:	2f ef       	ldi	r18, 0xFF	; 255
    3350:	3f ef       	ldi	r19, 0xFF	; 255
    3352:	a9 01       	movw	r20, r18
    3354:	be 01       	movw	r22, r28
    3356:	6f 5f       	subi	r22, 0xFF	; 255
    3358:	7f 4f       	sbci	r23, 0xFF	; 255
    335a:	80 91 e5 1d 	lds	r24, 0x1DE5	; 0x801de5 <events_queue>
    335e:	90 91 e6 1d 	lds	r25, 0x1DE6	; 0x801de6 <events_queue+0x1>
    3362:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
				break;
    3366:	4d c0       	rjmp	.+154    	; 0x3402 <receive_from_ground+0x168>
			case CALIBRATE_ALTITUDE:
				print("CALIBRATE_ALTITUDE\r\n");
    3368:	81 e0       	ldi	r24, 0x01	; 1
    336a:	94 e0       	ldi	r25, 0x04	; 4
    336c:	8e d0       	rcall	.+284    	; 0x348a <print>
    336e:	85 e0       	ldi	r24, 0x05	; 5
				event = ENTER_CALIBRATION;
    3370:	89 83       	std	Y+1, r24	; 0x01
    3372:	00 e0       	ldi	r16, 0x00	; 0
				xQueueSend(events_queue, &event, portMAX_DELAY);
    3374:	2f ef       	ldi	r18, 0xFF	; 255
    3376:	3f ef       	ldi	r19, 0xFF	; 255
    3378:	a9 01       	movw	r20, r18
    337a:	be 01       	movw	r22, r28
    337c:	6f 5f       	subi	r22, 0xFF	; 255
    337e:	7f 4f       	sbci	r23, 0xFF	; 255
    3380:	80 91 e5 1d 	lds	r24, 0x1DE5	; 0x801de5 <events_queue>
    3384:	90 91 e6 1d 	lds	r25, 0x1DE6	; 0x801de6 <events_queue+0x1>
    3388:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
				break;
			case SERVO:
				print("SERVO\r\n");
    338c:	3a c0       	rjmp	.+116    	; 0x3402 <receive_from_ground+0x168>
    338e:	86 e1       	ldi	r24, 0x16	; 22
    3390:	94 e0       	ldi	r25, 0x04	; 4
    3392:	7b d0       	rcall	.+246    	; 0x348a <print>
				move_servo();
    3394:	15 da       	rcall	.-3030   	; 0x27c0 <move_servo>
    3396:	2f e3       	ldi	r18, 0x3F	; 63
    3398:	8d e0       	ldi	r24, 0x0D	; 13
    339a:	93 e0       	ldi	r25, 0x03	; 3
    339c:	21 50       	subi	r18, 0x01	; 1
    339e:	80 40       	sbci	r24, 0x00	; 0
    33a0:	90 40       	sbci	r25, 0x00	; 0
    33a2:	e1 f7       	brne	.-8      	; 0x339c <receive_from_ground+0x102>
    33a4:	00 c0       	rjmp	.+0      	; 0x33a6 <receive_from_ground+0x10c>
				_delay_ms(1000);
				stop_servo();
    33a6:	00 00       	nop
    33a8:	3b da       	rcall	.-2954   	; 0x2820 <stop_servo>
				break;
    33aa:	2b c0       	rjmp	.+86     	; 0x3402 <receive_from_ground+0x168>
			case RESET:
				print("RESET\r\n");
    33ac:	8e e1       	ldi	r24, 0x1E	; 30
    33ae:	94 e0       	ldi	r25, 0x04	; 4
    33b0:	6c d0       	rcall	.+216    	; 0x348a <print>
    33b2:	9c e0       	ldi	r25, 0x0C	; 12
    33b4:	88 e1       	ldi	r24, 0x18	; 24
    33b6:	0f b6       	in	r0, 0x3f	; 63
    33b8:	f8 94       	cli
    33ba:	a8 95       	wdr
    33bc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    33c0:	0f be       	out	0x3f, r0	; 63
    33c2:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
				// enter bootloader
				wdt_enable(WDTO_250MS);
				while(1); // wait for reset
				break;
			case AT:
				print("AT\r\n");
    33c6:	ff cf       	rjmp	.-2      	; 0x33c6 <receive_from_ground+0x12c>
    33c8:	86 e2       	ldi	r24, 0x26	; 38
    33ca:	94 e0       	ldi	r25, 0x04	; 4
				// send AT command to XBEE
				send_AT_command(&buf[2], command_length - 1);
    33cc:	5e d0       	rcall	.+188    	; 0x348a <print>
    33ce:	6f ef       	ldi	r22, 0xFF	; 255
    33d0:	60 0f       	add	r22, r16
    33d2:	8d ed       	ldi	r24, 0xDD	; 221
    33d4:	9c e1       	ldi	r25, 0x1C	; 28
				break;
    33d6:	cc d1       	rcall	.+920    	; 0x3770 <send_AT_command>
			case STARTUP_ACK:
				print("STARTUP_ACK\r\n");
    33d8:	14 c0       	rjmp	.+40     	; 0x3402 <receive_from_ground+0x168>
    33da:	8b e2       	ldi	r24, 0x2B	; 43
    33dc:	94 e0       	ldi	r25, 0x04	; 4
				startup_ack = 1;
    33de:	55 d0       	rcall	.+170    	; 0x348a <print>
    33e0:	81 e0       	ldi	r24, 0x01	; 1
				break;
    33e2:	80 93 3f 1d 	sts	0x1D3F, r24	; 0x801d3f <startup_ack>
			default:
				print("Something went wrong!\r\n");
    33e6:	0d c0       	rjmp	.+26     	; 0x3402 <receive_from_ground+0x168>
    33e8:	89 e3       	ldi	r24, 0x39	; 57
    33ea:	94 e0       	ldi	r25, 0x04	; 4
				UART0_send_bytes(buf, 20);
    33ec:	4e d0       	rcall	.+156    	; 0x348a <print>
    33ee:	64 e1       	ldi	r22, 0x14	; 20
    33f0:	70 e0       	ldi	r23, 0x00	; 0
    33f2:	8b ed       	ldi	r24, 0xDB	; 219
    33f4:	9c e1       	ldi	r25, 0x1C	; 28
    33f6:	43 d1       	rcall	.+646    	; 0x367e <UART0_send_bytes>
				command_echo = 0xFF;
    33f8:	1f ef       	ldi	r17, 0xFF	; 255
				break;
    33fa:	03 c0       	rjmp	.+6      	; 0x3402 <receive_from_ground+0x168>
			}
		}
		else {
			print("Dropped an invalid packet.\r\n");
    33fc:	81 e5       	ldi	r24, 0x51	; 81
    33fe:	94 e0       	ldi	r25, 0x04	; 4
    3400:	44 d0       	rcall	.+136    	; 0x348a <print>
    3402:	1f 3f       	cpi	r17, 0xFF	; 255
		}
		
		if (command_echo != 0xFF) {
    3404:	c9 f0       	breq	.+50     	; 0x3438 <receive_from_ground+0x19e>
    3406:	00 e0       	ldi	r16, 0x00	; 0
			xSemaphoreTake(stateMutex, portMAX_DELAY);
    3408:	2f ef       	ldi	r18, 0xFF	; 255
    340a:	3f ef       	ldi	r19, 0xFF	; 255
    340c:	a9 01       	movw	r20, r18
    340e:	60 e0       	ldi	r22, 0x00	; 0
    3410:	70 e0       	ldi	r23, 0x00	; 0
    3412:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    3416:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    341a:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
    341e:	10 93 e1 1d 	sts	0x1DE1, r17	; 0x801de1 <universal_telemetry+0x33>
			universal_telemetry.cmd_echo = command_echo;
    3422:	20 e0       	ldi	r18, 0x00	; 0
			xSemaphoreGive(stateMutex);
    3424:	30 e0       	ldi	r19, 0x00	; 0
    3426:	a9 01       	movw	r20, r18
    3428:	60 e0       	ldi	r22, 0x00	; 0
    342a:	70 e0       	ldi	r23, 0x00	; 0
    342c:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <stateMutex>
    3430:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <stateMutex+0x1>
    3434:	0e 94 76 05 	call	0xaec	; 0xaec <xQueueGenericSend>
    3438:	6c e2       	ldi	r22, 0x2C	; 44
		}

		vTaskDelay(pdMS_TO_TICKS(300));
    343a:	71 e0       	ldi	r23, 0x01	; 1
    343c:	80 e0       	ldi	r24, 0x00	; 0
    343e:	90 e0       	ldi	r25, 0x00	; 0
    3440:	0e 94 ba 0a 	call	0x1574	; 0x1574 <vTaskDelay>
    3444:	30 cf       	rjmp	.-416    	; 0x32a6 <receive_from_ground+0xc>

00003446 <UART_init>:
	}
    3446:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
}

// Deprecated
uint8_t UART1_is_ready() {
	return (UCSR1A & (1<<RXC1));
}
    344a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
    344e:	28 e1       	ldi	r18, 0x18	; 24
    3450:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7c00c1>
    3454:	26 e0       	ldi	r18, 0x06	; 6
    3456:	20 93 c2 00 	sts	0x00C2, r18	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7c00c2>
    345a:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7c00cd>
    345e:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7c00cc>
    3462:	88 e9       	ldi	r24, 0x98	; 152
    3464:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7c00c9>
    3468:	20 93 ca 00 	sts	0x00CA, r18	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7c00ca>
    346c:	08 95       	ret

0000346e <UART0_tx>:
    346e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7c00c0>
    3472:	95 ff       	sbrs	r25, 5
    3474:	fc cf       	rjmp	.-8      	; 0x346e <UART0_tx>
    3476:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    347a:	08 95       	ret

0000347c <UART1_tx>:
    347c:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7c00c8>
    3480:	95 ff       	sbrs	r25, 5
    3482:	fc cf       	rjmp	.-8      	; 0x347c <UART1_tx>
    3484:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7c00ce>
    3488:	08 95       	ret

0000348a <print>:
    348a:	cf 93       	push	r28
    348c:	df 93       	push	r29
    348e:	ec 01       	movw	r28, r24
    3490:	02 c0       	rjmp	.+4      	; 0x3496 <print+0xc>
    3492:	ed df       	rcall	.-38     	; 0x346e <UART0_tx>
    3494:	21 96       	adiw	r28, 0x01	; 1
    3496:	88 81       	ld	r24, Y
    3498:	81 11       	cpse	r24, r1
    349a:	fb cf       	rjmp	.-10     	; 0x3492 <print+0x8>
    349c:	df 91       	pop	r29
    349e:	cf 91       	pop	r28
    34a0:	08 95       	ret

000034a2 <UART1_send_bytes>:
    34a2:	0f 93       	push	r16
    34a4:	1f 93       	push	r17
    34a6:	cf 93       	push	r28
    34a8:	df 93       	push	r29
    34aa:	ec 01       	movw	r28, r24
    34ac:	8c 01       	movw	r16, r24
    34ae:	06 0f       	add	r16, r22
    34b0:	17 1f       	adc	r17, r23
    34b2:	02 c0       	rjmp	.+4      	; 0x34b8 <UART1_send_bytes+0x16>
    34b4:	89 91       	ld	r24, Y+
    34b6:	e2 df       	rcall	.-60     	; 0x347c <UART1_tx>
    34b8:	c0 17       	cp	r28, r16
    34ba:	d1 07       	cpc	r29, r17
    34bc:	d8 f3       	brcs	.-10     	; 0x34b4 <UART1_send_bytes+0x12>
    34be:	df 91       	pop	r29
    34c0:	cf 91       	pop	r28
    34c2:	1f 91       	pop	r17
    34c4:	0f 91       	pop	r16
    34c6:	08 95       	ret

000034c8 <UART1_receive_bytes>:
    34c8:	cf 92       	push	r12
    34ca:	df 92       	push	r13
    34cc:	ef 92       	push	r14
    34ce:	ff 92       	push	r15
    34d0:	0f 93       	push	r16
    34d2:	cf 93       	push	r28
    34d4:	df 93       	push	r29
    34d6:	1f 92       	push	r1
    34d8:	cd b7       	in	r28, 0x3d	; 61
    34da:	de b7       	in	r29, 0x3e	; 62
    34dc:	6c 01       	movw	r12, r24
    34de:	00 e0       	ldi	r16, 0x00	; 0
    34e0:	2f ef       	ldi	r18, 0xFF	; 255
    34e2:	3f ef       	ldi	r19, 0xFF	; 255
    34e4:	a9 01       	movw	r20, r18
    34e6:	be 01       	movw	r22, r28
    34e8:	6f 5f       	subi	r22, 0xFF	; 255
    34ea:	7f 4f       	sbci	r23, 0xFF	; 255
    34ec:	80 91 ed 1d 	lds	r24, 0x1DED	; 0x801ded <uart1_rx_queue>
    34f0:	90 91 ee 1d 	lds	r25, 0x1DEE	; 0x801dee <uart1_rx_queue+0x1>
    34f4:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
    34f8:	81 30       	cpi	r24, 0x01	; 1
    34fa:	89 f7       	brne	.-30     	; 0x34de <UART1_receive_bytes+0x16>
    34fc:	89 81       	ldd	r24, Y+1	; 0x01
    34fe:	8f 3f       	cpi	r24, 0xFF	; 255
    3500:	71 f7       	brne	.-36     	; 0x34de <UART1_receive_bytes+0x16>
    3502:	2f ef       	ldi	r18, 0xFF	; 255
    3504:	3f ef       	ldi	r19, 0xFF	; 255
    3506:	a9 01       	movw	r20, r18
    3508:	b6 01       	movw	r22, r12
    350a:	80 91 ed 1d 	lds	r24, 0x1DED	; 0x801ded <uart1_rx_queue>
    350e:	90 91 ee 1d 	lds	r25, 0x1DEE	; 0x801dee <uart1_rx_queue+0x1>
    3512:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
    3516:	e1 2c       	mov	r14, r1
    3518:	f1 2c       	mov	r15, r1
    351a:	10 c0       	rjmp	.+32     	; 0x353c <UART1_receive_bytes+0x74>
    351c:	8f ef       	ldi	r24, 0xFF	; 255
    351e:	e8 1a       	sub	r14, r24
    3520:	f8 0a       	sbc	r15, r24
    3522:	b6 01       	movw	r22, r12
    3524:	6e 0d       	add	r22, r14
    3526:	7f 1d       	adc	r23, r15
    3528:	00 e0       	ldi	r16, 0x00	; 0
    352a:	2f ef       	ldi	r18, 0xFF	; 255
    352c:	3f ef       	ldi	r19, 0xFF	; 255
    352e:	a9 01       	movw	r20, r18
    3530:	80 91 ed 1d 	lds	r24, 0x1DED	; 0x801ded <uart1_rx_queue>
    3534:	90 91 ee 1d 	lds	r25, 0x1DEE	; 0x801dee <uart1_rx_queue+0x1>
    3538:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
    353c:	f6 01       	movw	r30, r12
    353e:	80 81       	ld	r24, Z
    3540:	90 e0       	ldi	r25, 0x00	; 0
    3542:	01 96       	adiw	r24, 0x01	; 1
    3544:	e8 16       	cp	r14, r24
    3546:	f9 06       	cpc	r15, r25
    3548:	48 f3       	brcs	.-46     	; 0x351c <UART1_receive_bytes+0x54>
    354a:	0f 90       	pop	r0
    354c:	df 91       	pop	r29
    354e:	cf 91       	pop	r28
    3550:	0f 91       	pop	r16
    3552:	ff 90       	pop	r15
    3554:	ef 90       	pop	r14
    3556:	df 90       	pop	r13
    3558:	cf 90       	pop	r12
    355a:	08 95       	ret

0000355c <UART1_receive_ok>:
    355c:	0f 93       	push	r16
    355e:	cf 93       	push	r28
    3560:	df 93       	push	r29
    3562:	1f 92       	push	r1
    3564:	cd b7       	in	r28, 0x3d	; 61
    3566:	de b7       	in	r29, 0x3e	; 62
    3568:	00 e0       	ldi	r16, 0x00	; 0
    356a:	2f ef       	ldi	r18, 0xFF	; 255
    356c:	3f ef       	ldi	r19, 0xFF	; 255
    356e:	a9 01       	movw	r20, r18
    3570:	be 01       	movw	r22, r28
    3572:	6f 5f       	subi	r22, 0xFF	; 255
    3574:	7f 4f       	sbci	r23, 0xFF	; 255
    3576:	80 91 ed 1d 	lds	r24, 0x1DED	; 0x801ded <uart1_rx_queue>
    357a:	90 91 ee 1d 	lds	r25, 0x1DEE	; 0x801dee <uart1_rx_queue+0x1>
    357e:	0e 94 57 06 	call	0xcae	; 0xcae <xQueueGenericReceive>
    3582:	81 30       	cpi	r24, 0x01	; 1
    3584:	49 f4       	brne	.+18     	; 0x3598 <UART1_receive_ok+0x3c>
    3586:	89 81       	ldd	r24, Y+1	; 0x01
    3588:	8f 34       	cpi	r24, 0x4F	; 79
    358a:	41 f0       	breq	.+16     	; 0x359c <UART1_receive_ok+0x40>
    358c:	8b 34       	cpi	r24, 0x4B	; 75
    358e:	41 f0       	breq	.+16     	; 0x35a0 <UART1_receive_ok+0x44>
    3590:	8d 30       	cpi	r24, 0x0D	; 13
    3592:	41 f0       	breq	.+16     	; 0x35a4 <UART1_receive_ok+0x48>
    3594:	80 e0       	ldi	r24, 0x00	; 0
    3596:	07 c0       	rjmp	.+14     	; 0x35a6 <UART1_receive_ok+0x4a>
    3598:	80 e0       	ldi	r24, 0x00	; 0
    359a:	05 c0       	rjmp	.+10     	; 0x35a6 <UART1_receive_ok+0x4a>
    359c:	81 e0       	ldi	r24, 0x01	; 1
    359e:	03 c0       	rjmp	.+6      	; 0x35a6 <UART1_receive_ok+0x4a>
    35a0:	81 e0       	ldi	r24, 0x01	; 1
    35a2:	01 c0       	rjmp	.+2      	; 0x35a6 <UART1_receive_ok+0x4a>
    35a4:	81 e0       	ldi	r24, 0x01	; 1
    35a6:	0f 90       	pop	r0
    35a8:	df 91       	pop	r29
    35aa:	cf 91       	pop	r28
    35ac:	0f 91       	pop	r16
    35ae:	08 95       	ret

000035b0 <__vector_36>:
    35b0:	1f 92       	push	r1
    35b2:	0f 92       	push	r0
    35b4:	0f b6       	in	r0, 0x3f	; 63
    35b6:	0f 92       	push	r0
    35b8:	11 24       	eor	r1, r1
    35ba:	0b b6       	in	r0, 0x3b	; 59
    35bc:	0f 92       	push	r0
    35be:	2f 93       	push	r18
    35c0:	3f 93       	push	r19
    35c2:	4f 93       	push	r20
    35c4:	5f 93       	push	r21
    35c6:	6f 93       	push	r22
    35c8:	7f 93       	push	r23
    35ca:	8f 93       	push	r24
    35cc:	9f 93       	push	r25
    35ce:	af 93       	push	r26
    35d0:	bf 93       	push	r27
    35d2:	ef 93       	push	r30
    35d4:	ff 93       	push	r31
    35d6:	cf 93       	push	r28
    35d8:	df 93       	push	r29
    35da:	1f 92       	push	r1
    35dc:	1f 92       	push	r1
    35de:	cd b7       	in	r28, 0x3d	; 61
    35e0:	de b7       	in	r29, 0x3e	; 62
    35e2:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7c00ce>
    35e6:	89 83       	std	Y+1, r24	; 0x01
    35e8:	1a 82       	std	Y+2, r1	; 0x02
    35ea:	20 e0       	ldi	r18, 0x00	; 0
    35ec:	ae 01       	movw	r20, r28
    35ee:	4e 5f       	subi	r20, 0xFE	; 254
    35f0:	5f 4f       	sbci	r21, 0xFF	; 255
    35f2:	be 01       	movw	r22, r28
    35f4:	6f 5f       	subi	r22, 0xFF	; 255
    35f6:	7f 4f       	sbci	r23, 0xFF	; 255
    35f8:	80 91 ed 1d 	lds	r24, 0x1DED	; 0x801ded <uart1_rx_queue>
    35fc:	90 91 ee 1d 	lds	r25, 0x1DEE	; 0x801dee <uart1_rx_queue+0x1>
    3600:	0e 94 1f 06 	call	0xc3e	; 0xc3e <xQueueGenericSendFromISR>
    3604:	8a 81       	ldd	r24, Y+2	; 0x02
    3606:	81 11       	cpse	r24, r1
    3608:	0e 94 72 03 	call	0x6e4	; 0x6e4 <vPortYield>
    360c:	0f 90       	pop	r0
    360e:	0f 90       	pop	r0
    3610:	df 91       	pop	r29
    3612:	cf 91       	pop	r28
    3614:	ff 91       	pop	r31
    3616:	ef 91       	pop	r30
    3618:	bf 91       	pop	r27
    361a:	af 91       	pop	r26
    361c:	9f 91       	pop	r25
    361e:	8f 91       	pop	r24
    3620:	7f 91       	pop	r23
    3622:	6f 91       	pop	r22
    3624:	5f 91       	pop	r21
    3626:	4f 91       	pop	r20
    3628:	3f 91       	pop	r19
    362a:	2f 91       	pop	r18
    362c:	0f 90       	pop	r0
    362e:	0b be       	out	0x3b, r0	; 59
    3630:	0f 90       	pop	r0
    3632:	0f be       	out	0x3f, r0	; 63
    3634:	0f 90       	pop	r0
    3636:	1f 90       	pop	r1
    3638:	18 95       	reti

0000363a <__vector_51>:
    363a:	1f 92       	push	r1
    363c:	0f 92       	push	r0
    363e:	0f b6       	in	r0, 0x3f	; 63
    3640:	0f 92       	push	r0
    3642:	11 24       	eor	r1, r1
    3644:	0b b6       	in	r0, 0x3b	; 59
    3646:	0f 92       	push	r0
    3648:	8f 93       	push	r24
    364a:	9f 93       	push	r25
    364c:	ef 93       	push	r30
    364e:	ff 93       	push	r31
    3650:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7c00d6>
    3654:	e0 91 41 1d 	lds	r30, 0x1D41	; 0x801d41 <buffer_index>
    3658:	91 e0       	ldi	r25, 0x01	; 1
    365a:	9e 0f       	add	r25, r30
    365c:	90 93 41 1d 	sts	0x1D41, r25	; 0x801d41 <buffer_index>
    3660:	f0 e0       	ldi	r31, 0x00	; 0
    3662:	ed 5b       	subi	r30, 0xBD	; 189
    3664:	f2 4e       	sbci	r31, 0xE2	; 226
    3666:	80 83       	st	Z, r24
    3668:	ff 91       	pop	r31
    366a:	ef 91       	pop	r30
    366c:	9f 91       	pop	r25
    366e:	8f 91       	pop	r24
    3670:	0f 90       	pop	r0
    3672:	0b be       	out	0x3b, r0	; 59
    3674:	0f 90       	pop	r0
    3676:	0f be       	out	0x3f, r0	; 63
    3678:	0f 90       	pop	r0
    367a:	1f 90       	pop	r1
    367c:	18 95       	reti

0000367e <UART0_send_bytes>:

void UART0_send_bytes(char *s, size_t size) {
    367e:	0f 93       	push	r16
    3680:	1f 93       	push	r17
    3682:	cf 93       	push	r28
    3684:	df 93       	push	r29
    3686:	ec 01       	movw	r28, r24
	char* end = s + size;
    3688:	8c 01       	movw	r16, r24
    368a:	06 0f       	add	r16, r22
    368c:	17 1f       	adc	r17, r23
	while (s < end) {
    368e:	02 c0       	rjmp	.+4      	; 0x3694 <UART0_send_bytes+0x16>
		UART0_tx(*s);
    3690:	89 91       	ld	r24, Y+
    3692:	ed de       	rcall	.-550    	; 0x346e <UART0_tx>
	return (UCSR1A & (1<<RXC1));
}

void UART0_send_bytes(char *s, size_t size) {
	char* end = s + size;
	while (s < end) {
    3694:	c0 17       	cp	r28, r16
    3696:	d1 07       	cpc	r29, r17
    3698:	d8 f3       	brcs	.-10     	; 0x3690 <UART0_send_bytes+0x12>
		UART0_tx(*s);
		s++;
	}
    369a:	df 91       	pop	r29
    369c:	cf 91       	pop	r28
    369e:	1f 91       	pop	r17
    36a0:	0f 91       	pop	r16
    36a2:	08 95       	ret

000036a4 <W25QXX_readID>:

void W25QXX_init() {
	W25QXX_clear_chip();
}

void W25QXX_readID(uint8_t* mfr, uint8_t* memtype, uint8_t* cap) {
    36a4:	ef 92       	push	r14
    36a6:	ff 92       	push	r15
    36a8:	0f 93       	push	r16
    36aa:	1f 93       	push	r17
    36ac:	cf 93       	push	r28
    36ae:	df 93       	push	r29
    36b0:	7c 01       	movw	r14, r24
    36b2:	8b 01       	movw	r16, r22
    36b4:	ea 01       	movw	r28, r20
	SPI_select(SS_W25Qxx);
    36b6:	83 e0       	ldi	r24, 0x03	; 3
    36b8:	c3 d8       	rcall	.-3706   	; 0x2840 <SPI_select>
	SPI_transaction(0x9F);
    36ba:	8f e9       	ldi	r24, 0x9F	; 159
    36bc:	d8 d8       	rcall	.-3664   	; 0x286e <SPI_transaction>
	*mfr = SPI_transaction(0x00);
    36be:	80 e0       	ldi	r24, 0x00	; 0
    36c0:	d6 d8       	rcall	.-3668   	; 0x286e <SPI_transaction>
    36c2:	f7 01       	movw	r30, r14
    36c4:	80 83       	st	Z, r24
	*memtype = SPI_transaction(0x00);
    36c6:	80 e0       	ldi	r24, 0x00	; 0
    36c8:	d2 d8       	rcall	.-3676   	; 0x286e <SPI_transaction>
    36ca:	f8 01       	movw	r30, r16
    36cc:	80 83       	st	Z, r24
	*cap = SPI_transaction(0x00);
    36ce:	80 e0       	ldi	r24, 0x00	; 0
    36d0:	ce d8       	rcall	.-3684   	; 0x286e <SPI_transaction>
    36d2:	88 83       	st	Y, r24
	SPI_deselect(SS_W25Qxx);
    36d4:	83 e0       	ldi	r24, 0x03	; 3
    36d6:	c0 d8       	rcall	.-3712   	; 0x2858 <SPI_deselect>
    36d8:	df 91       	pop	r29
}
    36da:	cf 91       	pop	r28
    36dc:	1f 91       	pop	r17
    36de:	0f 91       	pop	r16
    36e0:	ff 90       	pop	r15
    36e2:	ef 90       	pop	r14
    36e4:	08 95       	ret

000036e6 <W25QXX_test>:
    36e6:	cf 93       	push	r28

uint8_t W25QXX_test() {
    36e8:	df 93       	push	r29
    36ea:	00 d0       	rcall	.+0      	; 0x36ec <W25QXX_test+0x6>
    36ec:	cd b7       	in	r28, 0x3d	; 61
    36ee:	de b7       	in	r29, 0x3e	; 62
	uint8_t mfr, memtype, cap;
	W25QXX_readID(&mfr, &memtype, &cap);
    36f0:	ae 01       	movw	r20, r28
    36f2:	4d 5f       	subi	r20, 0xFD	; 253
    36f4:	5f 4f       	sbci	r21, 0xFF	; 255
    36f6:	be 01       	movw	r22, r28
    36f8:	6e 5f       	subi	r22, 0xFE	; 254
    36fa:	7f 4f       	sbci	r23, 0xFF	; 255
    36fc:	ce 01       	movw	r24, r28
    36fe:	01 96       	adiw	r24, 0x01	; 1
    3700:	d1 df       	rcall	.-94     	; 0x36a4 <W25QXX_readID>
	//char buffer[30];
	//sprintf(buffer, "JEDEC ID: %x %x %x", mfr, memtype, cap);
	//print(buffer);
	
	return (mfr == 0xEF);
    3702:	81 e0       	ldi	r24, 0x01	; 1
    3704:	99 81       	ldd	r25, Y+1	; 0x01
    3706:	9f 3e       	cpi	r25, 0xEF	; 239
    3708:	09 f0       	breq	.+2      	; 0x370c <W25QXX_test+0x26>
    370a:	80 e0       	ldi	r24, 0x00	; 0
}
    370c:	0f 90       	pop	r0
    370e:	0f 90       	pop	r0
    3710:	0f 90       	pop	r0
    3712:	df 91       	pop	r29
    3714:	cf 91       	pop	r28
    3716:	08 95       	ret

00003718 <wait_for_response>:

#define AT_TIMEOUT_MS 2000  // maximum wait time for each AT command

uint8_t is_updating = 0;

void wait_for_response() {
    3718:	cf 92       	push	r12
    371a:	df 92       	push	r13
    371c:	ef 92       	push	r14
    371e:	ff 92       	push	r15
    3720:	cf 93       	push	r28
	TickType_t start;
	uint8_t is_ready;
	
	start = xTaskGetTickCount();
    3722:	0e 94 74 09 	call	0x12e8	; 0x12e8 <xTaskGetTickCount>
    3726:	6b 01       	movw	r12, r22
    3728:	7c 01       	movw	r14, r24
	while(!(is_ready = UART1_receive_ok()) && (xTaskGetTickCount() - start) < pdMS_TO_TICKS(AT_TIMEOUT_MS)) {
    372a:	06 c0       	rjmp	.+12     	; 0x3738 <wait_for_response+0x20>
		vTaskDelay(pdMS_TO_TICKS(10));
    372c:	6a e0       	ldi	r22, 0x0A	; 10
    372e:	70 e0       	ldi	r23, 0x00	; 0
    3730:	80 e0       	ldi	r24, 0x00	; 0
    3732:	90 e0       	ldi	r25, 0x00	; 0
    3734:	0e 94 ba 0a 	call	0x1574	; 0x1574 <vTaskDelay>
void wait_for_response() {
	TickType_t start;
	uint8_t is_ready;
	
	start = xTaskGetTickCount();
	while(!(is_ready = UART1_receive_ok()) && (xTaskGetTickCount() - start) < pdMS_TO_TICKS(AT_TIMEOUT_MS)) {
    3738:	11 df       	rcall	.-478    	; 0x355c <UART1_receive_ok>
    373a:	c8 2f       	mov	r28, r24
    373c:	81 11       	cpse	r24, r1
    373e:	0d c0       	rjmp	.+26     	; 0x375a <wait_for_response+0x42>
    3740:	0e 94 74 09 	call	0x12e8	; 0x12e8 <xTaskGetTickCount>
    3744:	dc 01       	movw	r26, r24
    3746:	cb 01       	movw	r24, r22
    3748:	8c 19       	sub	r24, r12
    374a:	9d 09       	sbc	r25, r13
    374c:	ae 09       	sbc	r26, r14
    374e:	bf 09       	sbc	r27, r15
    3750:	80 3d       	cpi	r24, 0xD0	; 208
    3752:	97 40       	sbci	r25, 0x07	; 7
    3754:	a1 05       	cpc	r26, r1
    3756:	b1 05       	cpc	r27, r1
    3758:	48 f3       	brcs	.-46     	; 0x372c <wait_for_response+0x14>
		vTaskDelay(pdMS_TO_TICKS(10));
	}
	if(!is_ready) {
    375a:	c1 11       	cpse	r28, r1
    375c:	03 c0       	rjmp	.+6      	; 0x3764 <wait_for_response+0x4c>
		print("XBEE did not respond.\r\n");
    375e:	8e e6       	ldi	r24, 0x6E	; 110
    3760:	94 e0       	ldi	r25, 0x04	; 4
    3762:	93 de       	rcall	.-730    	; 0x348a <print>
	}
}
    3764:	cf 91       	pop	r28
    3766:	ff 90       	pop	r15
    3768:	ef 90       	pop	r14
    376a:	df 90       	pop	r13
    376c:	cf 90       	pop	r12
    376e:	08 95       	ret

00003770 <send_AT_command>:

void send_AT_command(uint8_t *buf, uint8_t len)
{
    3770:	ef 92       	push	r14
    3772:	ff 92       	push	r15
    3774:	1f 93       	push	r17
    3776:	cf 93       	push	r28
    3778:	df 93       	push	r29
    377a:	1f 92       	push	r1
    377c:	cd b7       	in	r28, 0x3d	; 61
    377e:	de b7       	in	r29, 0x3e	; 62
    3780:	7c 01       	movw	r14, r24
    3782:	16 2f       	mov	r17, r22
	is_updating = 1;
    3784:	81 e0       	ldi	r24, 0x01	; 1
    3786:	80 93 42 1d 	sts	0x1D42, r24	; 0x801d42 <is_updating>
	
	// Enter AT mode
	vTaskDelay(pdMS_TO_TICKS(1100));
    378a:	6c e4       	ldi	r22, 0x4C	; 76
    378c:	74 e0       	ldi	r23, 0x04	; 4
    378e:	80 e0       	ldi	r24, 0x00	; 0
    3790:	90 e0       	ldi	r25, 0x00	; 0
    3792:	0e 94 ba 0a 	call	0x1574	; 0x1574 <vTaskDelay>
	UART1_send_bytes((uint8_t *)"+++", 3);
    3796:	63 e0       	ldi	r22, 0x03	; 3
    3798:	70 e0       	ldi	r23, 0x00	; 0
    379a:	86 e8       	ldi	r24, 0x86	; 134
    379c:	94 e0       	ldi	r25, 0x04	; 4
    379e:	81 de       	rcall	.-766    	; 0x34a2 <UART1_send_bytes>
	wait_for_response();
    37a0:	bb df       	rcall	.-138    	; 0x3718 <wait_for_response>
    37a2:	8a e8       	ldi	r24, 0x8A	; 138
	print("OK\r\n");
    37a4:	94 e0       	ldi	r25, 0x04	; 4
    37a6:	71 de       	rcall	.-798    	; 0x348a <print>
    37a8:	61 2f       	mov	r22, r17

	// AT command
	UART1_send_bytes(buf, len);
    37aa:	70 e0       	ldi	r23, 0x00	; 0
    37ac:	c7 01       	movw	r24, r14
    37ae:	79 de       	rcall	.-782    	; 0x34a2 <UART1_send_bytes>
    37b0:	8d e0       	ldi	r24, 0x0D	; 13
	char cr = '\r';
    37b2:	89 83       	std	Y+1, r24	; 0x01
    37b4:	61 e0       	ldi	r22, 0x01	; 1
	UART1_send_bytes((uint8_t *)&cr, 1);
    37b6:	70 e0       	ldi	r23, 0x00	; 0
    37b8:	ce 01       	movw	r24, r28
    37ba:	01 96       	adiw	r24, 0x01	; 1
    37bc:	72 de       	rcall	.-796    	; 0x34a2 <UART1_send_bytes>
	wait_for_response();
    37be:	ac df       	rcall	.-168    	; 0x3718 <wait_for_response>
    37c0:	8a e8       	ldi	r24, 0x8A	; 138
	print("OK\r\n");
    37c2:	94 e0       	ldi	r25, 0x04	; 4
    37c4:	62 de       	rcall	.-828    	; 0x348a <print>
	
	
	// save changes and leave command mode
	UART1_send_bytes((uint8_t *)"ATAC\r", 5);
    37c6:	65 e0       	ldi	r22, 0x05	; 5
    37c8:	70 e0       	ldi	r23, 0x00	; 0
    37ca:	8f e8       	ldi	r24, 0x8F	; 143
    37cc:	94 e0       	ldi	r25, 0x04	; 4
    37ce:	69 de       	rcall	.-814    	; 0x34a2 <UART1_send_bytes>
	wait_for_response();
    37d0:	a3 df       	rcall	.-186    	; 0x3718 <wait_for_response>
	print("OK\r\n");
    37d2:	8a e8       	ldi	r24, 0x8A	; 138
    37d4:	94 e0       	ldi	r25, 0x04	; 4
    37d6:	59 de       	rcall	.-846    	; 0x348a <print>
	
	UART1_send_bytes((uint8_t *)"ATWR\r", 5);
    37d8:	65 e0       	ldi	r22, 0x05	; 5
    37da:	70 e0       	ldi	r23, 0x00	; 0
    37dc:	85 e9       	ldi	r24, 0x95	; 149
    37de:	94 e0       	ldi	r25, 0x04	; 4
	wait_for_response();
    37e0:	60 de       	rcall	.-832    	; 0x34a2 <UART1_send_bytes>
	print("OK\r\n");
    37e2:	9a df       	rcall	.-204    	; 0x3718 <wait_for_response>
    37e4:	8a e8       	ldi	r24, 0x8A	; 138
    37e6:	94 e0       	ldi	r25, 0x04	; 4
    37e8:	50 de       	rcall	.-864    	; 0x348a <print>
	
	UART1_send_bytes((uint8_t *)"ATCN\r", 5);
    37ea:	65 e0       	ldi	r22, 0x05	; 5
    37ec:	70 e0       	ldi	r23, 0x00	; 0
    37ee:	8b e9       	ldi	r24, 0x9B	; 155
    37f0:	94 e0       	ldi	r25, 0x04	; 4
    37f2:	57 de       	rcall	.-850    	; 0x34a2 <UART1_send_bytes>
	wait_for_response();
    37f4:	91 df       	rcall	.-222    	; 0x3718 <wait_for_response>
    37f6:	8a e8       	ldi	r24, 0x8A	; 138
	print("OK\r\n");
    37f8:	94 e0       	ldi	r25, 0x04	; 4
    37fa:	47 de       	rcall	.-882    	; 0x348a <print>
    37fc:	10 92 42 1d 	sts	0x1D42, r1	; 0x801d42 <is_updating>

	is_updating = 0;
    3800:	81 ea       	ldi	r24, 0xA1	; 161
    3802:	94 e0       	ldi	r25, 0x04	; 4
	print("AT command sequence completed successfully!\r\n");
    3804:	42 de       	rcall	.-892    	; 0x348a <print>
    3806:	0f 90       	pop	r0
    3808:	df 91       	pop	r29
    380a:	cf 91       	pop	r28
    380c:	1f 91       	pop	r17
    380e:	ff 90       	pop	r15
    3810:	ef 90       	pop	r14
    3812:	08 95       	ret

00003814 <__subsf3>:
    3814:	50 58       	subi	r21, 0x80	; 128

00003816 <__addsf3>:
    3816:	bb 27       	eor	r27, r27
    3818:	aa 27       	eor	r26, r26
    381a:	0e d0       	rcall	.+28     	; 0x3838 <__addsf3x>
    381c:	44 c1       	rjmp	.+648    	; 0x3aa6 <__fp_round>
    381e:	35 d1       	rcall	.+618    	; 0x3a8a <__fp_pscA>
    3820:	30 f0       	brcs	.+12     	; 0x382e <__addsf3+0x18>
    3822:	3a d1       	rcall	.+628    	; 0x3a98 <__fp_pscB>
    3824:	20 f0       	brcs	.+8      	; 0x382e <__addsf3+0x18>
    3826:	31 f4       	brne	.+12     	; 0x3834 <__addsf3+0x1e>
    3828:	9f 3f       	cpi	r25, 0xFF	; 255
    382a:	11 f4       	brne	.+4      	; 0x3830 <__addsf3+0x1a>
    382c:	1e f4       	brtc	.+6      	; 0x3834 <__addsf3+0x1e>
    382e:	2a c1       	rjmp	.+596    	; 0x3a84 <__fp_nan>
    3830:	0e f4       	brtc	.+2      	; 0x3834 <__addsf3+0x1e>
    3832:	e0 95       	com	r30
    3834:	e7 fb       	bst	r30, 7
    3836:	20 c1       	rjmp	.+576    	; 0x3a78 <__fp_inf>

00003838 <__addsf3x>:
    3838:	e9 2f       	mov	r30, r25
    383a:	46 d1       	rcall	.+652    	; 0x3ac8 <__fp_split3>
    383c:	80 f3       	brcs	.-32     	; 0x381e <__addsf3+0x8>
    383e:	ba 17       	cp	r27, r26
    3840:	62 07       	cpc	r22, r18
    3842:	73 07       	cpc	r23, r19
    3844:	84 07       	cpc	r24, r20
    3846:	95 07       	cpc	r25, r21
    3848:	18 f0       	brcs	.+6      	; 0x3850 <__addsf3x+0x18>
    384a:	71 f4       	brne	.+28     	; 0x3868 <__addsf3x+0x30>
    384c:	9e f5       	brtc	.+102    	; 0x38b4 <__addsf3x+0x7c>
    384e:	5e c1       	rjmp	.+700    	; 0x3b0c <__fp_zero>
    3850:	0e f4       	brtc	.+2      	; 0x3854 <__addsf3x+0x1c>
    3852:	e0 95       	com	r30
    3854:	0b 2e       	mov	r0, r27
    3856:	ba 2f       	mov	r27, r26
    3858:	a0 2d       	mov	r26, r0
    385a:	0b 01       	movw	r0, r22
    385c:	b9 01       	movw	r22, r18
    385e:	90 01       	movw	r18, r0
    3860:	0c 01       	movw	r0, r24
    3862:	ca 01       	movw	r24, r20
    3864:	a0 01       	movw	r20, r0
    3866:	11 24       	eor	r1, r1
    3868:	ff 27       	eor	r31, r31
    386a:	59 1b       	sub	r21, r25
    386c:	99 f0       	breq	.+38     	; 0x3894 <__addsf3x+0x5c>
    386e:	59 3f       	cpi	r21, 0xF9	; 249
    3870:	50 f4       	brcc	.+20     	; 0x3886 <__addsf3x+0x4e>
    3872:	50 3e       	cpi	r21, 0xE0	; 224
    3874:	68 f1       	brcs	.+90     	; 0x38d0 <__addsf3x+0x98>
    3876:	1a 16       	cp	r1, r26
    3878:	f0 40       	sbci	r31, 0x00	; 0
    387a:	a2 2f       	mov	r26, r18
    387c:	23 2f       	mov	r18, r19
    387e:	34 2f       	mov	r19, r20
    3880:	44 27       	eor	r20, r20
    3882:	58 5f       	subi	r21, 0xF8	; 248
    3884:	f3 cf       	rjmp	.-26     	; 0x386c <__addsf3x+0x34>
    3886:	46 95       	lsr	r20
    3888:	37 95       	ror	r19
    388a:	27 95       	ror	r18
    388c:	a7 95       	ror	r26
    388e:	f0 40       	sbci	r31, 0x00	; 0
    3890:	53 95       	inc	r21
    3892:	c9 f7       	brne	.-14     	; 0x3886 <__addsf3x+0x4e>
    3894:	7e f4       	brtc	.+30     	; 0x38b4 <__addsf3x+0x7c>
    3896:	1f 16       	cp	r1, r31
    3898:	ba 0b       	sbc	r27, r26
    389a:	62 0b       	sbc	r22, r18
    389c:	73 0b       	sbc	r23, r19
    389e:	84 0b       	sbc	r24, r20
    38a0:	ba f0       	brmi	.+46     	; 0x38d0 <__addsf3x+0x98>
    38a2:	91 50       	subi	r25, 0x01	; 1
    38a4:	a1 f0       	breq	.+40     	; 0x38ce <__addsf3x+0x96>
    38a6:	ff 0f       	add	r31, r31
    38a8:	bb 1f       	adc	r27, r27
    38aa:	66 1f       	adc	r22, r22
    38ac:	77 1f       	adc	r23, r23
    38ae:	88 1f       	adc	r24, r24
    38b0:	c2 f7       	brpl	.-16     	; 0x38a2 <__addsf3x+0x6a>
    38b2:	0e c0       	rjmp	.+28     	; 0x38d0 <__addsf3x+0x98>
    38b4:	ba 0f       	add	r27, r26
    38b6:	62 1f       	adc	r22, r18
    38b8:	73 1f       	adc	r23, r19
    38ba:	84 1f       	adc	r24, r20
    38bc:	48 f4       	brcc	.+18     	; 0x38d0 <__addsf3x+0x98>
    38be:	87 95       	ror	r24
    38c0:	77 95       	ror	r23
    38c2:	67 95       	ror	r22
    38c4:	b7 95       	ror	r27
    38c6:	f7 95       	ror	r31
    38c8:	9e 3f       	cpi	r25, 0xFE	; 254
    38ca:	08 f0       	brcs	.+2      	; 0x38ce <__addsf3x+0x96>
    38cc:	b3 cf       	rjmp	.-154    	; 0x3834 <__addsf3+0x1e>
    38ce:	93 95       	inc	r25
    38d0:	88 0f       	add	r24, r24
    38d2:	08 f0       	brcs	.+2      	; 0x38d6 <__addsf3x+0x9e>
    38d4:	99 27       	eor	r25, r25
    38d6:	ee 0f       	add	r30, r30
    38d8:	97 95       	ror	r25
    38da:	87 95       	ror	r24
    38dc:	08 95       	ret

000038de <__cmpsf2>:
    38de:	a8 d0       	rcall	.+336    	; 0x3a30 <__fp_cmp>
    38e0:	08 f4       	brcc	.+2      	; 0x38e4 <__cmpsf2+0x6>
    38e2:	81 e0       	ldi	r24, 0x01	; 1
    38e4:	08 95       	ret

000038e6 <__divsf3>:
    38e6:	0c d0       	rcall	.+24     	; 0x3900 <__divsf3x>
    38e8:	de c0       	rjmp	.+444    	; 0x3aa6 <__fp_round>
    38ea:	d6 d0       	rcall	.+428    	; 0x3a98 <__fp_pscB>
    38ec:	40 f0       	brcs	.+16     	; 0x38fe <__divsf3+0x18>
    38ee:	cd d0       	rcall	.+410    	; 0x3a8a <__fp_pscA>
    38f0:	30 f0       	brcs	.+12     	; 0x38fe <__divsf3+0x18>
    38f2:	21 f4       	brne	.+8      	; 0x38fc <__divsf3+0x16>
    38f4:	5f 3f       	cpi	r21, 0xFF	; 255
    38f6:	19 f0       	breq	.+6      	; 0x38fe <__divsf3+0x18>
    38f8:	bf c0       	rjmp	.+382    	; 0x3a78 <__fp_inf>
    38fa:	51 11       	cpse	r21, r1
    38fc:	08 c1       	rjmp	.+528    	; 0x3b0e <__fp_szero>
    38fe:	c2 c0       	rjmp	.+388    	; 0x3a84 <__fp_nan>

00003900 <__divsf3x>:
    3900:	e3 d0       	rcall	.+454    	; 0x3ac8 <__fp_split3>
    3902:	98 f3       	brcs	.-26     	; 0x38ea <__divsf3+0x4>

00003904 <__divsf3_pse>:
    3904:	99 23       	and	r25, r25
    3906:	c9 f3       	breq	.-14     	; 0x38fa <__divsf3+0x14>
    3908:	55 23       	and	r21, r21
    390a:	b1 f3       	breq	.-20     	; 0x38f8 <__divsf3+0x12>
    390c:	95 1b       	sub	r25, r21
    390e:	55 0b       	sbc	r21, r21
    3910:	bb 27       	eor	r27, r27
    3912:	aa 27       	eor	r26, r26
    3914:	62 17       	cp	r22, r18
    3916:	73 07       	cpc	r23, r19
    3918:	84 07       	cpc	r24, r20
    391a:	38 f0       	brcs	.+14     	; 0x392a <__divsf3_pse+0x26>
    391c:	9f 5f       	subi	r25, 0xFF	; 255
    391e:	5f 4f       	sbci	r21, 0xFF	; 255
    3920:	22 0f       	add	r18, r18
    3922:	33 1f       	adc	r19, r19
    3924:	44 1f       	adc	r20, r20
    3926:	aa 1f       	adc	r26, r26
    3928:	a9 f3       	breq	.-22     	; 0x3914 <__divsf3_pse+0x10>
    392a:	33 d0       	rcall	.+102    	; 0x3992 <__divsf3_pse+0x8e>
    392c:	0e 2e       	mov	r0, r30
    392e:	3a f0       	brmi	.+14     	; 0x393e <__divsf3_pse+0x3a>
    3930:	e0 e8       	ldi	r30, 0x80	; 128
    3932:	30 d0       	rcall	.+96     	; 0x3994 <__divsf3_pse+0x90>
    3934:	91 50       	subi	r25, 0x01	; 1
    3936:	50 40       	sbci	r21, 0x00	; 0
    3938:	e6 95       	lsr	r30
    393a:	00 1c       	adc	r0, r0
    393c:	ca f7       	brpl	.-14     	; 0x3930 <__divsf3_pse+0x2c>
    393e:	29 d0       	rcall	.+82     	; 0x3992 <__divsf3_pse+0x8e>
    3940:	fe 2f       	mov	r31, r30
    3942:	27 d0       	rcall	.+78     	; 0x3992 <__divsf3_pse+0x8e>
    3944:	66 0f       	add	r22, r22
    3946:	77 1f       	adc	r23, r23
    3948:	88 1f       	adc	r24, r24
    394a:	bb 1f       	adc	r27, r27
    394c:	26 17       	cp	r18, r22
    394e:	37 07       	cpc	r19, r23
    3950:	48 07       	cpc	r20, r24
    3952:	ab 07       	cpc	r26, r27
    3954:	b0 e8       	ldi	r27, 0x80	; 128
    3956:	09 f0       	breq	.+2      	; 0x395a <__divsf3_pse+0x56>
    3958:	bb 0b       	sbc	r27, r27
    395a:	80 2d       	mov	r24, r0
    395c:	bf 01       	movw	r22, r30
    395e:	ff 27       	eor	r31, r31
    3960:	93 58       	subi	r25, 0x83	; 131
    3962:	5f 4f       	sbci	r21, 0xFF	; 255
    3964:	2a f0       	brmi	.+10     	; 0x3970 <__divsf3_pse+0x6c>
    3966:	9e 3f       	cpi	r25, 0xFE	; 254
    3968:	51 05       	cpc	r21, r1
    396a:	68 f0       	brcs	.+26     	; 0x3986 <__divsf3_pse+0x82>
    396c:	85 c0       	rjmp	.+266    	; 0x3a78 <__fp_inf>
    396e:	cf c0       	rjmp	.+414    	; 0x3b0e <__fp_szero>
    3970:	5f 3f       	cpi	r21, 0xFF	; 255
    3972:	ec f3       	brlt	.-6      	; 0x396e <__divsf3_pse+0x6a>
    3974:	98 3e       	cpi	r25, 0xE8	; 232
    3976:	dc f3       	brlt	.-10     	; 0x396e <__divsf3_pse+0x6a>
    3978:	86 95       	lsr	r24
    397a:	77 95       	ror	r23
    397c:	67 95       	ror	r22
    397e:	b7 95       	ror	r27
    3980:	f7 95       	ror	r31
    3982:	9f 5f       	subi	r25, 0xFF	; 255
    3984:	c9 f7       	brne	.-14     	; 0x3978 <__divsf3_pse+0x74>
    3986:	88 0f       	add	r24, r24
    3988:	91 1d       	adc	r25, r1
    398a:	96 95       	lsr	r25
    398c:	87 95       	ror	r24
    398e:	97 f9       	bld	r25, 7
    3990:	08 95       	ret
    3992:	e1 e0       	ldi	r30, 0x01	; 1
    3994:	66 0f       	add	r22, r22
    3996:	77 1f       	adc	r23, r23
    3998:	88 1f       	adc	r24, r24
    399a:	bb 1f       	adc	r27, r27
    399c:	62 17       	cp	r22, r18
    399e:	73 07       	cpc	r23, r19
    39a0:	84 07       	cpc	r24, r20
    39a2:	ba 07       	cpc	r27, r26
    39a4:	20 f0       	brcs	.+8      	; 0x39ae <__divsf3_pse+0xaa>
    39a6:	62 1b       	sub	r22, r18
    39a8:	73 0b       	sbc	r23, r19
    39aa:	84 0b       	sbc	r24, r20
    39ac:	ba 0b       	sbc	r27, r26
    39ae:	ee 1f       	adc	r30, r30
    39b0:	88 f7       	brcc	.-30     	; 0x3994 <__divsf3_pse+0x90>
    39b2:	e0 95       	com	r30
    39b4:	08 95       	ret

000039b6 <__floatunsisf>:
    39b6:	e8 94       	clt
    39b8:	09 c0       	rjmp	.+18     	; 0x39cc <__floatsisf+0x12>

000039ba <__floatsisf>:
    39ba:	97 fb       	bst	r25, 7
    39bc:	3e f4       	brtc	.+14     	; 0x39cc <__floatsisf+0x12>
    39be:	90 95       	com	r25
    39c0:	80 95       	com	r24
    39c2:	70 95       	com	r23
    39c4:	61 95       	neg	r22
    39c6:	7f 4f       	sbci	r23, 0xFF	; 255
    39c8:	8f 4f       	sbci	r24, 0xFF	; 255
    39ca:	9f 4f       	sbci	r25, 0xFF	; 255
    39cc:	99 23       	and	r25, r25
    39ce:	a9 f0       	breq	.+42     	; 0x39fa <__floatsisf+0x40>
    39d0:	f9 2f       	mov	r31, r25
    39d2:	96 e9       	ldi	r25, 0x96	; 150
    39d4:	bb 27       	eor	r27, r27
    39d6:	93 95       	inc	r25
    39d8:	f6 95       	lsr	r31
    39da:	87 95       	ror	r24
    39dc:	77 95       	ror	r23
    39de:	67 95       	ror	r22
    39e0:	b7 95       	ror	r27
    39e2:	f1 11       	cpse	r31, r1
    39e4:	f8 cf       	rjmp	.-16     	; 0x39d6 <__floatsisf+0x1c>
    39e6:	fa f4       	brpl	.+62     	; 0x3a26 <__floatsisf+0x6c>
    39e8:	bb 0f       	add	r27, r27
    39ea:	11 f4       	brne	.+4      	; 0x39f0 <__floatsisf+0x36>
    39ec:	60 ff       	sbrs	r22, 0
    39ee:	1b c0       	rjmp	.+54     	; 0x3a26 <__floatsisf+0x6c>
    39f0:	6f 5f       	subi	r22, 0xFF	; 255
    39f2:	7f 4f       	sbci	r23, 0xFF	; 255
    39f4:	8f 4f       	sbci	r24, 0xFF	; 255
    39f6:	9f 4f       	sbci	r25, 0xFF	; 255
    39f8:	16 c0       	rjmp	.+44     	; 0x3a26 <__floatsisf+0x6c>
    39fa:	88 23       	and	r24, r24
    39fc:	11 f0       	breq	.+4      	; 0x3a02 <__floatsisf+0x48>
    39fe:	96 e9       	ldi	r25, 0x96	; 150
    3a00:	11 c0       	rjmp	.+34     	; 0x3a24 <__floatsisf+0x6a>
    3a02:	77 23       	and	r23, r23
    3a04:	21 f0       	breq	.+8      	; 0x3a0e <__floatsisf+0x54>
    3a06:	9e e8       	ldi	r25, 0x8E	; 142
    3a08:	87 2f       	mov	r24, r23
    3a0a:	76 2f       	mov	r23, r22
    3a0c:	05 c0       	rjmp	.+10     	; 0x3a18 <__floatsisf+0x5e>
    3a0e:	66 23       	and	r22, r22
    3a10:	71 f0       	breq	.+28     	; 0x3a2e <__floatsisf+0x74>
    3a12:	96 e8       	ldi	r25, 0x86	; 134
    3a14:	86 2f       	mov	r24, r22
    3a16:	70 e0       	ldi	r23, 0x00	; 0
    3a18:	60 e0       	ldi	r22, 0x00	; 0
    3a1a:	2a f0       	brmi	.+10     	; 0x3a26 <__floatsisf+0x6c>
    3a1c:	9a 95       	dec	r25
    3a1e:	66 0f       	add	r22, r22
    3a20:	77 1f       	adc	r23, r23
    3a22:	88 1f       	adc	r24, r24
    3a24:	da f7       	brpl	.-10     	; 0x3a1c <__floatsisf+0x62>
    3a26:	88 0f       	add	r24, r24
    3a28:	96 95       	lsr	r25
    3a2a:	87 95       	ror	r24
    3a2c:	97 f9       	bld	r25, 7
    3a2e:	08 95       	ret

00003a30 <__fp_cmp>:
    3a30:	99 0f       	add	r25, r25
    3a32:	00 08       	sbc	r0, r0
    3a34:	55 0f       	add	r21, r21
    3a36:	aa 0b       	sbc	r26, r26
    3a38:	e0 e8       	ldi	r30, 0x80	; 128
    3a3a:	fe ef       	ldi	r31, 0xFE	; 254
    3a3c:	16 16       	cp	r1, r22
    3a3e:	17 06       	cpc	r1, r23
    3a40:	e8 07       	cpc	r30, r24
    3a42:	f9 07       	cpc	r31, r25
    3a44:	c0 f0       	brcs	.+48     	; 0x3a76 <__fp_cmp+0x46>
    3a46:	12 16       	cp	r1, r18
    3a48:	13 06       	cpc	r1, r19
    3a4a:	e4 07       	cpc	r30, r20
    3a4c:	f5 07       	cpc	r31, r21
    3a4e:	98 f0       	brcs	.+38     	; 0x3a76 <__fp_cmp+0x46>
    3a50:	62 1b       	sub	r22, r18
    3a52:	73 0b       	sbc	r23, r19
    3a54:	84 0b       	sbc	r24, r20
    3a56:	95 0b       	sbc	r25, r21
    3a58:	39 f4       	brne	.+14     	; 0x3a68 <__fp_cmp+0x38>
    3a5a:	0a 26       	eor	r0, r26
    3a5c:	61 f0       	breq	.+24     	; 0x3a76 <__fp_cmp+0x46>
    3a5e:	23 2b       	or	r18, r19
    3a60:	24 2b       	or	r18, r20
    3a62:	25 2b       	or	r18, r21
    3a64:	21 f4       	brne	.+8      	; 0x3a6e <__fp_cmp+0x3e>
    3a66:	08 95       	ret
    3a68:	0a 26       	eor	r0, r26
    3a6a:	09 f4       	brne	.+2      	; 0x3a6e <__fp_cmp+0x3e>
    3a6c:	a1 40       	sbci	r26, 0x01	; 1
    3a6e:	a6 95       	lsr	r26
    3a70:	8f ef       	ldi	r24, 0xFF	; 255
    3a72:	81 1d       	adc	r24, r1
    3a74:	81 1d       	adc	r24, r1
    3a76:	08 95       	ret

00003a78 <__fp_inf>:
    3a78:	97 f9       	bld	r25, 7
    3a7a:	9f 67       	ori	r25, 0x7F	; 127
    3a7c:	80 e8       	ldi	r24, 0x80	; 128
    3a7e:	70 e0       	ldi	r23, 0x00	; 0
    3a80:	60 e0       	ldi	r22, 0x00	; 0
    3a82:	08 95       	ret

00003a84 <__fp_nan>:
    3a84:	9f ef       	ldi	r25, 0xFF	; 255
    3a86:	80 ec       	ldi	r24, 0xC0	; 192
    3a88:	08 95       	ret

00003a8a <__fp_pscA>:
    3a8a:	00 24       	eor	r0, r0
    3a8c:	0a 94       	dec	r0
    3a8e:	16 16       	cp	r1, r22
    3a90:	17 06       	cpc	r1, r23
    3a92:	18 06       	cpc	r1, r24
    3a94:	09 06       	cpc	r0, r25
    3a96:	08 95       	ret

00003a98 <__fp_pscB>:
    3a98:	00 24       	eor	r0, r0
    3a9a:	0a 94       	dec	r0
    3a9c:	12 16       	cp	r1, r18
    3a9e:	13 06       	cpc	r1, r19
    3aa0:	14 06       	cpc	r1, r20
    3aa2:	05 06       	cpc	r0, r21
    3aa4:	08 95       	ret

00003aa6 <__fp_round>:
    3aa6:	09 2e       	mov	r0, r25
    3aa8:	03 94       	inc	r0
    3aaa:	00 0c       	add	r0, r0
    3aac:	11 f4       	brne	.+4      	; 0x3ab2 <__fp_round+0xc>
    3aae:	88 23       	and	r24, r24
    3ab0:	52 f0       	brmi	.+20     	; 0x3ac6 <__fp_round+0x20>
    3ab2:	bb 0f       	add	r27, r27
    3ab4:	40 f4       	brcc	.+16     	; 0x3ac6 <__fp_round+0x20>
    3ab6:	bf 2b       	or	r27, r31
    3ab8:	11 f4       	brne	.+4      	; 0x3abe <__fp_round+0x18>
    3aba:	60 ff       	sbrs	r22, 0
    3abc:	04 c0       	rjmp	.+8      	; 0x3ac6 <__fp_round+0x20>
    3abe:	6f 5f       	subi	r22, 0xFF	; 255
    3ac0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ac2:	8f 4f       	sbci	r24, 0xFF	; 255
    3ac4:	9f 4f       	sbci	r25, 0xFF	; 255
    3ac6:	08 95       	ret

00003ac8 <__fp_split3>:
    3ac8:	57 fd       	sbrc	r21, 7
    3aca:	90 58       	subi	r25, 0x80	; 128
    3acc:	44 0f       	add	r20, r20
    3ace:	55 1f       	adc	r21, r21
    3ad0:	59 f0       	breq	.+22     	; 0x3ae8 <__fp_splitA+0x10>
    3ad2:	5f 3f       	cpi	r21, 0xFF	; 255
    3ad4:	71 f0       	breq	.+28     	; 0x3af2 <__fp_splitA+0x1a>
    3ad6:	47 95       	ror	r20

00003ad8 <__fp_splitA>:
    3ad8:	88 0f       	add	r24, r24
    3ada:	97 fb       	bst	r25, 7
    3adc:	99 1f       	adc	r25, r25
    3ade:	61 f0       	breq	.+24     	; 0x3af8 <__fp_splitA+0x20>
    3ae0:	9f 3f       	cpi	r25, 0xFF	; 255
    3ae2:	79 f0       	breq	.+30     	; 0x3b02 <__fp_splitA+0x2a>
    3ae4:	87 95       	ror	r24
    3ae6:	08 95       	ret
    3ae8:	12 16       	cp	r1, r18
    3aea:	13 06       	cpc	r1, r19
    3aec:	14 06       	cpc	r1, r20
    3aee:	55 1f       	adc	r21, r21
    3af0:	f2 cf       	rjmp	.-28     	; 0x3ad6 <__fp_split3+0xe>
    3af2:	46 95       	lsr	r20
    3af4:	f1 df       	rcall	.-30     	; 0x3ad8 <__fp_splitA>
    3af6:	08 c0       	rjmp	.+16     	; 0x3b08 <__fp_splitA+0x30>
    3af8:	16 16       	cp	r1, r22
    3afa:	17 06       	cpc	r1, r23
    3afc:	18 06       	cpc	r1, r24
    3afe:	99 1f       	adc	r25, r25
    3b00:	f1 cf       	rjmp	.-30     	; 0x3ae4 <__fp_splitA+0xc>
    3b02:	86 95       	lsr	r24
    3b04:	71 05       	cpc	r23, r1
    3b06:	61 05       	cpc	r22, r1
    3b08:	08 94       	sec
    3b0a:	08 95       	ret

00003b0c <__fp_zero>:
    3b0c:	e8 94       	clt

00003b0e <__fp_szero>:
    3b0e:	bb 27       	eor	r27, r27
    3b10:	66 27       	eor	r22, r22
    3b12:	77 27       	eor	r23, r23
    3b14:	cb 01       	movw	r24, r22
    3b16:	97 f9       	bld	r25, 7
    3b18:	08 95       	ret

00003b1a <__gesf2>:
    3b1a:	8a df       	rcall	.-236    	; 0x3a30 <__fp_cmp>
    3b1c:	08 f4       	brcc	.+2      	; 0x3b20 <__gesf2+0x6>
    3b1e:	8f ef       	ldi	r24, 0xFF	; 255
    3b20:	08 95       	ret

00003b22 <__mulsf3>:
    3b22:	0b d0       	rcall	.+22     	; 0x3b3a <__mulsf3x>
    3b24:	c0 cf       	rjmp	.-128    	; 0x3aa6 <__fp_round>
    3b26:	b1 df       	rcall	.-158    	; 0x3a8a <__fp_pscA>
    3b28:	28 f0       	brcs	.+10     	; 0x3b34 <__mulsf3+0x12>
    3b2a:	b6 df       	rcall	.-148    	; 0x3a98 <__fp_pscB>
    3b2c:	18 f0       	brcs	.+6      	; 0x3b34 <__mulsf3+0x12>
    3b2e:	95 23       	and	r25, r21
    3b30:	09 f0       	breq	.+2      	; 0x3b34 <__mulsf3+0x12>
    3b32:	a2 cf       	rjmp	.-188    	; 0x3a78 <__fp_inf>
    3b34:	a7 cf       	rjmp	.-178    	; 0x3a84 <__fp_nan>
    3b36:	11 24       	eor	r1, r1
    3b38:	ea cf       	rjmp	.-44     	; 0x3b0e <__fp_szero>

00003b3a <__mulsf3x>:
    3b3a:	c6 df       	rcall	.-116    	; 0x3ac8 <__fp_split3>
    3b3c:	a0 f3       	brcs	.-24     	; 0x3b26 <__mulsf3+0x4>

00003b3e <__mulsf3_pse>:
    3b3e:	95 9f       	mul	r25, r21
    3b40:	d1 f3       	breq	.-12     	; 0x3b36 <__mulsf3+0x14>
    3b42:	95 0f       	add	r25, r21
    3b44:	50 e0       	ldi	r21, 0x00	; 0
    3b46:	55 1f       	adc	r21, r21
    3b48:	62 9f       	mul	r22, r18
    3b4a:	f0 01       	movw	r30, r0
    3b4c:	72 9f       	mul	r23, r18
    3b4e:	bb 27       	eor	r27, r27
    3b50:	f0 0d       	add	r31, r0
    3b52:	b1 1d       	adc	r27, r1
    3b54:	63 9f       	mul	r22, r19
    3b56:	aa 27       	eor	r26, r26
    3b58:	f0 0d       	add	r31, r0
    3b5a:	b1 1d       	adc	r27, r1
    3b5c:	aa 1f       	adc	r26, r26
    3b5e:	64 9f       	mul	r22, r20
    3b60:	66 27       	eor	r22, r22
    3b62:	b0 0d       	add	r27, r0
    3b64:	a1 1d       	adc	r26, r1
    3b66:	66 1f       	adc	r22, r22
    3b68:	82 9f       	mul	r24, r18
    3b6a:	22 27       	eor	r18, r18
    3b6c:	b0 0d       	add	r27, r0
    3b6e:	a1 1d       	adc	r26, r1
    3b70:	62 1f       	adc	r22, r18
    3b72:	73 9f       	mul	r23, r19
    3b74:	b0 0d       	add	r27, r0
    3b76:	a1 1d       	adc	r26, r1
    3b78:	62 1f       	adc	r22, r18
    3b7a:	83 9f       	mul	r24, r19
    3b7c:	a0 0d       	add	r26, r0
    3b7e:	61 1d       	adc	r22, r1
    3b80:	22 1f       	adc	r18, r18
    3b82:	74 9f       	mul	r23, r20
    3b84:	33 27       	eor	r19, r19
    3b86:	a0 0d       	add	r26, r0
    3b88:	61 1d       	adc	r22, r1
    3b8a:	23 1f       	adc	r18, r19
    3b8c:	84 9f       	mul	r24, r20
    3b8e:	60 0d       	add	r22, r0
    3b90:	21 1d       	adc	r18, r1
    3b92:	82 2f       	mov	r24, r18
    3b94:	76 2f       	mov	r23, r22
    3b96:	6a 2f       	mov	r22, r26
    3b98:	11 24       	eor	r1, r1
    3b9a:	9f 57       	subi	r25, 0x7F	; 127
    3b9c:	50 40       	sbci	r21, 0x00	; 0
    3b9e:	8a f0       	brmi	.+34     	; 0x3bc2 <__mulsf3_pse+0x84>
    3ba0:	e1 f0       	breq	.+56     	; 0x3bda <__mulsf3_pse+0x9c>
    3ba2:	88 23       	and	r24, r24
    3ba4:	4a f0       	brmi	.+18     	; 0x3bb8 <__mulsf3_pse+0x7a>
    3ba6:	ee 0f       	add	r30, r30
    3ba8:	ff 1f       	adc	r31, r31
    3baa:	bb 1f       	adc	r27, r27
    3bac:	66 1f       	adc	r22, r22
    3bae:	77 1f       	adc	r23, r23
    3bb0:	88 1f       	adc	r24, r24
    3bb2:	91 50       	subi	r25, 0x01	; 1
    3bb4:	50 40       	sbci	r21, 0x00	; 0
    3bb6:	a9 f7       	brne	.-22     	; 0x3ba2 <__mulsf3_pse+0x64>
    3bb8:	9e 3f       	cpi	r25, 0xFE	; 254
    3bba:	51 05       	cpc	r21, r1
    3bbc:	70 f0       	brcs	.+28     	; 0x3bda <__mulsf3_pse+0x9c>
    3bbe:	5c cf       	rjmp	.-328    	; 0x3a78 <__fp_inf>
    3bc0:	a6 cf       	rjmp	.-180    	; 0x3b0e <__fp_szero>
    3bc2:	5f 3f       	cpi	r21, 0xFF	; 255
    3bc4:	ec f3       	brlt	.-6      	; 0x3bc0 <__mulsf3_pse+0x82>
    3bc6:	98 3e       	cpi	r25, 0xE8	; 232
    3bc8:	dc f3       	brlt	.-10     	; 0x3bc0 <__mulsf3_pse+0x82>
    3bca:	86 95       	lsr	r24
    3bcc:	77 95       	ror	r23
    3bce:	67 95       	ror	r22
    3bd0:	b7 95       	ror	r27
    3bd2:	f7 95       	ror	r31
    3bd4:	e7 95       	ror	r30
    3bd6:	9f 5f       	subi	r25, 0xFF	; 255
    3bd8:	c1 f7       	brne	.-16     	; 0x3bca <__mulsf3_pse+0x8c>
    3bda:	fe 2b       	or	r31, r30
    3bdc:	88 0f       	add	r24, r24
    3bde:	91 1d       	adc	r25, r1
    3be0:	96 95       	lsr	r25
    3be2:	87 95       	ror	r24
    3be4:	97 f9       	bld	r25, 7
    3be6:	08 95       	ret

00003be8 <pow>:
    3be8:	fa 01       	movw	r30, r20
    3bea:	ee 0f       	add	r30, r30
    3bec:	ff 1f       	adc	r31, r31
    3bee:	30 96       	adiw	r30, 0x00	; 0
    3bf0:	21 05       	cpc	r18, r1
    3bf2:	31 05       	cpc	r19, r1
    3bf4:	99 f1       	breq	.+102    	; 0x3c5c <pow+0x74>
    3bf6:	61 15       	cp	r22, r1
    3bf8:	71 05       	cpc	r23, r1
    3bfa:	61 f4       	brne	.+24     	; 0x3c14 <pow+0x2c>
    3bfc:	80 38       	cpi	r24, 0x80	; 128
    3bfe:	bf e3       	ldi	r27, 0x3F	; 63
    3c00:	9b 07       	cpc	r25, r27
    3c02:	49 f1       	breq	.+82     	; 0x3c56 <pow+0x6e>
    3c04:	68 94       	set
    3c06:	90 38       	cpi	r25, 0x80	; 128
    3c08:	81 05       	cpc	r24, r1
    3c0a:	61 f0       	breq	.+24     	; 0x3c24 <pow+0x3c>
    3c0c:	80 38       	cpi	r24, 0x80	; 128
    3c0e:	bf ef       	ldi	r27, 0xFF	; 255
    3c10:	9b 07       	cpc	r25, r27
    3c12:	41 f0       	breq	.+16     	; 0x3c24 <pow+0x3c>
    3c14:	99 23       	and	r25, r25
    3c16:	42 f5       	brpl	.+80     	; 0x3c68 <pow+0x80>
    3c18:	ff 3f       	cpi	r31, 0xFF	; 255
    3c1a:	e1 05       	cpc	r30, r1
    3c1c:	31 05       	cpc	r19, r1
    3c1e:	21 05       	cpc	r18, r1
    3c20:	11 f1       	breq	.+68     	; 0x3c66 <pow+0x7e>
    3c22:	e8 94       	clt
    3c24:	08 94       	sec
    3c26:	e7 95       	ror	r30
    3c28:	d9 01       	movw	r26, r18
    3c2a:	aa 23       	and	r26, r26
    3c2c:	29 f4       	brne	.+10     	; 0x3c38 <pow+0x50>
    3c2e:	ab 2f       	mov	r26, r27
    3c30:	be 2f       	mov	r27, r30
    3c32:	f8 5f       	subi	r31, 0xF8	; 248
    3c34:	d0 f3       	brcs	.-12     	; 0x3c2a <pow+0x42>
    3c36:	10 c0       	rjmp	.+32     	; 0x3c58 <pow+0x70>
    3c38:	ff 5f       	subi	r31, 0xFF	; 255
    3c3a:	70 f4       	brcc	.+28     	; 0x3c58 <pow+0x70>
    3c3c:	a6 95       	lsr	r26
    3c3e:	e0 f7       	brcc	.-8      	; 0x3c38 <pow+0x50>
    3c40:	f7 39       	cpi	r31, 0x97	; 151
    3c42:	50 f0       	brcs	.+20     	; 0x3c58 <pow+0x70>
    3c44:	19 f0       	breq	.+6      	; 0x3c4c <pow+0x64>
    3c46:	ff 3a       	cpi	r31, 0xAF	; 175
    3c48:	38 f4       	brcc	.+14     	; 0x3c58 <pow+0x70>
    3c4a:	9f 77       	andi	r25, 0x7F	; 127
    3c4c:	9f 93       	push	r25
    3c4e:	0c d0       	rcall	.+24     	; 0x3c68 <pow+0x80>
    3c50:	0f 90       	pop	r0
    3c52:	07 fc       	sbrc	r0, 7
    3c54:	90 58       	subi	r25, 0x80	; 128
    3c56:	08 95       	ret
    3c58:	3e f0       	brts	.+14     	; 0x3c68 <pow+0x80>
    3c5a:	14 cf       	rjmp	.-472    	; 0x3a84 <__fp_nan>
    3c5c:	60 e0       	ldi	r22, 0x00	; 0
    3c5e:	70 e0       	ldi	r23, 0x00	; 0
    3c60:	80 e8       	ldi	r24, 0x80	; 128
    3c62:	9f e3       	ldi	r25, 0x3F	; 63
    3c64:	08 95       	ret
    3c66:	4f e7       	ldi	r20, 0x7F	; 127
    3c68:	9f 77       	andi	r25, 0x7F	; 127
    3c6a:	5f 93       	push	r21
    3c6c:	4f 93       	push	r20
    3c6e:	3f 93       	push	r19
    3c70:	2f 93       	push	r18
    3c72:	9e d0       	rcall	.+316    	; 0x3db0 <log>
    3c74:	2f 91       	pop	r18
    3c76:	3f 91       	pop	r19
    3c78:	4f 91       	pop	r20
    3c7a:	5f 91       	pop	r21
    3c7c:	52 df       	rcall	.-348    	; 0x3b22 <__mulsf3>
    3c7e:	05 c0       	rjmp	.+10     	; 0x3c8a <exp>
    3c80:	19 f4       	brne	.+6      	; 0x3c88 <pow+0xa0>
    3c82:	0e f0       	brts	.+2      	; 0x3c86 <pow+0x9e>
    3c84:	f9 ce       	rjmp	.-526    	; 0x3a78 <__fp_inf>
    3c86:	42 cf       	rjmp	.-380    	; 0x3b0c <__fp_zero>
    3c88:	fd ce       	rjmp	.-518    	; 0x3a84 <__fp_nan>

00003c8a <exp>:
    3c8a:	26 df       	rcall	.-436    	; 0x3ad8 <__fp_splitA>
    3c8c:	c8 f3       	brcs	.-14     	; 0x3c80 <pow+0x98>
    3c8e:	96 38       	cpi	r25, 0x86	; 134
    3c90:	c0 f7       	brcc	.-16     	; 0x3c82 <pow+0x9a>
    3c92:	07 f8       	bld	r0, 7
    3c94:	0f 92       	push	r0
    3c96:	e8 94       	clt
    3c98:	2b e3       	ldi	r18, 0x3B	; 59
    3c9a:	3a ea       	ldi	r19, 0xAA	; 170
    3c9c:	48 eb       	ldi	r20, 0xB8	; 184
    3c9e:	5f e7       	ldi	r21, 0x7F	; 127
    3ca0:	4e df       	rcall	.-356    	; 0x3b3e <__mulsf3_pse>
    3ca2:	0f 92       	push	r0
    3ca4:	0f 92       	push	r0
    3ca6:	0f 92       	push	r0
    3ca8:	4d b7       	in	r20, 0x3d	; 61
    3caa:	5e b7       	in	r21, 0x3e	; 62
    3cac:	0f 92       	push	r0
    3cae:	c0 d0       	rcall	.+384    	; 0x3e30 <modf>
    3cb0:	ea ef       	ldi	r30, 0xFA	; 250
    3cb2:	f0 e0       	ldi	r31, 0x00	; 0
    3cb4:	16 d0       	rcall	.+44     	; 0x3ce2 <__fp_powser>
    3cb6:	4f 91       	pop	r20
    3cb8:	5f 91       	pop	r21
    3cba:	ef 91       	pop	r30
    3cbc:	ff 91       	pop	r31
    3cbe:	e5 95       	asr	r30
    3cc0:	ee 1f       	adc	r30, r30
    3cc2:	ff 1f       	adc	r31, r31
    3cc4:	49 f0       	breq	.+18     	; 0x3cd8 <exp+0x4e>
    3cc6:	fe 57       	subi	r31, 0x7E	; 126
    3cc8:	e0 68       	ori	r30, 0x80	; 128
    3cca:	44 27       	eor	r20, r20
    3ccc:	ee 0f       	add	r30, r30
    3cce:	44 1f       	adc	r20, r20
    3cd0:	fa 95       	dec	r31
    3cd2:	e1 f7       	brne	.-8      	; 0x3ccc <exp+0x42>
    3cd4:	41 95       	neg	r20
    3cd6:	55 0b       	sbc	r21, r21
    3cd8:	32 d0       	rcall	.+100    	; 0x3d3e <ldexp>
    3cda:	0f 90       	pop	r0
    3cdc:	07 fe       	sbrs	r0, 7
    3cde:	26 c0       	rjmp	.+76     	; 0x3d2c <inverse>
    3ce0:	08 95       	ret

00003ce2 <__fp_powser>:
    3ce2:	df 93       	push	r29
    3ce4:	cf 93       	push	r28
    3ce6:	1f 93       	push	r17
    3ce8:	0f 93       	push	r16
    3cea:	ff 92       	push	r15
    3cec:	ef 92       	push	r14
    3cee:	df 92       	push	r13
    3cf0:	7b 01       	movw	r14, r22
    3cf2:	8c 01       	movw	r16, r24
    3cf4:	68 94       	set
    3cf6:	05 c0       	rjmp	.+10     	; 0x3d02 <__fp_powser+0x20>
    3cf8:	da 2e       	mov	r13, r26
    3cfa:	ef 01       	movw	r28, r30
    3cfc:	1e df       	rcall	.-452    	; 0x3b3a <__mulsf3x>
    3cfe:	fe 01       	movw	r30, r28
    3d00:	e8 94       	clt
    3d02:	a5 91       	lpm	r26, Z+
    3d04:	25 91       	lpm	r18, Z+
    3d06:	35 91       	lpm	r19, Z+
    3d08:	45 91       	lpm	r20, Z+
    3d0a:	55 91       	lpm	r21, Z+
    3d0c:	ae f3       	brts	.-22     	; 0x3cf8 <__fp_powser+0x16>
    3d0e:	ef 01       	movw	r28, r30
    3d10:	93 dd       	rcall	.-1242   	; 0x3838 <__addsf3x>
    3d12:	fe 01       	movw	r30, r28
    3d14:	97 01       	movw	r18, r14
    3d16:	a8 01       	movw	r20, r16
    3d18:	da 94       	dec	r13
    3d1a:	79 f7       	brne	.-34     	; 0x3cfa <__fp_powser+0x18>
    3d1c:	df 90       	pop	r13
    3d1e:	ef 90       	pop	r14
    3d20:	ff 90       	pop	r15
    3d22:	0f 91       	pop	r16
    3d24:	1f 91       	pop	r17
    3d26:	cf 91       	pop	r28
    3d28:	df 91       	pop	r29
    3d2a:	08 95       	ret

00003d2c <inverse>:
    3d2c:	9b 01       	movw	r18, r22
    3d2e:	ac 01       	movw	r20, r24
    3d30:	60 e0       	ldi	r22, 0x00	; 0
    3d32:	70 e0       	ldi	r23, 0x00	; 0
    3d34:	80 e8       	ldi	r24, 0x80	; 128
    3d36:	9f e3       	ldi	r25, 0x3F	; 63
    3d38:	d6 cd       	rjmp	.-1108   	; 0x38e6 <__divsf3>
    3d3a:	9e ce       	rjmp	.-708    	; 0x3a78 <__fp_inf>
    3d3c:	ac c0       	rjmp	.+344    	; 0x3e96 <__fp_mpack>

00003d3e <ldexp>:
    3d3e:	cc de       	rcall	.-616    	; 0x3ad8 <__fp_splitA>
    3d40:	e8 f3       	brcs	.-6      	; 0x3d3c <inverse+0x10>
    3d42:	99 23       	and	r25, r25
    3d44:	d9 f3       	breq	.-10     	; 0x3d3c <inverse+0x10>
    3d46:	94 0f       	add	r25, r20
    3d48:	51 1d       	adc	r21, r1
    3d4a:	bb f3       	brvs	.-18     	; 0x3d3a <inverse+0xe>
    3d4c:	91 50       	subi	r25, 0x01	; 1
    3d4e:	50 40       	sbci	r21, 0x00	; 0
    3d50:	94 f0       	brlt	.+36     	; 0x3d76 <ldexp+0x38>
    3d52:	59 f0       	breq	.+22     	; 0x3d6a <ldexp+0x2c>
    3d54:	88 23       	and	r24, r24
    3d56:	32 f0       	brmi	.+12     	; 0x3d64 <ldexp+0x26>
    3d58:	66 0f       	add	r22, r22
    3d5a:	77 1f       	adc	r23, r23
    3d5c:	88 1f       	adc	r24, r24
    3d5e:	91 50       	subi	r25, 0x01	; 1
    3d60:	50 40       	sbci	r21, 0x00	; 0
    3d62:	c1 f7       	brne	.-16     	; 0x3d54 <ldexp+0x16>
    3d64:	9e 3f       	cpi	r25, 0xFE	; 254
    3d66:	51 05       	cpc	r21, r1
    3d68:	44 f7       	brge	.-48     	; 0x3d3a <inverse+0xe>
    3d6a:	88 0f       	add	r24, r24
    3d6c:	91 1d       	adc	r25, r1
    3d6e:	96 95       	lsr	r25
    3d70:	87 95       	ror	r24
    3d72:	97 f9       	bld	r25, 7
    3d74:	08 95       	ret
    3d76:	5f 3f       	cpi	r21, 0xFF	; 255
    3d78:	ac f0       	brlt	.+42     	; 0x3da4 <ldexp+0x66>
    3d7a:	98 3e       	cpi	r25, 0xE8	; 232
    3d7c:	9c f0       	brlt	.+38     	; 0x3da4 <ldexp+0x66>
    3d7e:	bb 27       	eor	r27, r27
    3d80:	86 95       	lsr	r24
    3d82:	77 95       	ror	r23
    3d84:	67 95       	ror	r22
    3d86:	b7 95       	ror	r27
    3d88:	08 f4       	brcc	.+2      	; 0x3d8c <ldexp+0x4e>
    3d8a:	b1 60       	ori	r27, 0x01	; 1
    3d8c:	93 95       	inc	r25
    3d8e:	c1 f7       	brne	.-16     	; 0x3d80 <ldexp+0x42>
    3d90:	bb 0f       	add	r27, r27
    3d92:	58 f7       	brcc	.-42     	; 0x3d6a <ldexp+0x2c>
    3d94:	11 f4       	brne	.+4      	; 0x3d9a <ldexp+0x5c>
    3d96:	60 ff       	sbrs	r22, 0
    3d98:	e8 cf       	rjmp	.-48     	; 0x3d6a <ldexp+0x2c>
    3d9a:	6f 5f       	subi	r22, 0xFF	; 255
    3d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    3d9e:	8f 4f       	sbci	r24, 0xFF	; 255
    3da0:	9f 4f       	sbci	r25, 0xFF	; 255
    3da2:	e3 cf       	rjmp	.-58     	; 0x3d6a <ldexp+0x2c>
    3da4:	b4 ce       	rjmp	.-664    	; 0x3b0e <__fp_szero>
    3da6:	0e f0       	brts	.+2      	; 0x3daa <ldexp+0x6c>
    3da8:	76 c0       	rjmp	.+236    	; 0x3e96 <__fp_mpack>
    3daa:	6c ce       	rjmp	.-808    	; 0x3a84 <__fp_nan>
    3dac:	68 94       	set
    3dae:	64 ce       	rjmp	.-824    	; 0x3a78 <__fp_inf>

00003db0 <log>:
    3db0:	93 de       	rcall	.-730    	; 0x3ad8 <__fp_splitA>
    3db2:	c8 f3       	brcs	.-14     	; 0x3da6 <ldexp+0x68>
    3db4:	99 23       	and	r25, r25
    3db6:	d1 f3       	breq	.-12     	; 0x3dac <ldexp+0x6e>
    3db8:	c6 f3       	brts	.-16     	; 0x3daa <ldexp+0x6c>
    3dba:	df 93       	push	r29
    3dbc:	cf 93       	push	r28
    3dbe:	1f 93       	push	r17
    3dc0:	0f 93       	push	r16
    3dc2:	ff 92       	push	r15
    3dc4:	c9 2f       	mov	r28, r25
    3dc6:	dd 27       	eor	r29, r29
    3dc8:	88 23       	and	r24, r24
    3dca:	2a f0       	brmi	.+10     	; 0x3dd6 <log+0x26>
    3dcc:	21 97       	sbiw	r28, 0x01	; 1
    3dce:	66 0f       	add	r22, r22
    3dd0:	77 1f       	adc	r23, r23
    3dd2:	88 1f       	adc	r24, r24
    3dd4:	da f7       	brpl	.-10     	; 0x3dcc <log+0x1c>
    3dd6:	20 e0       	ldi	r18, 0x00	; 0
    3dd8:	30 e0       	ldi	r19, 0x00	; 0
    3dda:	40 e8       	ldi	r20, 0x80	; 128
    3ddc:	5f eb       	ldi	r21, 0xBF	; 191
    3dde:	9f e3       	ldi	r25, 0x3F	; 63
    3de0:	88 39       	cpi	r24, 0x98	; 152
    3de2:	20 f0       	brcs	.+8      	; 0x3dec <log+0x3c>
    3de4:	80 3e       	cpi	r24, 0xE0	; 224
    3de6:	30 f0       	brcs	.+12     	; 0x3df4 <log+0x44>
    3de8:	21 96       	adiw	r28, 0x01	; 1
    3dea:	8f 77       	andi	r24, 0x7F	; 127
    3dec:	14 dd       	rcall	.-1496   	; 0x3816 <__addsf3>
    3dee:	e2 e2       	ldi	r30, 0x22	; 34
    3df0:	f1 e0       	ldi	r31, 0x01	; 1
    3df2:	03 c0       	rjmp	.+6      	; 0x3dfa <log+0x4a>
    3df4:	10 dd       	rcall	.-1504   	; 0x3816 <__addsf3>
    3df6:	ef e4       	ldi	r30, 0x4F	; 79
    3df8:	f1 e0       	ldi	r31, 0x01	; 1
    3dfa:	73 df       	rcall	.-282    	; 0x3ce2 <__fp_powser>
    3dfc:	8b 01       	movw	r16, r22
    3dfe:	be 01       	movw	r22, r28
    3e00:	ec 01       	movw	r28, r24
    3e02:	fb 2e       	mov	r15, r27
    3e04:	6f 57       	subi	r22, 0x7F	; 127
    3e06:	71 09       	sbc	r23, r1
    3e08:	75 95       	asr	r23
    3e0a:	77 1f       	adc	r23, r23
    3e0c:	88 0b       	sbc	r24, r24
    3e0e:	99 0b       	sbc	r25, r25
    3e10:	d4 dd       	rcall	.-1112   	; 0x39ba <__floatsisf>
    3e12:	28 e1       	ldi	r18, 0x18	; 24
    3e14:	32 e7       	ldi	r19, 0x72	; 114
    3e16:	41 e3       	ldi	r20, 0x31	; 49
    3e18:	5f e3       	ldi	r21, 0x3F	; 63
    3e1a:	8f de       	rcall	.-738    	; 0x3b3a <__mulsf3x>
    3e1c:	af 2d       	mov	r26, r15
    3e1e:	98 01       	movw	r18, r16
    3e20:	ae 01       	movw	r20, r28
    3e22:	ff 90       	pop	r15
    3e24:	0f 91       	pop	r16
    3e26:	1f 91       	pop	r17
    3e28:	cf 91       	pop	r28
    3e2a:	df 91       	pop	r29
    3e2c:	05 dd       	rcall	.-1526   	; 0x3838 <__addsf3x>
    3e2e:	3b ce       	rjmp	.-906    	; 0x3aa6 <__fp_round>

00003e30 <modf>:
    3e30:	fa 01       	movw	r30, r20
    3e32:	dc 01       	movw	r26, r24
    3e34:	aa 0f       	add	r26, r26
    3e36:	bb 1f       	adc	r27, r27
    3e38:	9b 01       	movw	r18, r22
    3e3a:	ac 01       	movw	r20, r24
    3e3c:	bf 57       	subi	r27, 0x7F	; 127
    3e3e:	28 f4       	brcc	.+10     	; 0x3e4a <modf+0x1a>
    3e40:	22 27       	eor	r18, r18
    3e42:	33 27       	eor	r19, r19
    3e44:	44 27       	eor	r20, r20
    3e46:	50 78       	andi	r21, 0x80	; 128
    3e48:	1f c0       	rjmp	.+62     	; 0x3e88 <modf+0x58>
    3e4a:	b7 51       	subi	r27, 0x17	; 23
    3e4c:	88 f4       	brcc	.+34     	; 0x3e70 <modf+0x40>
    3e4e:	ab 2f       	mov	r26, r27
    3e50:	00 24       	eor	r0, r0
    3e52:	46 95       	lsr	r20
    3e54:	37 95       	ror	r19
    3e56:	27 95       	ror	r18
    3e58:	01 1c       	adc	r0, r1
    3e5a:	a3 95       	inc	r26
    3e5c:	d2 f3       	brmi	.-12     	; 0x3e52 <modf+0x22>
    3e5e:	00 20       	and	r0, r0
    3e60:	69 f0       	breq	.+26     	; 0x3e7c <modf+0x4c>
    3e62:	22 0f       	add	r18, r18
    3e64:	33 1f       	adc	r19, r19
    3e66:	44 1f       	adc	r20, r20
    3e68:	b3 95       	inc	r27
    3e6a:	da f3       	brmi	.-10     	; 0x3e62 <modf+0x32>
    3e6c:	0d d0       	rcall	.+26     	; 0x3e88 <modf+0x58>
    3e6e:	d2 cc       	rjmp	.-1628   	; 0x3814 <__subsf3>
    3e70:	61 30       	cpi	r22, 0x01	; 1
    3e72:	71 05       	cpc	r23, r1
    3e74:	a0 e8       	ldi	r26, 0x80	; 128
    3e76:	8a 07       	cpc	r24, r26
    3e78:	b9 46       	sbci	r27, 0x69	; 105
    3e7a:	30 f4       	brcc	.+12     	; 0x3e88 <modf+0x58>
    3e7c:	9b 01       	movw	r18, r22
    3e7e:	ac 01       	movw	r20, r24
    3e80:	66 27       	eor	r22, r22
    3e82:	77 27       	eor	r23, r23
    3e84:	88 27       	eor	r24, r24
    3e86:	90 78       	andi	r25, 0x80	; 128
    3e88:	30 96       	adiw	r30, 0x00	; 0
    3e8a:	21 f0       	breq	.+8      	; 0x3e94 <modf+0x64>
    3e8c:	20 83       	st	Z, r18
    3e8e:	31 83       	std	Z+1, r19	; 0x01
    3e90:	42 83       	std	Z+2, r20	; 0x02
    3e92:	53 83       	std	Z+3, r21	; 0x03
    3e94:	08 95       	ret

00003e96 <__fp_mpack>:
    3e96:	9f 3f       	cpi	r25, 0xFF	; 255
    3e98:	31 f0       	breq	.+12     	; 0x3ea6 <__fp_mpack_finite+0xc>

00003e9a <__fp_mpack_finite>:
    3e9a:	91 50       	subi	r25, 0x01	; 1
    3e9c:	20 f4       	brcc	.+8      	; 0x3ea6 <__fp_mpack_finite+0xc>
    3e9e:	87 95       	ror	r24
    3ea0:	77 95       	ror	r23
    3ea2:	67 95       	ror	r22
    3ea4:	b7 95       	ror	r27
    3ea6:	88 0f       	add	r24, r24
    3ea8:	91 1d       	adc	r25, r1
    3eaa:	96 95       	lsr	r25
    3eac:	87 95       	ror	r24
    3eae:	97 f9       	bld	r25, 7
    3eb0:	08 95       	ret

00003eb2 <__mulsi3>:
    3eb2:	db 01       	movw	r26, r22
    3eb4:	8f 93       	push	r24
    3eb6:	9f 93       	push	r25
    3eb8:	13 d0       	rcall	.+38     	; 0x3ee0 <__muluhisi3>
    3eba:	bf 91       	pop	r27
    3ebc:	af 91       	pop	r26
    3ebe:	a2 9f       	mul	r26, r18
    3ec0:	80 0d       	add	r24, r0
    3ec2:	91 1d       	adc	r25, r1
    3ec4:	a3 9f       	mul	r26, r19
    3ec6:	90 0d       	add	r25, r0
    3ec8:	b2 9f       	mul	r27, r18
    3eca:	90 0d       	add	r25, r0
    3ecc:	11 24       	eor	r1, r1
    3ece:	08 95       	ret

00003ed0 <__tablejump2__>:
    3ed0:	ee 0f       	add	r30, r30
    3ed2:	ff 1f       	adc	r31, r31
    3ed4:	88 1f       	adc	r24, r24
    3ed6:	8b bf       	out	0x3b, r24	; 59
    3ed8:	07 90       	elpm	r0, Z+
    3eda:	f6 91       	elpm	r31, Z
    3edc:	e0 2d       	mov	r30, r0
    3ede:	19 94       	eijmp

00003ee0 <__muluhisi3>:
    3ee0:	09 d0       	rcall	.+18     	; 0x3ef4 <__umulhisi3>
    3ee2:	a5 9f       	mul	r26, r21
    3ee4:	90 0d       	add	r25, r0
    3ee6:	b4 9f       	mul	r27, r20
    3ee8:	90 0d       	add	r25, r0
    3eea:	a4 9f       	mul	r26, r20
    3eec:	80 0d       	add	r24, r0
    3eee:	91 1d       	adc	r25, r1
    3ef0:	11 24       	eor	r1, r1
    3ef2:	08 95       	ret

00003ef4 <__umulhisi3>:
    3ef4:	a2 9f       	mul	r26, r18
    3ef6:	b0 01       	movw	r22, r0
    3ef8:	b3 9f       	mul	r27, r19
    3efa:	c0 01       	movw	r24, r0
    3efc:	a3 9f       	mul	r26, r19
    3efe:	70 0d       	add	r23, r0
    3f00:	81 1d       	adc	r24, r1
    3f02:	11 24       	eor	r1, r1
    3f04:	91 1d       	adc	r25, r1
    3f06:	b2 9f       	mul	r27, r18
    3f08:	70 0d       	add	r23, r0
    3f0a:	81 1d       	adc	r24, r1
    3f0c:	11 24       	eor	r1, r1
    3f0e:	91 1d       	adc	r25, r1
    3f10:	08 95       	ret

00003f12 <memcpy>:
    3f12:	fb 01       	movw	r30, r22
    3f14:	dc 01       	movw	r26, r24
    3f16:	02 c0       	rjmp	.+4      	; 0x3f1c <memcpy+0xa>
    3f18:	01 90       	ld	r0, Z+
    3f1a:	0d 92       	st	X+, r0
    3f1c:	41 50       	subi	r20, 0x01	; 1
    3f1e:	50 40       	sbci	r21, 0x00	; 0
    3f20:	d8 f7       	brcc	.-10     	; 0x3f18 <memcpy+0x6>
    3f22:	08 95       	ret

00003f24 <sprintf>:
    3f24:	0f 93       	push	r16
    3f26:	1f 93       	push	r17
    3f28:	cf 93       	push	r28
    3f2a:	df 93       	push	r29
    3f2c:	cd b7       	in	r28, 0x3d	; 61
    3f2e:	de b7       	in	r29, 0x3e	; 62
    3f30:	2e 97       	sbiw	r28, 0x0e	; 14
    3f32:	0f b6       	in	r0, 0x3f	; 63
    3f34:	f8 94       	cli
    3f36:	de bf       	out	0x3e, r29	; 62
    3f38:	0f be       	out	0x3f, r0	; 63
    3f3a:	cd bf       	out	0x3d, r28	; 61
    3f3c:	0e 89       	ldd	r16, Y+22	; 0x16
    3f3e:	1f 89       	ldd	r17, Y+23	; 0x17
    3f40:	86 e0       	ldi	r24, 0x06	; 6
    3f42:	8c 83       	std	Y+4, r24	; 0x04
    3f44:	1a 83       	std	Y+2, r17	; 0x02
    3f46:	09 83       	std	Y+1, r16	; 0x01
    3f48:	8f ef       	ldi	r24, 0xFF	; 255
    3f4a:	9f e7       	ldi	r25, 0x7F	; 127
    3f4c:	9e 83       	std	Y+6, r25	; 0x06
    3f4e:	8d 83       	std	Y+5, r24	; 0x05
    3f50:	ae 01       	movw	r20, r28
    3f52:	46 5e       	subi	r20, 0xE6	; 230
    3f54:	5f 4f       	sbci	r21, 0xFF	; 255
    3f56:	68 8d       	ldd	r22, Y+24	; 0x18
    3f58:	79 8d       	ldd	r23, Y+25	; 0x19
    3f5a:	ce 01       	movw	r24, r28
    3f5c:	01 96       	adiw	r24, 0x01	; 1
    3f5e:	10 d0       	rcall	.+32     	; 0x3f80 <vfprintf>
    3f60:	ef 81       	ldd	r30, Y+7	; 0x07
    3f62:	f8 85       	ldd	r31, Y+8	; 0x08
    3f64:	e0 0f       	add	r30, r16
    3f66:	f1 1f       	adc	r31, r17
    3f68:	10 82       	st	Z, r1
    3f6a:	2e 96       	adiw	r28, 0x0e	; 14
    3f6c:	0f b6       	in	r0, 0x3f	; 63
    3f6e:	f8 94       	cli
    3f70:	de bf       	out	0x3e, r29	; 62
    3f72:	0f be       	out	0x3f, r0	; 63
    3f74:	cd bf       	out	0x3d, r28	; 61
    3f76:	df 91       	pop	r29
    3f78:	cf 91       	pop	r28
    3f7a:	1f 91       	pop	r17
    3f7c:	0f 91       	pop	r16
    3f7e:	08 95       	ret

00003f80 <vfprintf>:
    3f80:	2f 92       	push	r2
    3f82:	3f 92       	push	r3
    3f84:	4f 92       	push	r4
    3f86:	5f 92       	push	r5
    3f88:	6f 92       	push	r6
    3f8a:	7f 92       	push	r7
    3f8c:	8f 92       	push	r8
    3f8e:	9f 92       	push	r9
    3f90:	af 92       	push	r10
    3f92:	bf 92       	push	r11
    3f94:	cf 92       	push	r12
    3f96:	df 92       	push	r13
    3f98:	ef 92       	push	r14
    3f9a:	ff 92       	push	r15
    3f9c:	0f 93       	push	r16
    3f9e:	1f 93       	push	r17
    3fa0:	cf 93       	push	r28
    3fa2:	df 93       	push	r29
    3fa4:	cd b7       	in	r28, 0x3d	; 61
    3fa6:	de b7       	in	r29, 0x3e	; 62
    3fa8:	2b 97       	sbiw	r28, 0x0b	; 11
    3faa:	0f b6       	in	r0, 0x3f	; 63
    3fac:	f8 94       	cli
    3fae:	de bf       	out	0x3e, r29	; 62
    3fb0:	0f be       	out	0x3f, r0	; 63
    3fb2:	cd bf       	out	0x3d, r28	; 61
    3fb4:	6c 01       	movw	r12, r24
    3fb6:	7b 01       	movw	r14, r22
    3fb8:	8a 01       	movw	r16, r20
    3fba:	fc 01       	movw	r30, r24
    3fbc:	17 82       	std	Z+7, r1	; 0x07
    3fbe:	16 82       	std	Z+6, r1	; 0x06
    3fc0:	83 81       	ldd	r24, Z+3	; 0x03
    3fc2:	81 ff       	sbrs	r24, 1
    3fc4:	bf c1       	rjmp	.+894    	; 0x4344 <vfprintf+0x3c4>
    3fc6:	ce 01       	movw	r24, r28
    3fc8:	01 96       	adiw	r24, 0x01	; 1
    3fca:	3c 01       	movw	r6, r24
    3fcc:	f6 01       	movw	r30, r12
    3fce:	93 81       	ldd	r25, Z+3	; 0x03
    3fd0:	f7 01       	movw	r30, r14
    3fd2:	93 fd       	sbrc	r25, 3
    3fd4:	85 91       	lpm	r24, Z+
    3fd6:	93 ff       	sbrs	r25, 3
    3fd8:	81 91       	ld	r24, Z+
    3fda:	7f 01       	movw	r14, r30
    3fdc:	88 23       	and	r24, r24
    3fde:	09 f4       	brne	.+2      	; 0x3fe2 <vfprintf+0x62>
    3fe0:	ad c1       	rjmp	.+858    	; 0x433c <vfprintf+0x3bc>
    3fe2:	85 32       	cpi	r24, 0x25	; 37
    3fe4:	39 f4       	brne	.+14     	; 0x3ff4 <vfprintf+0x74>
    3fe6:	93 fd       	sbrc	r25, 3
    3fe8:	85 91       	lpm	r24, Z+
    3fea:	93 ff       	sbrs	r25, 3
    3fec:	81 91       	ld	r24, Z+
    3fee:	7f 01       	movw	r14, r30
    3ff0:	85 32       	cpi	r24, 0x25	; 37
    3ff2:	21 f4       	brne	.+8      	; 0x3ffc <vfprintf+0x7c>
    3ff4:	b6 01       	movw	r22, r12
    3ff6:	90 e0       	ldi	r25, 0x00	; 0
    3ff8:	d6 d1       	rcall	.+940    	; 0x43a6 <fputc>
    3ffa:	e8 cf       	rjmp	.-48     	; 0x3fcc <vfprintf+0x4c>
    3ffc:	91 2c       	mov	r9, r1
    3ffe:	21 2c       	mov	r2, r1
    4000:	31 2c       	mov	r3, r1
    4002:	ff e1       	ldi	r31, 0x1F	; 31
    4004:	f3 15       	cp	r31, r3
    4006:	d8 f0       	brcs	.+54     	; 0x403e <vfprintf+0xbe>
    4008:	8b 32       	cpi	r24, 0x2B	; 43
    400a:	79 f0       	breq	.+30     	; 0x402a <vfprintf+0xaa>
    400c:	38 f4       	brcc	.+14     	; 0x401c <vfprintf+0x9c>
    400e:	80 32       	cpi	r24, 0x20	; 32
    4010:	79 f0       	breq	.+30     	; 0x4030 <vfprintf+0xb0>
    4012:	83 32       	cpi	r24, 0x23	; 35
    4014:	a1 f4       	brne	.+40     	; 0x403e <vfprintf+0xbe>
    4016:	23 2d       	mov	r18, r3
    4018:	20 61       	ori	r18, 0x10	; 16
    401a:	1d c0       	rjmp	.+58     	; 0x4056 <vfprintf+0xd6>
    401c:	8d 32       	cpi	r24, 0x2D	; 45
    401e:	61 f0       	breq	.+24     	; 0x4038 <vfprintf+0xb8>
    4020:	80 33       	cpi	r24, 0x30	; 48
    4022:	69 f4       	brne	.+26     	; 0x403e <vfprintf+0xbe>
    4024:	23 2d       	mov	r18, r3
    4026:	21 60       	ori	r18, 0x01	; 1
    4028:	16 c0       	rjmp	.+44     	; 0x4056 <vfprintf+0xd6>
    402a:	83 2d       	mov	r24, r3
    402c:	82 60       	ori	r24, 0x02	; 2
    402e:	38 2e       	mov	r3, r24
    4030:	e3 2d       	mov	r30, r3
    4032:	e4 60       	ori	r30, 0x04	; 4
    4034:	3e 2e       	mov	r3, r30
    4036:	2a c0       	rjmp	.+84     	; 0x408c <vfprintf+0x10c>
    4038:	f3 2d       	mov	r31, r3
    403a:	f8 60       	ori	r31, 0x08	; 8
    403c:	1d c0       	rjmp	.+58     	; 0x4078 <vfprintf+0xf8>
    403e:	37 fc       	sbrc	r3, 7
    4040:	2d c0       	rjmp	.+90     	; 0x409c <vfprintf+0x11c>
    4042:	20 ed       	ldi	r18, 0xD0	; 208
    4044:	28 0f       	add	r18, r24
    4046:	2a 30       	cpi	r18, 0x0A	; 10
    4048:	40 f0       	brcs	.+16     	; 0x405a <vfprintf+0xda>
    404a:	8e 32       	cpi	r24, 0x2E	; 46
    404c:	b9 f4       	brne	.+46     	; 0x407c <vfprintf+0xfc>
    404e:	36 fc       	sbrc	r3, 6
    4050:	75 c1       	rjmp	.+746    	; 0x433c <vfprintf+0x3bc>
    4052:	23 2d       	mov	r18, r3
    4054:	20 64       	ori	r18, 0x40	; 64
    4056:	32 2e       	mov	r3, r18
    4058:	19 c0       	rjmp	.+50     	; 0x408c <vfprintf+0x10c>
    405a:	36 fe       	sbrs	r3, 6
    405c:	06 c0       	rjmp	.+12     	; 0x406a <vfprintf+0xea>
    405e:	8a e0       	ldi	r24, 0x0A	; 10
    4060:	98 9e       	mul	r9, r24
    4062:	20 0d       	add	r18, r0
    4064:	11 24       	eor	r1, r1
    4066:	92 2e       	mov	r9, r18
    4068:	11 c0       	rjmp	.+34     	; 0x408c <vfprintf+0x10c>
    406a:	ea e0       	ldi	r30, 0x0A	; 10
    406c:	2e 9e       	mul	r2, r30
    406e:	20 0d       	add	r18, r0
    4070:	11 24       	eor	r1, r1
    4072:	22 2e       	mov	r2, r18
    4074:	f3 2d       	mov	r31, r3
    4076:	f0 62       	ori	r31, 0x20	; 32
    4078:	3f 2e       	mov	r3, r31
    407a:	08 c0       	rjmp	.+16     	; 0x408c <vfprintf+0x10c>
    407c:	8c 36       	cpi	r24, 0x6C	; 108
    407e:	21 f4       	brne	.+8      	; 0x4088 <vfprintf+0x108>
    4080:	83 2d       	mov	r24, r3
    4082:	80 68       	ori	r24, 0x80	; 128
    4084:	38 2e       	mov	r3, r24
    4086:	02 c0       	rjmp	.+4      	; 0x408c <vfprintf+0x10c>
    4088:	88 36       	cpi	r24, 0x68	; 104
    408a:	41 f4       	brne	.+16     	; 0x409c <vfprintf+0x11c>
    408c:	f7 01       	movw	r30, r14
    408e:	93 fd       	sbrc	r25, 3
    4090:	85 91       	lpm	r24, Z+
    4092:	93 ff       	sbrs	r25, 3
    4094:	81 91       	ld	r24, Z+
    4096:	7f 01       	movw	r14, r30
    4098:	81 11       	cpse	r24, r1
    409a:	b3 cf       	rjmp	.-154    	; 0x4002 <vfprintf+0x82>
    409c:	98 2f       	mov	r25, r24
    409e:	9f 7d       	andi	r25, 0xDF	; 223
    40a0:	95 54       	subi	r25, 0x45	; 69
    40a2:	93 30       	cpi	r25, 0x03	; 3
    40a4:	28 f4       	brcc	.+10     	; 0x40b0 <vfprintf+0x130>
    40a6:	0c 5f       	subi	r16, 0xFC	; 252
    40a8:	1f 4f       	sbci	r17, 0xFF	; 255
    40aa:	9f e3       	ldi	r25, 0x3F	; 63
    40ac:	99 83       	std	Y+1, r25	; 0x01
    40ae:	0d c0       	rjmp	.+26     	; 0x40ca <vfprintf+0x14a>
    40b0:	83 36       	cpi	r24, 0x63	; 99
    40b2:	31 f0       	breq	.+12     	; 0x40c0 <vfprintf+0x140>
    40b4:	83 37       	cpi	r24, 0x73	; 115
    40b6:	71 f0       	breq	.+28     	; 0x40d4 <vfprintf+0x154>
    40b8:	83 35       	cpi	r24, 0x53	; 83
    40ba:	09 f0       	breq	.+2      	; 0x40be <vfprintf+0x13e>
    40bc:	55 c0       	rjmp	.+170    	; 0x4168 <vfprintf+0x1e8>
    40be:	20 c0       	rjmp	.+64     	; 0x4100 <vfprintf+0x180>
    40c0:	f8 01       	movw	r30, r16
    40c2:	80 81       	ld	r24, Z
    40c4:	89 83       	std	Y+1, r24	; 0x01
    40c6:	0e 5f       	subi	r16, 0xFE	; 254
    40c8:	1f 4f       	sbci	r17, 0xFF	; 255
    40ca:	88 24       	eor	r8, r8
    40cc:	83 94       	inc	r8
    40ce:	91 2c       	mov	r9, r1
    40d0:	53 01       	movw	r10, r6
    40d2:	12 c0       	rjmp	.+36     	; 0x40f8 <vfprintf+0x178>
    40d4:	28 01       	movw	r4, r16
    40d6:	f2 e0       	ldi	r31, 0x02	; 2
    40d8:	4f 0e       	add	r4, r31
    40da:	51 1c       	adc	r5, r1
    40dc:	f8 01       	movw	r30, r16
    40de:	a0 80       	ld	r10, Z
    40e0:	b1 80       	ldd	r11, Z+1	; 0x01
    40e2:	36 fe       	sbrs	r3, 6
    40e4:	03 c0       	rjmp	.+6      	; 0x40ec <vfprintf+0x16c>
    40e6:	69 2d       	mov	r22, r9
    40e8:	70 e0       	ldi	r23, 0x00	; 0
    40ea:	02 c0       	rjmp	.+4      	; 0x40f0 <vfprintf+0x170>
    40ec:	6f ef       	ldi	r22, 0xFF	; 255
    40ee:	7f ef       	ldi	r23, 0xFF	; 255
    40f0:	c5 01       	movw	r24, r10
    40f2:	4e d1       	rcall	.+668    	; 0x4390 <strnlen>
    40f4:	4c 01       	movw	r8, r24
    40f6:	82 01       	movw	r16, r4
    40f8:	f3 2d       	mov	r31, r3
    40fa:	ff 77       	andi	r31, 0x7F	; 127
    40fc:	3f 2e       	mov	r3, r31
    40fe:	15 c0       	rjmp	.+42     	; 0x412a <vfprintf+0x1aa>
    4100:	28 01       	movw	r4, r16
    4102:	22 e0       	ldi	r18, 0x02	; 2
    4104:	42 0e       	add	r4, r18
    4106:	51 1c       	adc	r5, r1
    4108:	f8 01       	movw	r30, r16
    410a:	a0 80       	ld	r10, Z
    410c:	b1 80       	ldd	r11, Z+1	; 0x01
    410e:	36 fe       	sbrs	r3, 6
    4110:	03 c0       	rjmp	.+6      	; 0x4118 <vfprintf+0x198>
    4112:	69 2d       	mov	r22, r9
    4114:	70 e0       	ldi	r23, 0x00	; 0
    4116:	02 c0       	rjmp	.+4      	; 0x411c <vfprintf+0x19c>
    4118:	6f ef       	ldi	r22, 0xFF	; 255
    411a:	7f ef       	ldi	r23, 0xFF	; 255
    411c:	c5 01       	movw	r24, r10
    411e:	2d d1       	rcall	.+602    	; 0x437a <strnlen_P>
    4120:	4c 01       	movw	r8, r24
    4122:	f3 2d       	mov	r31, r3
    4124:	f0 68       	ori	r31, 0x80	; 128
    4126:	3f 2e       	mov	r3, r31
    4128:	82 01       	movw	r16, r4
    412a:	33 fc       	sbrc	r3, 3
    412c:	19 c0       	rjmp	.+50     	; 0x4160 <vfprintf+0x1e0>
    412e:	82 2d       	mov	r24, r2
    4130:	90 e0       	ldi	r25, 0x00	; 0
    4132:	88 16       	cp	r8, r24
    4134:	99 06       	cpc	r9, r25
    4136:	a0 f4       	brcc	.+40     	; 0x4160 <vfprintf+0x1e0>
    4138:	b6 01       	movw	r22, r12
    413a:	80 e2       	ldi	r24, 0x20	; 32
    413c:	90 e0       	ldi	r25, 0x00	; 0
    413e:	33 d1       	rcall	.+614    	; 0x43a6 <fputc>
    4140:	2a 94       	dec	r2
    4142:	f5 cf       	rjmp	.-22     	; 0x412e <vfprintf+0x1ae>
    4144:	f5 01       	movw	r30, r10
    4146:	37 fc       	sbrc	r3, 7
    4148:	85 91       	lpm	r24, Z+
    414a:	37 fe       	sbrs	r3, 7
    414c:	81 91       	ld	r24, Z+
    414e:	5f 01       	movw	r10, r30
    4150:	b6 01       	movw	r22, r12
    4152:	90 e0       	ldi	r25, 0x00	; 0
    4154:	28 d1       	rcall	.+592    	; 0x43a6 <fputc>
    4156:	21 10       	cpse	r2, r1
    4158:	2a 94       	dec	r2
    415a:	21 e0       	ldi	r18, 0x01	; 1
    415c:	82 1a       	sub	r8, r18
    415e:	91 08       	sbc	r9, r1
    4160:	81 14       	cp	r8, r1
    4162:	91 04       	cpc	r9, r1
    4164:	79 f7       	brne	.-34     	; 0x4144 <vfprintf+0x1c4>
    4166:	e1 c0       	rjmp	.+450    	; 0x432a <vfprintf+0x3aa>
    4168:	84 36       	cpi	r24, 0x64	; 100
    416a:	11 f0       	breq	.+4      	; 0x4170 <vfprintf+0x1f0>
    416c:	89 36       	cpi	r24, 0x69	; 105
    416e:	39 f5       	brne	.+78     	; 0x41be <vfprintf+0x23e>
    4170:	f8 01       	movw	r30, r16
    4172:	37 fe       	sbrs	r3, 7
    4174:	07 c0       	rjmp	.+14     	; 0x4184 <vfprintf+0x204>
    4176:	60 81       	ld	r22, Z
    4178:	71 81       	ldd	r23, Z+1	; 0x01
    417a:	82 81       	ldd	r24, Z+2	; 0x02
    417c:	93 81       	ldd	r25, Z+3	; 0x03
    417e:	0c 5f       	subi	r16, 0xFC	; 252
    4180:	1f 4f       	sbci	r17, 0xFF	; 255
    4182:	08 c0       	rjmp	.+16     	; 0x4194 <vfprintf+0x214>
    4184:	60 81       	ld	r22, Z
    4186:	71 81       	ldd	r23, Z+1	; 0x01
    4188:	07 2e       	mov	r0, r23
    418a:	00 0c       	add	r0, r0
    418c:	88 0b       	sbc	r24, r24
    418e:	99 0b       	sbc	r25, r25
    4190:	0e 5f       	subi	r16, 0xFE	; 254
    4192:	1f 4f       	sbci	r17, 0xFF	; 255
    4194:	f3 2d       	mov	r31, r3
    4196:	ff 76       	andi	r31, 0x6F	; 111
    4198:	3f 2e       	mov	r3, r31
    419a:	97 ff       	sbrs	r25, 7
    419c:	09 c0       	rjmp	.+18     	; 0x41b0 <vfprintf+0x230>
    419e:	90 95       	com	r25
    41a0:	80 95       	com	r24
    41a2:	70 95       	com	r23
    41a4:	61 95       	neg	r22
    41a6:	7f 4f       	sbci	r23, 0xFF	; 255
    41a8:	8f 4f       	sbci	r24, 0xFF	; 255
    41aa:	9f 4f       	sbci	r25, 0xFF	; 255
    41ac:	f0 68       	ori	r31, 0x80	; 128
    41ae:	3f 2e       	mov	r3, r31
    41b0:	2a e0       	ldi	r18, 0x0A	; 10
    41b2:	30 e0       	ldi	r19, 0x00	; 0
    41b4:	a3 01       	movw	r20, r6
    41b6:	33 d1       	rcall	.+614    	; 0x441e <__ultoa_invert>
    41b8:	88 2e       	mov	r8, r24
    41ba:	86 18       	sub	r8, r6
    41bc:	44 c0       	rjmp	.+136    	; 0x4246 <vfprintf+0x2c6>
    41be:	85 37       	cpi	r24, 0x75	; 117
    41c0:	31 f4       	brne	.+12     	; 0x41ce <vfprintf+0x24e>
    41c2:	23 2d       	mov	r18, r3
    41c4:	2f 7e       	andi	r18, 0xEF	; 239
    41c6:	b2 2e       	mov	r11, r18
    41c8:	2a e0       	ldi	r18, 0x0A	; 10
    41ca:	30 e0       	ldi	r19, 0x00	; 0
    41cc:	25 c0       	rjmp	.+74     	; 0x4218 <vfprintf+0x298>
    41ce:	93 2d       	mov	r25, r3
    41d0:	99 7f       	andi	r25, 0xF9	; 249
    41d2:	b9 2e       	mov	r11, r25
    41d4:	8f 36       	cpi	r24, 0x6F	; 111
    41d6:	c1 f0       	breq	.+48     	; 0x4208 <vfprintf+0x288>
    41d8:	18 f4       	brcc	.+6      	; 0x41e0 <vfprintf+0x260>
    41da:	88 35       	cpi	r24, 0x58	; 88
    41dc:	79 f0       	breq	.+30     	; 0x41fc <vfprintf+0x27c>
    41de:	ae c0       	rjmp	.+348    	; 0x433c <vfprintf+0x3bc>
    41e0:	80 37       	cpi	r24, 0x70	; 112
    41e2:	19 f0       	breq	.+6      	; 0x41ea <vfprintf+0x26a>
    41e4:	88 37       	cpi	r24, 0x78	; 120
    41e6:	21 f0       	breq	.+8      	; 0x41f0 <vfprintf+0x270>
    41e8:	a9 c0       	rjmp	.+338    	; 0x433c <vfprintf+0x3bc>
    41ea:	e9 2f       	mov	r30, r25
    41ec:	e0 61       	ori	r30, 0x10	; 16
    41ee:	be 2e       	mov	r11, r30
    41f0:	b4 fe       	sbrs	r11, 4
    41f2:	0d c0       	rjmp	.+26     	; 0x420e <vfprintf+0x28e>
    41f4:	fb 2d       	mov	r31, r11
    41f6:	f4 60       	ori	r31, 0x04	; 4
    41f8:	bf 2e       	mov	r11, r31
    41fa:	09 c0       	rjmp	.+18     	; 0x420e <vfprintf+0x28e>
    41fc:	34 fe       	sbrs	r3, 4
    41fe:	0a c0       	rjmp	.+20     	; 0x4214 <vfprintf+0x294>
    4200:	29 2f       	mov	r18, r25
    4202:	26 60       	ori	r18, 0x06	; 6
    4204:	b2 2e       	mov	r11, r18
    4206:	06 c0       	rjmp	.+12     	; 0x4214 <vfprintf+0x294>
    4208:	28 e0       	ldi	r18, 0x08	; 8
    420a:	30 e0       	ldi	r19, 0x00	; 0
    420c:	05 c0       	rjmp	.+10     	; 0x4218 <vfprintf+0x298>
    420e:	20 e1       	ldi	r18, 0x10	; 16
    4210:	30 e0       	ldi	r19, 0x00	; 0
    4212:	02 c0       	rjmp	.+4      	; 0x4218 <vfprintf+0x298>
    4214:	20 e1       	ldi	r18, 0x10	; 16
    4216:	32 e0       	ldi	r19, 0x02	; 2
    4218:	f8 01       	movw	r30, r16
    421a:	b7 fe       	sbrs	r11, 7
    421c:	07 c0       	rjmp	.+14     	; 0x422c <vfprintf+0x2ac>
    421e:	60 81       	ld	r22, Z
    4220:	71 81       	ldd	r23, Z+1	; 0x01
    4222:	82 81       	ldd	r24, Z+2	; 0x02
    4224:	93 81       	ldd	r25, Z+3	; 0x03
    4226:	0c 5f       	subi	r16, 0xFC	; 252
    4228:	1f 4f       	sbci	r17, 0xFF	; 255
    422a:	06 c0       	rjmp	.+12     	; 0x4238 <vfprintf+0x2b8>
    422c:	60 81       	ld	r22, Z
    422e:	71 81       	ldd	r23, Z+1	; 0x01
    4230:	80 e0       	ldi	r24, 0x00	; 0
    4232:	90 e0       	ldi	r25, 0x00	; 0
    4234:	0e 5f       	subi	r16, 0xFE	; 254
    4236:	1f 4f       	sbci	r17, 0xFF	; 255
    4238:	a3 01       	movw	r20, r6
    423a:	f1 d0       	rcall	.+482    	; 0x441e <__ultoa_invert>
    423c:	88 2e       	mov	r8, r24
    423e:	86 18       	sub	r8, r6
    4240:	fb 2d       	mov	r31, r11
    4242:	ff 77       	andi	r31, 0x7F	; 127
    4244:	3f 2e       	mov	r3, r31
    4246:	36 fe       	sbrs	r3, 6
    4248:	0d c0       	rjmp	.+26     	; 0x4264 <vfprintf+0x2e4>
    424a:	23 2d       	mov	r18, r3
    424c:	2e 7f       	andi	r18, 0xFE	; 254
    424e:	a2 2e       	mov	r10, r18
    4250:	89 14       	cp	r8, r9
    4252:	58 f4       	brcc	.+22     	; 0x426a <vfprintf+0x2ea>
    4254:	34 fe       	sbrs	r3, 4
    4256:	0b c0       	rjmp	.+22     	; 0x426e <vfprintf+0x2ee>
    4258:	32 fc       	sbrc	r3, 2
    425a:	09 c0       	rjmp	.+18     	; 0x426e <vfprintf+0x2ee>
    425c:	83 2d       	mov	r24, r3
    425e:	8e 7e       	andi	r24, 0xEE	; 238
    4260:	a8 2e       	mov	r10, r24
    4262:	05 c0       	rjmp	.+10     	; 0x426e <vfprintf+0x2ee>
    4264:	b8 2c       	mov	r11, r8
    4266:	a3 2c       	mov	r10, r3
    4268:	03 c0       	rjmp	.+6      	; 0x4270 <vfprintf+0x2f0>
    426a:	b8 2c       	mov	r11, r8
    426c:	01 c0       	rjmp	.+2      	; 0x4270 <vfprintf+0x2f0>
    426e:	b9 2c       	mov	r11, r9
    4270:	a4 fe       	sbrs	r10, 4
    4272:	0f c0       	rjmp	.+30     	; 0x4292 <vfprintf+0x312>
    4274:	fe 01       	movw	r30, r28
    4276:	e8 0d       	add	r30, r8
    4278:	f1 1d       	adc	r31, r1
    427a:	80 81       	ld	r24, Z
    427c:	80 33       	cpi	r24, 0x30	; 48
    427e:	21 f4       	brne	.+8      	; 0x4288 <vfprintf+0x308>
    4280:	9a 2d       	mov	r25, r10
    4282:	99 7e       	andi	r25, 0xE9	; 233
    4284:	a9 2e       	mov	r10, r25
    4286:	09 c0       	rjmp	.+18     	; 0x429a <vfprintf+0x31a>
    4288:	a2 fe       	sbrs	r10, 2
    428a:	06 c0       	rjmp	.+12     	; 0x4298 <vfprintf+0x318>
    428c:	b3 94       	inc	r11
    428e:	b3 94       	inc	r11
    4290:	04 c0       	rjmp	.+8      	; 0x429a <vfprintf+0x31a>
    4292:	8a 2d       	mov	r24, r10
    4294:	86 78       	andi	r24, 0x86	; 134
    4296:	09 f0       	breq	.+2      	; 0x429a <vfprintf+0x31a>
    4298:	b3 94       	inc	r11
    429a:	a3 fc       	sbrc	r10, 3
    429c:	10 c0       	rjmp	.+32     	; 0x42be <vfprintf+0x33e>
    429e:	a0 fe       	sbrs	r10, 0
    42a0:	06 c0       	rjmp	.+12     	; 0x42ae <vfprintf+0x32e>
    42a2:	b2 14       	cp	r11, r2
    42a4:	80 f4       	brcc	.+32     	; 0x42c6 <vfprintf+0x346>
    42a6:	28 0c       	add	r2, r8
    42a8:	92 2c       	mov	r9, r2
    42aa:	9b 18       	sub	r9, r11
    42ac:	0d c0       	rjmp	.+26     	; 0x42c8 <vfprintf+0x348>
    42ae:	b2 14       	cp	r11, r2
    42b0:	58 f4       	brcc	.+22     	; 0x42c8 <vfprintf+0x348>
    42b2:	b6 01       	movw	r22, r12
    42b4:	80 e2       	ldi	r24, 0x20	; 32
    42b6:	90 e0       	ldi	r25, 0x00	; 0
    42b8:	76 d0       	rcall	.+236    	; 0x43a6 <fputc>
    42ba:	b3 94       	inc	r11
    42bc:	f8 cf       	rjmp	.-16     	; 0x42ae <vfprintf+0x32e>
    42be:	b2 14       	cp	r11, r2
    42c0:	18 f4       	brcc	.+6      	; 0x42c8 <vfprintf+0x348>
    42c2:	2b 18       	sub	r2, r11
    42c4:	02 c0       	rjmp	.+4      	; 0x42ca <vfprintf+0x34a>
    42c6:	98 2c       	mov	r9, r8
    42c8:	21 2c       	mov	r2, r1
    42ca:	a4 fe       	sbrs	r10, 4
    42cc:	0f c0       	rjmp	.+30     	; 0x42ec <vfprintf+0x36c>
    42ce:	b6 01       	movw	r22, r12
    42d0:	80 e3       	ldi	r24, 0x30	; 48
    42d2:	90 e0       	ldi	r25, 0x00	; 0
    42d4:	68 d0       	rcall	.+208    	; 0x43a6 <fputc>
    42d6:	a2 fe       	sbrs	r10, 2
    42d8:	16 c0       	rjmp	.+44     	; 0x4306 <vfprintf+0x386>
    42da:	a1 fc       	sbrc	r10, 1
    42dc:	03 c0       	rjmp	.+6      	; 0x42e4 <vfprintf+0x364>
    42de:	88 e7       	ldi	r24, 0x78	; 120
    42e0:	90 e0       	ldi	r25, 0x00	; 0
    42e2:	02 c0       	rjmp	.+4      	; 0x42e8 <vfprintf+0x368>
    42e4:	88 e5       	ldi	r24, 0x58	; 88
    42e6:	90 e0       	ldi	r25, 0x00	; 0
    42e8:	b6 01       	movw	r22, r12
    42ea:	0c c0       	rjmp	.+24     	; 0x4304 <vfprintf+0x384>
    42ec:	8a 2d       	mov	r24, r10
    42ee:	86 78       	andi	r24, 0x86	; 134
    42f0:	51 f0       	breq	.+20     	; 0x4306 <vfprintf+0x386>
    42f2:	a1 fe       	sbrs	r10, 1
    42f4:	02 c0       	rjmp	.+4      	; 0x42fa <vfprintf+0x37a>
    42f6:	8b e2       	ldi	r24, 0x2B	; 43
    42f8:	01 c0       	rjmp	.+2      	; 0x42fc <vfprintf+0x37c>
    42fa:	80 e2       	ldi	r24, 0x20	; 32
    42fc:	a7 fc       	sbrc	r10, 7
    42fe:	8d e2       	ldi	r24, 0x2D	; 45
    4300:	b6 01       	movw	r22, r12
    4302:	90 e0       	ldi	r25, 0x00	; 0
    4304:	50 d0       	rcall	.+160    	; 0x43a6 <fputc>
    4306:	89 14       	cp	r8, r9
    4308:	30 f4       	brcc	.+12     	; 0x4316 <vfprintf+0x396>
    430a:	b6 01       	movw	r22, r12
    430c:	80 e3       	ldi	r24, 0x30	; 48
    430e:	90 e0       	ldi	r25, 0x00	; 0
    4310:	4a d0       	rcall	.+148    	; 0x43a6 <fputc>
    4312:	9a 94       	dec	r9
    4314:	f8 cf       	rjmp	.-16     	; 0x4306 <vfprintf+0x386>
    4316:	8a 94       	dec	r8
    4318:	f3 01       	movw	r30, r6
    431a:	e8 0d       	add	r30, r8
    431c:	f1 1d       	adc	r31, r1
    431e:	80 81       	ld	r24, Z
    4320:	b6 01       	movw	r22, r12
    4322:	90 e0       	ldi	r25, 0x00	; 0
    4324:	40 d0       	rcall	.+128    	; 0x43a6 <fputc>
    4326:	81 10       	cpse	r8, r1
    4328:	f6 cf       	rjmp	.-20     	; 0x4316 <vfprintf+0x396>
    432a:	22 20       	and	r2, r2
    432c:	09 f4       	brne	.+2      	; 0x4330 <vfprintf+0x3b0>
    432e:	4e ce       	rjmp	.-868    	; 0x3fcc <vfprintf+0x4c>
    4330:	b6 01       	movw	r22, r12
    4332:	80 e2       	ldi	r24, 0x20	; 32
    4334:	90 e0       	ldi	r25, 0x00	; 0
    4336:	37 d0       	rcall	.+110    	; 0x43a6 <fputc>
    4338:	2a 94       	dec	r2
    433a:	f7 cf       	rjmp	.-18     	; 0x432a <vfprintf+0x3aa>
    433c:	f6 01       	movw	r30, r12
    433e:	86 81       	ldd	r24, Z+6	; 0x06
    4340:	97 81       	ldd	r25, Z+7	; 0x07
    4342:	02 c0       	rjmp	.+4      	; 0x4348 <vfprintf+0x3c8>
    4344:	8f ef       	ldi	r24, 0xFF	; 255
    4346:	9f ef       	ldi	r25, 0xFF	; 255
    4348:	2b 96       	adiw	r28, 0x0b	; 11
    434a:	0f b6       	in	r0, 0x3f	; 63
    434c:	f8 94       	cli
    434e:	de bf       	out	0x3e, r29	; 62
    4350:	0f be       	out	0x3f, r0	; 63
    4352:	cd bf       	out	0x3d, r28	; 61
    4354:	df 91       	pop	r29
    4356:	cf 91       	pop	r28
    4358:	1f 91       	pop	r17
    435a:	0f 91       	pop	r16
    435c:	ff 90       	pop	r15
    435e:	ef 90       	pop	r14
    4360:	df 90       	pop	r13
    4362:	cf 90       	pop	r12
    4364:	bf 90       	pop	r11
    4366:	af 90       	pop	r10
    4368:	9f 90       	pop	r9
    436a:	8f 90       	pop	r8
    436c:	7f 90       	pop	r7
    436e:	6f 90       	pop	r6
    4370:	5f 90       	pop	r5
    4372:	4f 90       	pop	r4
    4374:	3f 90       	pop	r3
    4376:	2f 90       	pop	r2
    4378:	08 95       	ret

0000437a <strnlen_P>:
    437a:	fc 01       	movw	r30, r24
    437c:	05 90       	lpm	r0, Z+
    437e:	61 50       	subi	r22, 0x01	; 1
    4380:	70 40       	sbci	r23, 0x00	; 0
    4382:	01 10       	cpse	r0, r1
    4384:	d8 f7       	brcc	.-10     	; 0x437c <strnlen_P+0x2>
    4386:	80 95       	com	r24
    4388:	90 95       	com	r25
    438a:	8e 0f       	add	r24, r30
    438c:	9f 1f       	adc	r25, r31
    438e:	08 95       	ret

00004390 <strnlen>:
    4390:	fc 01       	movw	r30, r24
    4392:	61 50       	subi	r22, 0x01	; 1
    4394:	70 40       	sbci	r23, 0x00	; 0
    4396:	01 90       	ld	r0, Z+
    4398:	01 10       	cpse	r0, r1
    439a:	d8 f7       	brcc	.-10     	; 0x4392 <strnlen+0x2>
    439c:	80 95       	com	r24
    439e:	90 95       	com	r25
    43a0:	8e 0f       	add	r24, r30
    43a2:	9f 1f       	adc	r25, r31
    43a4:	08 95       	ret

000043a6 <fputc>:
    43a6:	0f 93       	push	r16
    43a8:	1f 93       	push	r17
    43aa:	cf 93       	push	r28
    43ac:	df 93       	push	r29
    43ae:	fb 01       	movw	r30, r22
    43b0:	23 81       	ldd	r18, Z+3	; 0x03
    43b2:	21 fd       	sbrc	r18, 1
    43b4:	03 c0       	rjmp	.+6      	; 0x43bc <fputc+0x16>
    43b6:	8f ef       	ldi	r24, 0xFF	; 255
    43b8:	9f ef       	ldi	r25, 0xFF	; 255
    43ba:	2c c0       	rjmp	.+88     	; 0x4414 <fputc+0x6e>
    43bc:	22 ff       	sbrs	r18, 2
    43be:	16 c0       	rjmp	.+44     	; 0x43ec <fputc+0x46>
    43c0:	46 81       	ldd	r20, Z+6	; 0x06
    43c2:	57 81       	ldd	r21, Z+7	; 0x07
    43c4:	24 81       	ldd	r18, Z+4	; 0x04
    43c6:	35 81       	ldd	r19, Z+5	; 0x05
    43c8:	42 17       	cp	r20, r18
    43ca:	53 07       	cpc	r21, r19
    43cc:	44 f4       	brge	.+16     	; 0x43de <fputc+0x38>
    43ce:	a0 81       	ld	r26, Z
    43d0:	b1 81       	ldd	r27, Z+1	; 0x01
    43d2:	9d 01       	movw	r18, r26
    43d4:	2f 5f       	subi	r18, 0xFF	; 255
    43d6:	3f 4f       	sbci	r19, 0xFF	; 255
    43d8:	31 83       	std	Z+1, r19	; 0x01
    43da:	20 83       	st	Z, r18
    43dc:	8c 93       	st	X, r24
    43de:	26 81       	ldd	r18, Z+6	; 0x06
    43e0:	37 81       	ldd	r19, Z+7	; 0x07
    43e2:	2f 5f       	subi	r18, 0xFF	; 255
    43e4:	3f 4f       	sbci	r19, 0xFF	; 255
    43e6:	37 83       	std	Z+7, r19	; 0x07
    43e8:	26 83       	std	Z+6, r18	; 0x06
    43ea:	14 c0       	rjmp	.+40     	; 0x4414 <fputc+0x6e>
    43ec:	8b 01       	movw	r16, r22
    43ee:	ec 01       	movw	r28, r24
    43f0:	fb 01       	movw	r30, r22
    43f2:	00 84       	ldd	r0, Z+8	; 0x08
    43f4:	f1 85       	ldd	r31, Z+9	; 0x09
    43f6:	e0 2d       	mov	r30, r0
    43f8:	19 95       	eicall
    43fa:	89 2b       	or	r24, r25
    43fc:	e1 f6       	brne	.-72     	; 0x43b6 <fputc+0x10>
    43fe:	d8 01       	movw	r26, r16
    4400:	16 96       	adiw	r26, 0x06	; 6
    4402:	8d 91       	ld	r24, X+
    4404:	9c 91       	ld	r25, X
    4406:	17 97       	sbiw	r26, 0x07	; 7
    4408:	01 96       	adiw	r24, 0x01	; 1
    440a:	17 96       	adiw	r26, 0x07	; 7
    440c:	9c 93       	st	X, r25
    440e:	8e 93       	st	-X, r24
    4410:	16 97       	sbiw	r26, 0x06	; 6
    4412:	ce 01       	movw	r24, r28
    4414:	df 91       	pop	r29
    4416:	cf 91       	pop	r28
    4418:	1f 91       	pop	r17
    441a:	0f 91       	pop	r16
    441c:	08 95       	ret

0000441e <__ultoa_invert>:
    441e:	fa 01       	movw	r30, r20
    4420:	aa 27       	eor	r26, r26
    4422:	28 30       	cpi	r18, 0x08	; 8
    4424:	51 f1       	breq	.+84     	; 0x447a <__ultoa_invert+0x5c>
    4426:	20 31       	cpi	r18, 0x10	; 16
    4428:	81 f1       	breq	.+96     	; 0x448a <__ultoa_invert+0x6c>
    442a:	e8 94       	clt
    442c:	6f 93       	push	r22
    442e:	6e 7f       	andi	r22, 0xFE	; 254
    4430:	6e 5f       	subi	r22, 0xFE	; 254
    4432:	7f 4f       	sbci	r23, 0xFF	; 255
    4434:	8f 4f       	sbci	r24, 0xFF	; 255
    4436:	9f 4f       	sbci	r25, 0xFF	; 255
    4438:	af 4f       	sbci	r26, 0xFF	; 255
    443a:	b1 e0       	ldi	r27, 0x01	; 1
    443c:	3e d0       	rcall	.+124    	; 0x44ba <__ultoa_invert+0x9c>
    443e:	b4 e0       	ldi	r27, 0x04	; 4
    4440:	3c d0       	rcall	.+120    	; 0x44ba <__ultoa_invert+0x9c>
    4442:	67 0f       	add	r22, r23
    4444:	78 1f       	adc	r23, r24
    4446:	89 1f       	adc	r24, r25
    4448:	9a 1f       	adc	r25, r26
    444a:	a1 1d       	adc	r26, r1
    444c:	68 0f       	add	r22, r24
    444e:	79 1f       	adc	r23, r25
    4450:	8a 1f       	adc	r24, r26
    4452:	91 1d       	adc	r25, r1
    4454:	a1 1d       	adc	r26, r1
    4456:	6a 0f       	add	r22, r26
    4458:	71 1d       	adc	r23, r1
    445a:	81 1d       	adc	r24, r1
    445c:	91 1d       	adc	r25, r1
    445e:	a1 1d       	adc	r26, r1
    4460:	20 d0       	rcall	.+64     	; 0x44a2 <__ultoa_invert+0x84>
    4462:	09 f4       	brne	.+2      	; 0x4466 <__ultoa_invert+0x48>
    4464:	68 94       	set
    4466:	3f 91       	pop	r19
    4468:	2a e0       	ldi	r18, 0x0A	; 10
    446a:	26 9f       	mul	r18, r22
    446c:	11 24       	eor	r1, r1
    446e:	30 19       	sub	r19, r0
    4470:	30 5d       	subi	r19, 0xD0	; 208
    4472:	31 93       	st	Z+, r19
    4474:	de f6       	brtc	.-74     	; 0x442c <__ultoa_invert+0xe>
    4476:	cf 01       	movw	r24, r30
    4478:	08 95       	ret
    447a:	46 2f       	mov	r20, r22
    447c:	47 70       	andi	r20, 0x07	; 7
    447e:	40 5d       	subi	r20, 0xD0	; 208
    4480:	41 93       	st	Z+, r20
    4482:	b3 e0       	ldi	r27, 0x03	; 3
    4484:	0f d0       	rcall	.+30     	; 0x44a4 <__ultoa_invert+0x86>
    4486:	c9 f7       	brne	.-14     	; 0x447a <__ultoa_invert+0x5c>
    4488:	f6 cf       	rjmp	.-20     	; 0x4476 <__ultoa_invert+0x58>
    448a:	46 2f       	mov	r20, r22
    448c:	4f 70       	andi	r20, 0x0F	; 15
    448e:	40 5d       	subi	r20, 0xD0	; 208
    4490:	4a 33       	cpi	r20, 0x3A	; 58
    4492:	18 f0       	brcs	.+6      	; 0x449a <__ultoa_invert+0x7c>
    4494:	49 5d       	subi	r20, 0xD9	; 217
    4496:	31 fd       	sbrc	r19, 1
    4498:	40 52       	subi	r20, 0x20	; 32
    449a:	41 93       	st	Z+, r20
    449c:	02 d0       	rcall	.+4      	; 0x44a2 <__ultoa_invert+0x84>
    449e:	a9 f7       	brne	.-22     	; 0x448a <__ultoa_invert+0x6c>
    44a0:	ea cf       	rjmp	.-44     	; 0x4476 <__ultoa_invert+0x58>
    44a2:	b4 e0       	ldi	r27, 0x04	; 4
    44a4:	a6 95       	lsr	r26
    44a6:	97 95       	ror	r25
    44a8:	87 95       	ror	r24
    44aa:	77 95       	ror	r23
    44ac:	67 95       	ror	r22
    44ae:	ba 95       	dec	r27
    44b0:	c9 f7       	brne	.-14     	; 0x44a4 <__ultoa_invert+0x86>
    44b2:	00 97       	sbiw	r24, 0x00	; 0
    44b4:	61 05       	cpc	r22, r1
    44b6:	71 05       	cpc	r23, r1
    44b8:	08 95       	ret
    44ba:	9b 01       	movw	r18, r22
    44bc:	ac 01       	movw	r20, r24
    44be:	0a 2e       	mov	r0, r26
    44c0:	06 94       	lsr	r0
    44c2:	57 95       	ror	r21
    44c4:	47 95       	ror	r20
    44c6:	37 95       	ror	r19
    44c8:	27 95       	ror	r18
    44ca:	ba 95       	dec	r27
    44cc:	c9 f7       	brne	.-14     	; 0x44c0 <__ultoa_invert+0xa2>
    44ce:	62 0f       	add	r22, r18
    44d0:	73 1f       	adc	r23, r19
    44d2:	84 1f       	adc	r24, r20
    44d4:	95 1f       	adc	r25, r21
    44d6:	a0 1d       	adc	r26, r0
    44d8:	08 95       	ret

000044da <eeprom_read_dword>:
    44da:	a6 e1       	ldi	r26, 0x16	; 22
    44dc:	b0 e0       	ldi	r27, 0x00	; 0
    44de:	44 e0       	ldi	r20, 0x04	; 4
    44e0:	50 e0       	ldi	r21, 0x00	; 0
    44e2:	02 c0       	rjmp	.+4      	; 0x44e8 <eeprom_read_blraw>

000044e4 <eeprom_read_block>:
    44e4:	dc 01       	movw	r26, r24
    44e6:	cb 01       	movw	r24, r22

000044e8 <eeprom_read_blraw>:
    44e8:	fc 01       	movw	r30, r24
    44ea:	f9 99       	sbic	0x1f, 1	; 31
    44ec:	fe cf       	rjmp	.-4      	; 0x44ea <eeprom_read_blraw+0x2>
    44ee:	06 c0       	rjmp	.+12     	; 0x44fc <eeprom_read_blraw+0x14>
    44f0:	f2 bd       	out	0x22, r31	; 34
    44f2:	e1 bd       	out	0x21, r30	; 33
    44f4:	f8 9a       	sbi	0x1f, 0	; 31
    44f6:	31 96       	adiw	r30, 0x01	; 1
    44f8:	00 b4       	in	r0, 0x20	; 32
    44fa:	0d 92       	st	X+, r0
    44fc:	41 50       	subi	r20, 0x01	; 1
    44fe:	50 40       	sbci	r21, 0x00	; 0
    4500:	b8 f7       	brcc	.-18     	; 0x44f0 <eeprom_read_blraw+0x8>
    4502:	08 95       	ret

00004504 <_exit>:
    4504:	f8 94       	cli

00004506 <__stop_program>:
    4506:	ff cf       	rjmp	.-2      	; 0x4506 <__stop_program>
